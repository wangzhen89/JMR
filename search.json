[{"path":"index.html","id":"前言","chapter":"前言","heading":"前言","text":"本书为 Joint Models Longitudinal Time--Event Data Applications R 的翻译。本书可作为医学研究中的生存数据建模（尤其是第 8 章的联合模型）的后续文本。可点击带 \\(\\blacktriangleright\\) 的标题以展开图表，例如\n原书出版于 2012 年，鉴于 R 以及 JM 包的更新，许多结果无法复现。询问作者后，作者回复道 JM 包已不再维护，建议使用 JMbayes2，但该包提供基于 MCMC 的贝叶斯方法。为尊重原著，本翻译基于原书以及勘误，代码的结果未更改，但不影响参考学习。","code":""},{"path":"index.html","id":"原书前言","chapter":"前言","heading":"原书前言","text":"纵向数据与事件时间数据的联合模型已成为分析随访数据的宝贵工具。这些模型主要适用于两种情况：第一，当重点是生存结局并且我们希望考虑误差测量的内生性时依协变量的影响时；第二，当重点是纵向结果并且希望校正非随机脱落时。由于能在简单统计工具无法提供有效推断的情况下提供有效推断，并且具有广泛的应用范围，在过去 25 年中，联合建模领域取得了许多进展。尽管人们对联合模型的兴趣及其发展已经很普遍，但关于它们的信息也同样分散在介绍该领域最新进展的文章中，以及专门用于纵向或生存数据分析的书籍章节中。然而，似乎没有专门针对这类模型的专著或文本。因此，撰写本书的目的是提供一个纵向与生存数据的联合模型的理论和应用的概述。相关文献已提出了两个主要框架，即使用潜变量来捕捉两个结局之间的关联的随机效应联合模型 (Tsiatis Davidian, 2004)，以及基于 G 估计的边际结构联合模型 (Robins et al., 1999, 2000). 本书则专注于前者。联合建模的两个子领域，即处理内生性时变协变量和非随机脱落，都同样涵盖并呈现了真实的数据集。由于作者的背景和合作经历，这些例子来自医学领域，特别是生物标志物研究。然而，只要对纵向结果和事件时间结局之间的关联感兴趣，就可以使用这种类型的联合模型，因此在其他领域也有许多应用。此外还介绍了多种扩展，包括纵向与生存结局之间的不同关联结构、分层因素的纳入、滞后效应的结合、外源时变协变量的处理以及竞争风险设置等。对于纵向部分，主要关注连续纵向结果和线性混合效应模型的使用。书中包含的所有分析都是在用于统计计算和图形的 R 软件环境中实现的，涉及到作者编写的免费软件包 JM。该包可拟合多种联合模型，包括上述扩展。然而，它并没有涵盖文献中提出的所有类型的联合模型，因此，文中介绍的一些扩展，如分类纵向标志物和多个纵向标志物的联合模型在文本中被，未给出软件说明。文中给出的结果是使用包 JM 的 1.0-0 版本以及 R 2.15.0 生成的。该软件包的当前版本可以从 Comprehensive R Archive\nNetwork (http://cran.r-project.org) 获得。由于平台依赖性，分析结果可能会因不同的计算机或操作系统以及 R 和该包的未来版本而略有不同。文本中使用的所有代码都可从如下网站获得：http://jmr.r-forge.r-project.org如有错别字、错误和对本书内容的改进，作者将不胜感激，并可通过电子邮件联系：d.rizopoulos@erasmusmc.nl","code":""},{"path":"index.html","id":"预备知识","chapter":"前言","heading":"预备知识","text":"本书的内容假定读者熟悉统计入门课程水平的统计数据分析的基本概念，包括标准最大似然理论，以及回归分析方面的深厚背景。对混合效应模型和生存分析的一些背景知识也会有所帮助，但并非必须。同样，关于 R 语言，本书不假定读者有任何先验知识，但对该语言的基本熟悉会有所帮助。","code":""},{"path":"index.html","id":"印刷惯例","chapter":"前言","heading":"印刷惯例","text":"本书中引用的 R 语言对象、命令和输出均以等宽 typewriter 字体呈现。可在 R 命令行交互式输入的代码格式为：其中 > 表示 R 命令行提示符，其他所有内容都是用户应该输入的内容。此外，单行无法呈现的 R 表达式将适当缩进，如下所示：当在正文中引用函数时，它将采用 typewriter 字体进行格式化，并且在函数名称后带有括号，例如，jointModel()。同样，函数参数和为这些参数指定的值也将以 typewriter 字体格式化，但末尾没有括号，例如 method = \"weibull-PH-aGH\"。为节省空间，对一些 R 输出进行了编辑。如下表示完整行的省略：但一些空行已直接删除且没有提示。本专著中的许多工作都是基于与 Geert Verbeke 和 Geert Molenberghs 的合作研究，我很高兴与他们合作。我还要感谢 Emmanuel Lesaffre 就联合建模主题进行了有益的讨论，并创造了一个令人兴奋的工作环境。特别感谢 JM 的所有用户，他们的反馈极大地促进了该软件包的开发。对于本书，我要特别感谢匿名审稿人对早期版本手稿的宝贵反馈，感谢 Chapman Hall/CRC 的 John Kimmel 在整个制作过程中提供的帮助和支持。本专著是使用 Friedrich Leisch’s Sweave 包、\\(\\LaTeX\\) 文档准备系统写作的，当然还有 R。Dimitris RizopoulosRotterdam, April 2012","code":"> x <- 5> jointModel(lmeFit, coxFit, timeVar = \"time\",\n             method = \"weibull-PH-aGH\", parameterization = \"both\")\n..."},{"path":"目录.html","id":"目录","chapter":"目录","heading":"目录","text":"介绍\n1.1 目标\n1.2 激励性研究\n1.2.1 原发性胆汁性肝硬化 (PBC) 数据\n1.2.2 艾滋病数据\n1.2.3 肝硬化数据\n1.2.4 主动脉瓣数据\n1.2.5 其他应用\n\n1.3 纵向研究中的推断目标\n1.3.1 协变量对单一结果的效应\n1.3.2 结果之间的关联\n1.3.3 复杂的假设检验\n1.3.4 预测\n1.3.5 隐式结果的统计分析\n\n1.4 概述\n1.1 目标1.2 激励性研究\n1.2.1 原发性胆汁性肝硬化 (PBC) 数据\n1.2.2 艾滋病数据\n1.2.3 肝硬化数据\n1.2.4 主动脉瓣数据\n1.2.5 其他应用\n1.2.1 原发性胆汁性肝硬化 (PBC) 数据1.2.2 艾滋病数据1.2.3 肝硬化数据1.2.4 主动脉瓣数据1.2.5 其他应用1.3 纵向研究中的推断目标\n1.3.1 协变量对单一结果的效应\n1.3.2 结果之间的关联\n1.3.3 复杂的假设检验\n1.3.4 预测\n1.3.5 隐式结果的统计分析\n1.3.1 协变量对单一结果的效应1.3.2 结果之间的关联1.3.3 复杂的假设检验1.3.4 预测1.3.5 隐式结果的统计分析1.4 概述纵向数据分析\n2.1 纵向数据的特征\n2.2 线性混合效应模型\n2.2.1 估计\n2.2.2 在 R 中的实现\n\n2.3 纵向研究中的缺失数据\n2.3.1 缺失数据机制\n2.3.2 非随机缺失模型族\n\n2.4 延伸阅读\n2.1 纵向数据的特征2.2 线性混合效应模型\n2.2.1 估计\n2.2.2 在 R 中的实现\n2.2.1 估计2.2.2 在 R 中的实现2.3 纵向研究中的缺失数据\n2.3.1 缺失数据机制\n2.3.2 非随机缺失模型族\n2.3.1 缺失数据机制2.3.2 非随机缺失模型族2.4 延伸阅读事件时间数据分析\n3.1 事件时间数据的特征\n3.2 生存分析的基本函数\n3.2.1 删失数据的似然构造\n\n3.3 相对风险回归模型\n3.3.1 在 R 中的实现\n\n3.4 时依协变量\n3.5 扩展的 Cox 模型\n3.6 延伸阅读\n3.1 事件时间数据的特征3.2 生存分析的基本函数\n3.2.1 删失数据的似然构造\n3.2.1 删失数据的似然构造3.3 相对风险回归模型\n3.3.1 在 R 中的实现\n3.3.1 在 R 中的实现3.4 时依协变量3.5 扩展的 Cox 模型3.6 延伸阅读纵向与事件时间数据的联合模型\n4.1 基本联合模型\n4.1.1 生存子模型\n4.1.2 纵向子模型\n\n4.2 R 中的联合建模：与扩展的 Cox 模型比较\n4.3 联合模型的估计\n4.3.1 两阶段法\n4.3.2 联合似然公式\n4.3.3 具有未指定基线风险函数的标准误\n4.3.4 JM 中的优化控制\n4.3.5 数值积分\n4.3.6 JM 中的数值积分控制\n4.3.7 收敛问题\n\n4.4 联合模型的渐近推断\n4.4.1 假设检验\n4.4.2 置信区间\n4.4.3 设计考虑\n\n4.5 随机效应的估计\n4.6 与缺失数据框架的连接\n4.7 联合模型的敏感性分析\n4.1 基本联合模型\n4.1.1 生存子模型\n4.1.2 纵向子模型\n4.1.1 生存子模型4.1.2 纵向子模型4.2 R 中的联合建模：与扩展的 Cox 模型比较4.3 联合模型的估计\n4.3.1 两阶段法\n4.3.2 联合似然公式\n4.3.3 具有未指定基线风险函数的标准误\n4.3.4 JM 中的优化控制\n4.3.5 数值积分\n4.3.6 JM 中的数值积分控制\n4.3.7 收敛问题\n4.3.1 两阶段法4.3.2 联合似然公式4.3.3 具有未指定基线风险函数的标准误4.3.4 JM 中的优化控制4.3.5 数值积分4.3.6 JM 中的数值积分控制4.3.7 收敛问题4.4 联合模型的渐近推断\n4.4.1 假设检验\n4.4.2 置信区间\n4.4.3 设计考虑\n4.4.1 假设检验4.4.2 置信区间4.4.3 设计考虑4.5 随机效应的估计4.6 与缺失数据框架的连接4.7 联合模型的敏感性分析标准联合模型的扩展\n5.1 参数化\n5.1.1 交互效应\n5.1.2 滞后效应\n5.1.3 滞后效应\n5.1.4 时依斜率参数化\n5.1.5 累积效应参数化\n5.1.6 随机效应参数化\n\n5.2 处理外源时依协变量\n5.3 分层相对风险模型\n5.4 潜类别联合模型\n5.5 多个事件\n5.5.1 竞争风险\n5.5.2 复发事件\n\n5.6 加速失效时间模型\n5.7 分类纵向结果的联合模型\n5.7.1 广义线性混合模型 (GLMM)\n5.7.2 将离散重复测量与生存结合\n\n5.8 多个纵向结果的联合模型\n5.1 参数化\n5.1.1 交互效应\n5.1.2 滞后效应\n5.1.3 滞后效应\n5.1.4 时依斜率参数化\n5.1.5 累积效应参数化\n5.1.6 随机效应参数化\n5.1.1 交互效应5.1.2 滞后效应5.1.3 滞后效应5.1.4 时依斜率参数化5.1.5 累积效应参数化5.1.6 随机效应参数化5.2 处理外源时依协变量5.3 分层相对风险模型5.4 潜类别联合模型5.5 多个事件\n5.5.1 竞争风险\n5.5.2 复发事件\n5.5.1 竞争风险5.5.2 复发事件5.6 加速失效时间模型5.7 分类纵向结果的联合模型\n5.7.1 广义线性混合模型 (GLMM)\n5.7.2 将离散重复测量与生存结合\n5.7.1 广义线性混合模型 (GLMM)5.7.2 将离散重复测量与生存结合5.8 多个纵向结果的联合模型标准联合模型的扩展\n6.1 联合模型的残差\n6.1.1 纵向部分的残差\n6.1.2 生存部分的残差\n\n6.2 脱落和残差\n6.3 多重插补残差\n6.3.1 固定就诊时间\n6.3.2 随机就诊时间\n\n6.4 随机效应分布\n6.1 联合模型的残差\n6.1.1 纵向部分的残差\n6.1.2 生存部分的残差\n6.1.1 纵向部分的残差6.1.2 生存部分的残差6.2 脱落和残差6.3 多重插补残差\n6.3.1 固定就诊时间\n6.3.2 随机就诊时间\n6.3.1 固定就诊时间6.3.2 随机就诊时间6.4 随机效应分布联合模型的预测和准确性\n7.1 生存概率的动态预测\n7.1.1 定义\n7.1.2 估计\n7.1.3 在 R 中的实现\n\n7.2 纵向结果的动态预测\n7.3 参数化对预测的影响\n7.4 联合模型的前瞻准确性\n7.4.1 二项结果的判别度量\n7.4.2 生存结果的判别度量\n7.4.3 纵向标志物的预测规则\n7.4.4 判别指数\n7.4.5 联合建模框架下的估计\n7.4.6 在 R 中的实现\n\n7.1 生存概率的动态预测\n7.1.1 定义\n7.1.2 估计\n7.1.3 在 R 中的实现\n7.1.1 定义7.1.2 估计7.1.3 在 R 中的实现7.2 纵向结果的动态预测7.3 参数化对预测的影响7.4 联合模型的前瞻准确性\n7.4.1 二项结果的判别度量\n7.4.2 生存结果的判别度量\n7.4.3 纵向标志物的预测规则\n7.4.4 判别指数\n7.4.5 联合建模框架下的估计\n7.4.6 在 R 中的实现\n7.4.1 二项结果的判别度量7.4.2 生存结果的判别度量7.4.3 纵向标志物的预测规则7.4.4 判别指数7.4.5 联合建模框架下的估计7.4.6 在 R 中的实现附录 R 的简要介绍\n.1 获取并安装 R 和 R 包\n.1 获取并安装 R 和 R 包附录 B 联合模型的 EM 算法附录 C JM 包的结构参考书目","code":""},{"path":"chap1.html","id":"chap1","chapter":"第 1 章 介绍","heading":"第 1 章 介绍","text":"","code":""},{"path":"chap1.html","id":"sec1-1","chapter":"第 1 章 介绍","heading":"1.1 目标","text":"在随访研究中，通常会为每个样本单元收集不同类型的结果，其中可能包括几个纵向测量的响应，以及发生特定关注事件之前的时间。这类研究中感兴趣的研究问题通常需要对记录的结果进行单独分析，但在许多情况下，兴趣也可能在于研究它们的关联结构。后一种情况的一个常见例子可以在有关生物标志物研究中找到，许多临床研究旨在确定对事件时间结果具有强大预后能力的生物标志物。标准例子包括人类免疫缺陷病毒 (HIV) 的研究，其中感兴趣的是 CD4 细胞计数或病毒载量与获得性免疫缺陷综合征 (AIDS) 患病时间之间的关联；肝硬化研究，其调查血清胆红素与死亡时间之间的关联；以及前列腺癌症研究，关注点在于前列腺特异性抗原 (PSA) 水平与前列腺癌症发展时间之间的关联。这些医学状况的一个重要固有特征是其动态性。也就是说，进展速度不仅因患者而异，而且同一患者的疾病进展速度也会随时间动态变化。因此，只有在分析中考虑对生物标志物的重复评估时，才能揭示生物标志物在描述疾病进展及其与生存关联方面的真正潜力。为了解决涉及重复测量与事件时间之间的关联结构的研究问题，已经开发了一类统计模型，称为纵向数据与事件时间数据的联合模型 (joint models longitudinal time--event data)。目前，这些模型的研究构成了统计研究的一个活跃领域，近年来受到了广泛的关注。特别是，在 Self Pawitan (1992) 以及 DeGruttola Tu (1994) 将联合建模方法应用于艾滋病研究的早期工作，以及 Faucett Thomas (1996) 以及 Wulfsohn Tsiatis (1997) 提出了开创性论文之后，这一领域的发展呈爆炸式增长。许多论文提出了标准联合模型的几种扩展，其中包括纵向轨迹的灵活建模、纳入潜类别以考虑总体异质性、考虑多个纵向标志物、对多个失效时间进行建模以及动态预测和准确性度量的计算。本书的主要目标是全面介绍这种联合建模框架。具体来说，我们将重点关注联合模型试图回答的研究问题类型，以及这些模型适合回答这些问题的情况。我们将解释它们背后的关键假设，以及如何最佳利用这些假设从数据中提取相关信息。本书的另一个目的是促进这些模型在日常统计实践中的使用。为此，文本中涵盖几乎的所有理论材料都使用 JM 包 (Rizopoulos, 2012b, 2010) 在实际数据示例中进行了说明，JM 包是为统计计算和图形的 R 软件环境开发的 (R Development Core Team, 2012).","code":""},{"path":"chap1.html","id":"sec1-2","chapter":"第 1 章 介绍","heading":"1.2 激励性研究","text":"","code":""},{"path":"chap1.html","id":"sec1-2-1","chapter":"第 1 章 介绍","heading":"1.2.1 原发性胆汁性肝硬化 (PBC) 数据","text":"原发性胆汁性肝硬化 (PBC) 是一种慢性、致命但罕见的肝病，其特征是肝脏内小胆管的炎症性破坏，最终导致肝硬化。我们在这里考虑的数据集来自 Mayo Clinic 1974 年至 1984 年进行的一项研究 (Murtaugh et al., 1994) ，该研究包括 312 名患者，其中 158 名患者随机分配至 D-青霉胺组，154 名患者分配至安慰剂组。主要关注的是患者的生存情况以及 D-青霉胺是否能延长生存期。此外，我们还获得了基线协变量（例如基线年龄、性别等）的信息，以及几种生物标志物的随访测量数据。这些生物标志物包括血清胆红素、蜘蛛痣（皮肤上的血管畸形）和肝肿大（肝脏肿大）等。在这里，我们将重点关注血清胆红素水平，它被认为是疾病进展的有力指标，我们尤其对该标志物与生存的关联感兴趣。这些患者最初的临床方案规定每六个月、一年以及此后每年进行一次随访。然而，由于死亡和删失，患者平均就诊 6.2 次（标准差 3.8），总共进行了 1945 次血清胆红素观测。到研究结束时，140 名患者死亡，29 名患者接受了移植，143 名患者仍然存活。图 1.1 显示了患者样本的血清胆红素对数的平滑纵向曲线，从中可以看出，许多曲线在时间上是非线性的。","code":""},{"path":"chap1.html","id":"sec1-2-2","chapter":"第 1 章 介绍","heading":"1.2.2 艾滋病数据","text":"在我们考虑的艾滋病数据集中，有467名患者在接受抗逆转录病毒治疗期间感染了晚期人类免疫缺陷病毒，且齐多夫定治疗失败或不耐受。这项研究的主要目的是比较两种替代抗逆转录病毒药物——去羟肌苷 (ddI) 和扎西他滨 (ddC)——在死亡时间方面的疗效和安全性。患者被随机分配接受 ddI 或 ddC 治疗，并在研究开始时（即随机化发生时）以及随后的 2 个月、6 个月、12 个月和 18 个月记录 CD4 细胞计数。关于这项研究的更多设计细节，请参见 Abrams et al.(1994) 的研究。研究结束时，有 188 名患者死亡，导致约 59.7% 的数据删失。在计划的 2335 次测量中，实际记录了 1405 次，导致 39.8% 的响应缺失。图 1.2 展示了死亡时间的生存函数的 Kaplan-Meier 估计（关于 Kaplan-Meier 估计的更多细节，请参阅 3.2 节），以及随机抽取的十名患者 CD4 细胞计数平方根的纵向轨迹。在我们的示例中，我们重点关注这项研究的次要目标之一，即研究这些晚期 HIV 感染患者的 CD4 计数与死亡风险之间的关联结构。其中，CD4 细胞是在脾脏、淋巴结和胸腺中产生的一种白细胞，是抗感染系统的一部分。CD4 计数测量的是血液中 CD4 细胞的数量，是免疫系统强度的重要标志物。因此，随着时间的推移，CD4 细胞计数的减少表明患者免疫系统的状况恶化，从而增加了感染的风险。","code":""},{"path":"chap1.html","id":"sec1-2-3","chapter":"第 1 章 介绍","heading":"1.2.3 肝硬化数据","text":"肝硬化数据集包括 488 名经组织学证实的肝硬化患者，其中 237 名患者被随机分配到泼尼松治疗组，其余患者接受安慰剂治疗。肝硬化是一个一般术语，包括所有形式的慢性弥漫性肝病，其特征是肝细胞广泛损失以及肝小叶结构广泛破坏。这项研究于 1962 年至 1974 年在哥本哈根进行，其主要目的是评估泼尼松是否能延长肝硬化患者的生存期 (Andersen et al., 1993). 在随访结束时，泼尼松治疗组有 150 名 (63.3%) 患者死亡，安慰剂组有 142 名 (56.6%) 患者死亡。患者计划于 3 个月、6 个月和 12 个月后复诊，此后每年复诊，并记录几种临床和生化变量值。临床变量包括酒精摄入、营养状况、出血和腹水程度的信息，而最重要的生化变量包括白蛋白、胆红素、碱性磷酸酶和凝血酶原。尽管患者应在上述预定的就诊时间进行测量，但实际随访时间却与预定的就诊时间有很大差异。此外，如图 1.3 所示，死亡患者在死亡前不久接受了更多的就诊。\n在我们的说明中，我们将集中讨论凝血酶原指数与死亡风险之间的关系。该指数基于血液测试中肝脏产生的凝血因子 II, VII 和 X 的测量值。图 1.4 展示了每个治疗组特定于受试者的纵向轨迹。此外，我们还关注凝血酶原指数能否有效地区分两类人群：一类是在经过最近一次评估后，在一个与医学相关的特定时间段内去世的个体；另一类是生存时间超过这个特定时段的个体。举例来说，对于来自同一人群的未来患者，我们希望基于其基线协变量数据及现有的凝血酶原检测结果来计算其生存概率，并将此信息告知主治医师，以便为他们的后续诊疗决策提供支持。","code":""},{"path":"chap1.html","id":"sec1-2-4","chapter":"第 1 章 介绍","heading":"1.2.4 主动脉瓣数据","text":"主动脉瓣数据集包括 289 名主动脉瓣狭窄 () 患者，他们于 1992 年至 2005 年间在 Erasmus University Medical Center 接受了同种异体主动脉根部置换术 (RR) 或冠状动脉下植入术 (SI) (Takkenberg et al., 2002, 2006). 主动脉瓣狭窄是指位于心脏左心室和主动脉之间的主动脉瓣开口变窄，是最常见的瓣膜性心脏病之一。该数据集中的所有患者都通过年度电话访谈、访问他们的心脏病专家进行了前瞻性随访。Erasmus University Medical Center 在术后六个月、术后一年及之后每两年通过一系列标准化超声心动图进行超声心动图随访。研究结束时，有 61 名 (21.1%) 患者死亡，78 名 (27%) 患者接受了再次手术。我们关注主动脉射血速度（主动脉梯度）与死亡或再次手术风险之间的关联。由于主动脉梯度水平呈右偏分布，我们通常使用它们的平方根转换。图 1.5 显示了主动脉梯度平方根的简单线性回归中特异于受试者的截距和斜率的散点图，根据事件时间排序。","code":""},{"path":"chap1.html","id":"sec1-2-5","chapter":"第 1 章 介绍","heading":"1.2.5 其他应用","text":"前几节主要关注人体研究的数据集，重点关注纵向生物标志物测量值与患者生存之间的关联。然而，纵向响应和事件时间之间的相互关系在许多其他学科中也很有趣。下面我们给出三个来自生物标志物研究以外领域的例子。例 1：在群居动物研究中，对畜群社会动态的纵向测量可能与其迁移到其他区域所需的时间有关联。例 2：在社会学和教育测试中，以及在一些流行病学研究中，将问卷调查受访者的表现与事件时间结果的联系通常是研究者关注的。例如，在痴呆症研究中，会使用问卷来衡量患者的认知情绪状态，以及记忆和沟通能力。由于痴呆症是一种渐进性疾病，患者会频繁接受此类问卷调查，而研究的重点在于患者在心理测试中的表现变化与临床病症发作之间的关系。例 3：在土木工程领域，常常关注研究建筑物无法继续使用的时间点。为此，会定期记录有关结构完整性的多个指标，旨在评估这些指标是否能有效预测相关结构失效的风险。","code":""},{"path":"chap1.html","id":"sec1-3","chapter":"第 1 章 介绍","heading":"1.3 纵向研究中的推断目标","text":"从上一节可以明显看出，在纵向研究中，通常会为每个患者记录大量信息，而人们的兴趣往往在于这些不同信息之间的复杂关联。在更详细地讨论纵向研究中可能感兴趣的可能相互关系之前，我们将首先区分这些研究中记录的两种类型的结果。首先，我们将显式结果 (explicit outcomes) 称为研究方案中明确规定的在随访期间记录的结果。例如，在 PBC 研究中，显式结果包括患者的生存信息和生物标志物的纵向测量。第二种类型的结果，我们称之为隐式结果 (implicit outcomes)，是指那些虽然不是直接关注的重点，但可能会使显式结果的分析变得复杂的结果。一个典型的例子就是缺失数据。尤其是，根据方案，患者通常需要按照预定的时间前往研究中心提供信息，但在实践中很难实现。患者经常错过一些就诊，或者由于各种原因完全退出研究。例如，正如我们在艾滋病数据集中看到的那样，在 2335 次计划测量中，实际只记录了 1405 次，导致 39.8% 的响应缺失。与缺失数据密切相关的隐式结果的另一个例子是就诊过程，它是指生成纵向测量收集时间点的机制（随机的或确定的）(Lipsitz et al., 2002). 随机就诊时间 (random visit times) 常见于观察性研究中，在类研究中，纵向测量的时间点不是由设计确定的，而是由医生甚至患者自己确定的。然而，即使是预先由研究方案规定了就诊时间的随机化研究，也可能出现随机就诊时间。例如，在 PBC 数据集中，在随访的前两年里，血清胆红素的测量在基线、半年、一年和两年时进行，就诊时间差异较小，而在随后几年中，就诊时间的变异性显著增加。下面我们对纵向研究中可能提出的研究问题进行了分类 (Rizopoulos Lesaffre, 2012).","code":""},{"path":"chap1.html","id":"sec1-3-1","chapter":"第 1 章 介绍","heading":"1.3.1 协变量对单一结果的效应","text":"一般来说，医学研究中最常见的研究问题类型是估计或检验一组协变量对某些感兴趣结果的效应。例如，对于艾滋病患者，我们想知道 ddI 是否可以提高生存率，或者男性和女性之间 CD4 细胞计数的平均纵向分布是否存在差异。回答这些问题需要假设一种合适的统计模型，将协变量与感兴趣的结果联系起来。根据结果的性质，可以使用几种类型的统计模型。第 2 章和第 3 章分别回顾了纵向数据和事件时间数据的基本建模框架。","code":""},{"path":"chap1.html","id":"sec1-3-2","chapter":"第 1 章 介绍","heading":"1.3.2 结果之间的关联","text":"通常，探究结果之间的关联结构也具有重要意义。比如，在 PBC 数据集中，医生们关注的是当前血清胆红素水平与死亡风险之间关联的强度。一个类似的例子出现在哮喘研究中，其中哮喘发作的风险可能与空气污染程度相关。乍一看，这些研究问题在精神上与第 1.3.1 节提出的问题相似，唯一的区别在于协变量过程现在是时依的 (time-dependent). 因此，人们可以简单地通过假设合适的模型将这两个关注的结果变量关联起来。这意味着可以通过构建模型来探索两个结果之间的动态关系。例如，我们可以简单地为死亡风险制定一个时依 Cox 模型，并将纵向 CD4 细胞计数测量作为时依协变量 (Andersen Gill, 1982). 然而，我们需要仔细考虑的一个重要特征是，在这种模型中，结果变量同时扮演着响应和协变量的角色。为此，我们首先需要辨别协变量结果过程的类型，特别是协变量结果对于响应结果来说是内部的（或内生性的） (internal, endogenous) 还是外部的（或外源性的） (external, exogenous). 内生性的正式定义将在第 3 章给出。然而，区分内部和外部协变量的一种更直观的方式是通过理解时依协变量过程的本质。简单地说，内部协变量是由患者自己产生的，因此需要患者的存在。回顾前两个例子，我们注意到 CD4 细胞计数和死亡风险是患者自身产生的随机过程，因此 CD4 细胞数构成了一个内部协变量过程。另一方面，空气污染是哮喘发作的外部协变量，因为患者对空气污染没有影响。当协变量结果对于响应结果是外部的，我们可以使用 1.3.1 节提到的大多数标准模型，可能只需相对较小的修改。然而，正如我们将在后面看到的，带内部协变量的统计分析带来了几个额外的困难。","code":""},{"path":"chap1.html","id":"sec1-3-3","chapter":"第 1 章 介绍","heading":"1.3.3 复杂的假设检验","text":"前两节研究问题的组合也常常是研究者所关注的。一个典型的例子就是替代标志物的评估。特别是对于慢性疾病，如原发性胆汁性肝硬化 (PBC)，我们可能会想使用短期的纵向血清胆红素测量来评估治疗效应，而不是花费很长时间来确定的生存终点。Prentice 于 1989 年提出了替代性的三个条件：() 治疗必须对患者生存有影响；(II) 治疗必须对标志物（即血清胆红素）有影响；以及 (III) 治疗效应应通过标志物表现出来，即给定特定的标志 物轨迹，死亡风险应独立于治疗。显然，为了评估条件 () 和 (II)，我们需要分别为生存和纵向结果设定单独的模型，每个模型都包含治疗作为预测因子。然而，为了检验条件 (III)，则需要一个以治疗和血清胆红素为条件的生存结果模型。鉴于血清胆红素作为内生时依协变量的特性，如上所述，联合模型提供了一个灵活的建模框架，用于确定在考虑到血清胆红素后，治疗是否对生存有影响。当我们有兴趣同时检验基线协变量对几种结果的影响时，需要进行类似类型的分析。例如，继续考虑上面提到的例子，血清胆红素可能不是描述疾病进展的良好生物标志物，因此即使考虑了血清胆红素，治疗仍可能对患者的生存产生影响。在这种情况下，我们可以扩展我们的分析，纳入更多疾病进展的生物标志物，如蜘蛛痣和肝肿大等。研究兴趣可能在于同时检验治疗对所有标志物的影响，或者是校正其他标志物后，检验某一特定标志物与死亡风险之间的关联性。显然，为了进行此类检验，我们需要一种灵活的建模方法，能够捕捉这些结果之间的相互关系。","code":""},{"path":"chap1.html","id":"sec1-3-4","chapter":"第 1 章 介绍","heading":"1.3.4 预测","text":"统计模型也常用于提供与患者相关的预测结果。特别是在当前医学实践中趋向个性化医疗的趋势下，能够提供高质量个体化预测的模型显得尤为宝贵。实际上，在随访期间针对特定患者的具体时间点，医生希望能利用手头上所有的可用信息（包括基线信息和积累的生物标志物水平），以预测具有医学意义的结果，从而更好地理解疾病的动态发展，并最终作出当时最优的决策。当有新的信息记录时，医生会关注于对这些预测进行更新，因此采取一种随时间动态调整的方式进行处理。当对高质量预测感兴趣时，将患者所有可用信息结合起来考虑各个结果之间的生物学相互关系是很有用的。以 PBC 数据集为例，从生物标志物的定义可以看出，它们度量了肝功能的不同方面。因此，如果我们仅基于其中一个标志物进行预测并忽略其它标志物，将会丢弃有价值的信息。这不可避免地意味着，我们无法达到可能通过同时结合所有生物标志物所能达到的最大预测能力。因此，显然，将所有标志物结合到一个模型中的建模方法是有利的，因为它利用了所有可用的信息。Fieuws et al. (2008) 通过实证研究说明了结合标志物进行预测的额外价值，他们指出，在肾脏移植研究中，基于使用所有记录的肾功能生物标志物的联合模型对移植物衰竭进行的预测，其表现大大优于单独对每个标志物进行的分析。","code":""},{"path":"chap1.html","id":"sec1-3-5","chapter":"第 1 章 介绍","heading":"1.3.5 隐式结果的统计分析","text":"在上述所有类型的研究问题中，我们关注的都是显式结果。然而，如前所述，在纵向研究中，往往也会产生隐式结果，即使这些结果不是主要关注的结果，也需要对其进行适当的处理。特别是在存在隐式结果的情况下，在进行感兴趣的分析之前，必须仔细考虑描述生成隐式结果（缺失数据和/或就诊时间）的过程的概率机制的本质，因为它极大地决定了如何调整分析以获得有效的推断结论。","code":""},{"path":"chap1.html","id":"sec1-4","chapter":"第 1 章 介绍","heading":"1.4 概述","text":"第 2 章和第 3 章旨在介绍联合模型的组成部分，即纵向数据的线性混合效应模型和生存数据的相对风险模型。具体来说，在第 2 章中，我们讨论了纵向响应分析中出现的复杂性，并引入了线性混合效应模型作为处理相关数据的灵活建模框架。我们首先讨论估计与推断问题，然后重点关注纵向研究中经常遇到的缺失数据问题。我们定义了不同的缺失数据机制，并解释了在何种情况下线性混合模型能够提供有效的推断结论。第 3 章首先解释了事件时间数据的特殊特征，如删失 (censoring) 和截尾 (truncation)，以及它们如何将对这些数据的分析变得复杂。接下来，我们介绍相对风险模型，特别是 Cox 模型。在第 2 章中，我们简要地提到了偏似然和全似然下的估计和推断。在最后一节中，我们将重点讨论时依协变量。更具体地说，我们提供了内生性和外源性时依协变量的定义，并讨论了扩展（时依）Cox 模型在哪些情况下提供了有效的推断。第 4 章介绍联合建模框架的基础知识。特别是，从第 3 章末尾开始，我们首先从生存的角度出发，将联合模型作为处理内生时依协变量的建模框架。我们介绍标准联合模型，讨论其背后的假设，并给出了最大似然估计。接下来，我们与第 2 章中提出的缺失数据框架建立联系，并进一步推动联合模型成为可处理非随机脱落 (nonrandom dropout) 的模型。在第 5 章中，我们探讨了标准联合模型的几种扩展。生存部分的扩展包括纵向和生存结果之间的不同类型的参数化、分层相对风险模型、多个失效时间的处理以及加速失败时间模型的考虑。关于纵向部分，我们首先提出了具有分类纵向标志物的联合模型，然后我们扩展到具有多个纵向结果的多变量联合模型。最后，作为标准联合模型的替代模型，我们提出了潜类别联合模型 (latent class joint model)，该模型假设纵向和事件时间过程之间的关联是由于总体中存在潜在的异质性。在第 6 章中，我们介绍了几种基于残差的诊断工具来评估联合模型背后的假设。我们分别关注生存部分和纵向部分的不同类型的残差，并特别关注这些残差如何受到事件发生引起的非随机脱落的影响。此外，我们还提及随机效应分布的错误指定并讨论其如何影响推断。第 7 章重点介绍了预测和判别。更具体地说，我们说明了联合模型如何用于估计事件时间结果的生存概率以及纵向结果的预测，并说明如何随着为每个受试者收集更多信息而动态更新这些预测。接下来，我们将注意力转向纵向标志物的前瞻性准确性度量，并评估其在区分即将经历事件的受试者与风险低得多的受试者的能力。特别地，在预测规则的一般定义下，我们给出了灵敏度和特异度度量的适当定义，并使用受试者工作特征方法确定了纵向标志物的准确性。最后，附录 简要介绍了 R 语言，以便对该软件包没有或几乎没有经验的读者能够获得所需的最少背景知识，使他们能够在自己的数据集中应用本书介绍的联合建模技术。","code":""},{"path":"chap2.html","id":"chap2","chapter":"第 2 章 纵向数据分析","heading":"第 2 章 纵向数据分析","text":"本章介绍了用于分析连续纵向响应的线性混合效应模型，该模型构成了纵向和事件时间数据联合模型的第一个组成部分。特别关注经常遇到的数据缺失问题。特别是，我们提出了描述纵向响应和缺失过程之间关联结构的不同类型的机制，并解释了在什么情况下需要对两个结果进行联合建模分析。","code":""},{"path":"chap2.html","id":"sec2-1","chapter":"第 2 章 纵向数据分析","heading":"2.1 纵向数据的特征","text":"相关数据 (correlated data) 在定量研究的许多领域都很常见。按照 Verbeke Molenberghs (2000) 和 Molenbberghs Verbeke (2005) 的观点，相关数据这一一般术语涵盖了多种多元数据结构，例如聚类数据 (clustered data)、重复测量 (repeated measures)、纵向数据 (longitudinal data) 和空间相关数据 (spatial correlated data). 本章的重点是纵向数据，纵向数据可以广义地定义为通过对受试者（例如人类、动物或实验室样本）随时间进行重复测量而得到的数据。此类数据在健康科学中经常出现，其中纵向研究在增进我们对疾病发展和持续性的理解方面发挥着重要作用。纵向研究的显著特点是，它们允许通过在整个研究期间对受试者进行重复测量，直接评估响应变量随时间的变化。例如，在一项纵向研究中，患者被（随机）分配在研究开始时接受不同的治疗，并随时间进行随访，我们可以同时研究评估不同治疗方案在特定时间点（例如研究结束时）的效应差异（即横断面效应）治疗方案或治疗方案之间的差异如何随时间变化（纵向效应）从以上描述中可以明显看出，在纵向研究中，我们期望对同一受试者进行的重复测量显示出正相关。这一特征意味着，假定独立观测的标准统计工具，如 \\(t\\) 检验和简单线性回归，不适用于纵向数据分析。","code":""},{"path":"chap2.html","id":"sec2-2","chapter":"第 2 章 纵向数据分析","heading":"2.2 线性混合效应模型","text":"纵向数据分析的直观方法基于这样一种观点，总体中的每个个体都有自己的随时间变化的平均响应曲线 (mean response profile)，该曲线具有特定的函数形式。图 2.1 以图形的方式展示了这一理念，图中展示了两个假想受试者的纵向响应（点），以及它们对应的线性平均轨迹（虚线）。所有受试者的平均变化用实线表示。为了正式引入这种纵向数据的表示方法，我们令 \\(y_{ij}\\) 表示受试者 \\(\\) 在时间 \\(t_{ij}\\) 的响应，其中 \\(= 1, ..., n\\)，\\(j = 1, ..., n_i\\)。图 2.1 表明，一个简单的带有截距和线性时间效应的回归模型似乎足以分别刻画每个受试者的数据。然而，不同的受试者往往具有不同的截距和斜率。因此，对于观测响应 \\(y_{ij}\\)，一个合理的模型是\\[y_{ij}=\\tilde{\\beta}_{i0}+\\tilde{\\beta}_{i1}t_{ij}+\\varepsilon_{ij}\\]其中假定误差项 \\(\\epsilon_{ij}\\) 来自均值为零且方差为 \\(\\sigma^2\\) 的正态分布。由于受试者是从受试者总体中随机抽取的，因此可以合理地定价特定于受试者的回归系数 \\(\\tilde\\beta_{i0}\\) 和 \\(\\tilde\\beta_{i1}\\) 也是从相应的回归系数总体中随机抽取的。通常假定总体中回归系数的分布是二元正态分布，其中均值向量为1 \\(\\beta= (\\beta_0, \\beta_1)^\\top\\) 以及方差-协方差阵为 \\(D\\)。在此设定下，我们可以将模型重新表述为\\[\\begin{aligned}y_{ij}=(\\beta_0+b_{i0})+(\\beta_1+b_{i1})t_{ij}+\\varepsilon_{ij}\\end{aligned}\\]其中 \\(\\tilde{\\beta}_{i0}=\\beta_0+b_{i0},\\tilde{\\beta}_{i1}=\\beta_1+b_{i1}\\)，项 \\(b_i = (b_{i0}, b_{i1})^\\top\\) 称为随机效应 (random effect)，具有均值为零以及协方差阵为 \\(D\\) 的二元正态分布。参数 \\(\\beta_0\\) 和 \\(\\beta_1\\) 描述总体中的平均纵向变化（即，对受试者进行平均），称为固定效应 (fixed effects).上述模型的推广，即，允许额外的预测因子和额外的回归系数随机变化的模型，称为线性混合效应模型 (linear mixed-effects model) (Laird, Ware, 1982; Harville, 1977; Verbeke Molenberghs, 2000)，是分析纵向响应最常用的模型之一。一般线性混合模型具有以下形式\\[\\begin{align}\n\\left\\{\\begin{array}{rcl}y_i&=&X_i\\beta+Z_ib_i+\\varepsilon_i,\\\\ b_i&\\sim&\\mathcal{N}( 0, D),\\\\\\varepsilon_i&\\sim&\\mathcal{N}(0,\\sigma^2 \\text{}_{n_i}),\\end{array}\\right.\n\\tag{2.1}\n\\end{align}\\]其中 \\(X_i\\) 和 \\(Z_i\\) 分别是固定效应回归系数 \\(\\beta\\) 和随机效应回归系数 \\(b_i\\) 的已知设计矩阵，\\({{}}_{n_i}\\) 表示 \\(n_i\\) 维单位矩阵。假定随机效应呈正态分布，均值为零，方差-协方差阵为 \\(D\\)，并假定与误差项 \\(\\varepsilon_i\\) 无关，即 \\(\\text{cov}( b_i, \\varepsilon_i) = 0\\)。固定效应 \\(\\beta\\) 的解释与简单线性回归模型中的解释完全相同，即，假定设计矩阵 \\(X_i\\) 有 \\(p\\) 个协变量，则系数 \\(\\beta_j , j = 1, \\ldots, p\\) 表示当相应的协变量 \\(x_j\\) 增加一个单位时 \\(y_i\\) 平均的变化，其中所有其他预测变量保持不变。同样，随机效应 \\(b_i\\) 可以解释为第 \\(\\) 个受试者的回归参数集合相对于总体参数的偏离情况。混合模型的一个优点在于，它不仅可以估计那些可用于描述目标总体平均响应如何变化的参数，还可以预测个体响应轨迹随时间的变化。这是在第 4 章将要介绍的纵向数据与事件时间数据联合建模框架中使用这些模型的主要原因之一。此外，混合模型可以容纳数据中任何程度的不均衡，也就是说，我们不需要每个受试者都有相同数量的测量值，也不需要这些测量值在相同的时间点进行。而且，随机效应以相对简洁的方式解释了每个受试者重复测量之间的相关性。特别是，第 \\(\\) 个受试者的结果将是边际相关的 (marginally correlated)，因为它们共享相同的随机效应 \\(b_i\\)。换句话说，我们假定受试者的纵向响应条件独立于她的随机效应，即\\[\\begin{aligned}p(y_i\\mid  b_i;\\theta)=\\prod_{j=1}^{n_i}p(y_{ij}\\mid  b_i;\\theta)\\end{aligned}\\]当所选的随机效应结构不足以捕捉数据中的相关性时（尤其是对于只有较少随机效应的模型），我们可以扩展上面定义的线性混合模型，并为特定对象的误差分量，即 \\(\\varepsilon_i\\sim \\mathcal N( 0,\\Sigma_i)\\)，提供一个适当的、更通用的协方差阵，其中 \\(\\Sigma_i\\) 仅通过其维数 \\(n_i\\) 取决于 \\(\\)。在相关文献中，已经提出了多种不同的模型来表示 \\(\\Sigma_i\\)，这些模型对应着不同类型的序列相关函数。其中最常用的几种包括一阶自回归模型、指数以及高斯相关结构，但用于拟合线性混合模型的标准统计软件提供了更多的选择 (Verbeke Molenberghs, 2000; Pinheiro Bates, 2000).","code":""},{"path":"chap2.html","id":"sec2-2-1","chapter":"第 2 章 纵向数据分析","heading":"2.2.1 估计","text":"线性混合效应模型的参数估计通常基于最大似然 (maximum likelihood, ML) 原理。具体地，第 \\(\\) 个受试者的观测响应数据的边际密度由以下表达式给出\\[p(y_i)=\\int p(y_i\\mid b_i)p(b_i)db_i\\]利用以下事实：随机效应在条件均值 \\(E(yi | bi)\\) 的指定中线性进入，并且给定随机效应 \\(b_i\\) 时，纵向响应的条件分布 \\(\\{y_i|b_i\\}\\) 以及随机效应 \\(b_i\\) 的分布都是正态的，因此，上述积分具有封闭形式的解，它得到了一个 \\(n_i\\) 维正态分布，其均值为 \\(X_i\\beta\\)，方差-协方差阵为 \\(V_i = Z_iDZ^T_i + \\sigma^2I_{n_i}\\)。因此，假定受试者之间独立，线性混合模型的对数似然函数形式为\\[\\begin{align}\n\\begin{array}{rcl}\\ell(\\theta)&=&\\displaystyle\\sum_{=1}^n\\log p(y_i;\\theta)\\\\[1ex]&=&\\displaystyle\\sum_{=1}^n\\log\\int p(y_i\\mid b_i;\\beta,\\sigma^2)p(b_i;\\theta_b)db_i\\end{array}\n\\tag{2.2}\n\\end{align}\\]其中，\\(\\theta\\) 表示完整的参数向量，分解为子向量 \\(\\theta^T = (\\beta^T, \\sigma^2, \\theta^T_b)\\)，其中2 \\(\\theta_b = \\text{vech}(D)\\)，且\\[p(y_i;\\theta)=(2\\pi)^{-n_i/2}|V_i|^{-1/2}\\exp\\Bigl\\{-\\frac{1}{2}(y_i-X_i\\beta)^\\top V_i^{-1}(y_i-X_i\\beta)\\Bigr\\}\\]其中 \\(||\\) 表示方阵 \\(\\) 的行列式。如果我们假定 \\(V_i\\) 是已知的，那么通过以 \\(V_i\\) 中的参数为条件最大化式 (2.2) 而获得的固定效应向量 \\(\\beta\\) 的最大似然估计具有闭合形式，并且对应于广义最小二乘估计：\\[\\begin{align}\n\\hat{\\beta}=\\left(\\sum_{=1}^nX_i^\\top V_i^{-1}X_i\\right)^{-1}\\sum_{=1}^nX_i^\\top V_i^{-1}y_i\n\\tag{2.3}\n\\end{align}\\]当 \\(V_i\\) 未知，但可获得该矩阵的估计 \\(\\widehat{V}_i\\) 时，我们可以使用式 (2.3) 来估计 \\(\\beta\\)，其中 \\(V_i\\) 替换为 \\(\\widehat{V}_i\\)。为了获得 \\(\\widehat{V}_i\\)，我们可以再次使用最大似然法，对于给定的 \\(\\beta\\) 最大化对数似然 \\(\\ell(\\theta_b,\\sigma^2)\\)。根据标准渐近最大似然理论，在满足一定正则条件的情况下，\\(V_i\\) 的最大似然估计将是渐近无偏的。然而，在小样本情况下，\\(V_i\\) 的最大似然估计将是有偏的。实际上，这与简单线性回归的现象是一样的，其中误差项方差的最大似然估计定义为\\[\\hat{\\sigma}^2=\\frac{\\sum_i(y_i-x_i^\\top\\hat{\\beta})^2}n\\]是有偏的。产生这种偏差是因为 \\(\\sigma^2\\) 的 ML 估计没有考虑到 \\(\\beta\\) 也是根据数据来估计的这一事实。无偏估计则是通过将残差平方和除以 \\(n−p\\)（残差自由度）来获得的，即\\[\\hat{\\sigma}^2=\\frac{\\sum_i(y_i-x_i^\\top\\hat{\\beta})^2}{n-p}\\]其中 \\(p\\) 表示协变量向量 \\(x_i\\) 的维度。为了在更一般的多元回归情况下解决矩阵 \\(V_i\\) 的最大似然估计的相同问题，已经发展了限制性最大似然 (restricted\nmaximum likelihood, REML) 估计理论 (Harville, 1974). REML 估计背后的主要思想是将用于估计 \\(V_i\\) 的数据部分与用于估计 \\(\\beta\\) 的数据部分进行分离。换句话说，\\(V_i\\) 的 REML 估计的基本思想是从似然中消除 \\(\\beta\\)，使其仅根据 \\(V_i\\) 来定义。REML 估计通过最大化稍作修改的对数似然函数来进行\\[\\begin{aligned}\n\\ell(\\theta_b,\\sigma^2)=&-\\dfrac{n-p}{2}\\log(2\\pi)+\\dfrac{1}{2}\\log\\left|\\sum_{=1}^nX_i^\\top X_i\\right|-\\dfrac{1}{2}\\log\\left|\\sum_{=1}^nX_i^\\top V_i^{-1}X_i\\right|  \\\\\n&-\\frac12\\sum_{=1}^n\\Big\\{\\log|V_i|+(y_i-X_i\\hat{\\beta})^\\top V_i^{-1}(y_i-X_i\\hat{\\beta})\\Big\\} \\\\\n\\propto&-\\frac{1}{2}\\sum_{=1}^n\\log|V_i|-\\frac{1}{2}\\sum_{=1}^n(y_i-X_i\\hat{\\beta})^\\top V_i^{-1}(y_i-X_i\\hat{\\beta}) \\\\\n&-\\frac12\\log\\left|\\sum_{=1}^nX_i^\\top V_i^{-1}X_i\\right|,\n\\end{aligned}\\]其中 \\(\\hat\\beta\\) 由式 (2.3) 给出。通过最大化该修改的对数似然获得的估计 \\(\\widehat{V}_i\\) 校正了 \\(\\beta\\) 也已被估计的事实。与 \\(\\beta\\) 的估计相反，\\(V_i\\) 中唯一参数的最大似然估计和限制性最大似然估计一般都不能写出封闭形式。因此，为了获得 \\(\\widehat{V}_i\\)，需要数值优化程序。两种常用的算法是期望最大化 (Expectation-Maximization, EM) (Dempster et al., 1977) 和 Newton-Raphson 算法 (Lange, 2004)，其在线性混合效应模型中的实现可以在 Laird Ware (1982) 以及 Lindstrom Bates (1988) 中找到。固定效应回归系数的标准误可以通过计算广义最小二乘估计（式 (2.3)）的方差直接获得，即\\[\\begin{align}\n\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\beta})\n&=\\left(\\sum_{=1}^nX_i^\\top\\widehat{Q}_iX_i\\right)^{-1}\\left(\\sum_{=1}^nX_i^\\top\\widehat{Q}_i\\text{v}\\hat{\\mathrm{}}\\text{r}(y_i)Q_iX_i\\right)\\left(\\sum_{=1}^nX_i^\\top\\widehat{Q}_iX_i\\right)^{-1} \\tag{2.4}\\\\\n&=\\left(\\sum_{=1}^nX_i^\\top\\widehat{Q}_iX_i\\right)^{-1}\n\\tag{2.5}\n\\end{align}\\]其中 \\(\\widehat Q_i=\\widehat{V}_i^{-1}\\)，\\(\\widehat{V}_i^{-1}\\) 表示协方差阵 \\(V_i\\) 的 REML 或 ML 估计。从第一行简化为第二行要求模型是正确指定的，并且 \\(\\operatorname{var}(y_i)=\\widehat{V}_i\\)。如果我们想保护 \\(\\beta\\) 的推断免受模型协方差结构潜在错误指定的影响，我们可以使用 \\(\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\beta})\\) 的所谓三明治或稳健估计 (sandwich robust estimate) (White, 1982). 这可以通过在式 (2.4) 中代入 \\(y_i\\) 的方差的如下经验估计得到。\\[\\operatorname{var}(y_i)=\\begin{pmatrix}y_i-X_i\\hat{\\beta}\\end{pmatrix}\\begin{pmatrix}y_i-X_i\\hat{\\beta}\\end{pmatrix}^\\top \\]只要正确指定模型的平均结构 \\(X_i\\beta\\)，基于三明治估计的标准误将是一致的，但当正确指定 \\(V_i\\) 时，它们的效率将低于基于式 (2.5) 的标准误。\\(V_i\\) 中唯一参数估计的标准误是根据 Fisher 信息矩阵的相应块的逆获得的，即\\[\\operatorname{var}(\\hat{\\theta}_{b,\\sigma})=\\left\\{E\\bigg(-\\sum_{=1}^n\\frac{\\partial^2\\ell_i(\\theta)}{\\partial\\theta_{b,\\sigma}^\\top\\partial\\theta_{b,\\sigma}}\\bigg|_{\\theta_{b,\\sigma}=\\hat{\\theta}_{b,\\sigma}}\\bigg)\\right\\}^{-1}\\]","code":""},{"path":"chap2.html","id":"sec2-2-2","chapter":"第 2 章 纵向数据分析","heading":"2.2.2 在 R 中的实现","text":"R 语言在混合建模方面功能强大，有多个包可以拟合不同类型的混合效应模型。对于线性混合效应模型，两个主要的包是 nlme (Pinheiro et al., 2012; Pinheiro Bates, 2000) 和 lme4 (Bates et al., 2011). 前者仅适用于连续数据，但可以拟合具有更复杂误差结构（即相关和/或异方差误差项）的模型，而后者则可以拟合连续和分类响应的混合模型3，但仅通过随机效应来考虑受试者重复测量之间的相关性。在这本书中，我们将使用包 nlme 中的函数 lm() 拟合线性混合效应模型，因为稍后将用于拟合联合模型的包 JM 基于该函数的输出。为了说明 lme() 的用法，我们执行混合模型分析来描述 AIDS 数据集中患者的 CD4 细胞计数平方根随时间的演变。该数据集为 R 的 JM 包 (Rizopoulos, 2012b) 的数据框 aids，可以使用以下命令加载我们应注意，为了使用函数 lm() 拟合混合模型，数据需要以所谓的长格式排列，其中每个患者的测量值存储在多行中4。艾滋病数据集已经以这种格式组织；例如，前两名患者的纵向响应位于前七行CD4 列包含 CD4 细胞计数测量值的平方根，obstime 列包含记录相应纵向响应的时间点。我们从一个简单的线性混合模型开始分析，该模型假定了一个随时间的线性平均演变，并包括每个患者的单个随机效应项\\[\\left\\{\\begin{array}{l}y_{ij}=\\beta_0+\\beta_1t_{ij}+b_{i0}+\\varepsilon_{ij},\\\\b_{i0}\\thicksim\\mathcal{N}(0,\\sigma_b^2),\\quad\\varepsilon_{ij}\\thicksim\\mathcal{N}(0,\\sigma^2)\\end{array}\\right.\\]该模型假定所有患者的 CD4 细胞计数平方根在时间上具有完全相同的演变，但患者在基线时不同，即每个患者都有自己的截距，有些患者以较高的 CD4 计数开始，有些患者则以较低的 CD4 计数开始。这种特殊类型的线性混合模型称为随机截距模型 (random-intercepts model)，其图形展示在图 2.2 的左侧面板。lme() 的基本语法基于两个参数，分别命名为 fixed 和 random ，这两个参数是 R 公式，用于指定模型的固定效应和随机效应部分（有关 R 公式的基础的更多信息，请参阅附录 ）。\n对于 random 参数中的公式，用户还应指定分组变量的名称，以识别哪些重复测量属于同一组（在我们的示例中，组是患者）。data 参数用于指定存储了所有变量的数据框。拟合随机截距模型的相应调用是默认情况下，lme() 执行 REML 估计。summary() 函数返回拟合模型的详细输出，包括模型中所有参数的估计值、标准化残差的位置测量值以及用于拟合模型的数据的信息。方差分量（即参数 \\(\\sigma_b\\) 和 \\(\\sigma\\)）的估计在 Random effects 标题下给出，而回归系数 \\(\\beta\\) 估计以及相应的标准误、\\(t\\) 值和 \\(p\\) 值在 Fixed effects 标题下提供。正如预期的那样，时间效应系数具有负号，表明平均而言，CD4 细胞计数平方根随时间减小。随机截距模型下纵向响应的隐含边际协方差结构，具有以下形式\\[V_i=\\sigma_b^21_{n_i}1_{n_i}^\\top+\\sigma^2\\text{}_{n_i}\\]其中 \\(\\text{1}_{n_i}\\) 表示 \\(n_i\\) 维单位向量，假定方差 \\(\\sigma^2_b+\\sigma^2\\) 随时间恒定，并且任意两个时间点的测量值之间存在相等的正相关性 \\(\\rho=\\sigma_b^2/(\\sigma_b^2+\\sigma^2)\\)。该协方差阵称为复合对称的 (compound symmetric)，公共相关性 \\(\\rho\\) 通常称为类内相关系数 (intraclass correlation coefficient) (Hand Crowder, 1996). 可以使用函数 getVarCov() 从拟合的线性混合模型中提取特定患者的估计边际协方差阵 \\(\\widehat{V}_i\\)。对于我们的示例，我们提取患者 12 的协方差阵，他是数据集中第一个拥有所有五个计划测量值的患者因此，根据随机截距模型，每个时间点的测量误差方差估计等于 24.2，并且任何一对时间之间的协方差估计为 20.3. 使用函数 cov2cor() 可计算由该协方差矩阵导出的相关矩阵尽管随机截距模型的简单性很有吸引力，但它提出了一个不切实际的限制，即重复测量之间的相关性随时间保持不变。直观地说，我们预期在时间上相距更远的测量值之间的相关性更小。允许更灵活地指定协方差结构的一个扩展是随机截距和随机斜率模型：\\[\\left\\{\\begin{array}{ll}y_{ij}=\\beta_0+\\beta_1t_{ij}+b_{i0}+b_{i1}t_{ij}+\\varepsilon_{ij}\\\\b_i\\thicksim\\mathcal{N}(0,D),\\quad\\varepsilon_{ij}\\thicksim\\mathcal{N}(0,\\sigma^2)\\end{array}\\right.\\]该模型引入了一个额外的随机效应项，并假定 CD4 细胞计数的变化率因患者而异。其图形表示如图 2.2 的右侧面板所示。为了用 lme() 拟合该模型，我们在 random 参数中指定一个包含时间变量的公式（默认包含截距）与随机截距模型相比，我们固定效应参数估计的差异非常小。对于随机效应，我们可以观测到患者之间 CD4 基线水平的变异性大于标志物随时间演变的变异性。在随机截距和随机斜率模型下，同一个体的任何一对响应的隐含边际协方差函数形如\\[\\begin{align}\n\\begin{array}{rcl}\\text{cov}(y_{ij},y_{ij'})&=&\\begin{bmatrix}1&t_{ij}\\end{bmatrix}\\,D\\,\\begin{bmatrix}1\\\\t_{ij'}\\end{bmatrix}+\\sigma^2\\\\&=&d_{22}t_{ij}t_{ij'}+d_{12}(t_{ij}+t_{ij'})+d_{11}+\\sigma^2\\end{array}\n\\tag{2.6}\n\\end{align}\\]其中 \\(d_{kl}\\) 表示协方差阵 \\(D\\) 的第 \\(kl\\) 个元素。对于同一时间点 \\(t_{ij} = t_{ij'} = t\\)，方差函数为 \\(d_{22}t^2 + 2d_{12}t + d_{11} + \\sigma^ 2\\) ，其随时间呈二次函数，曲率为正数 \\(d_{22}\\)。因此，隐含边际模型\\[\\begin{aligned}y_i=X_i\\beta+\\varepsilon_i^*,\\quad\\varepsilon_i^*\\sim\\mathcal{N}(0,Z_iDZ_i^\\top+\\sigma^2\\text{}_{n_i})\\end{aligned}\\]具有异方差误差项。在艾滋病数据集中，边际协方差阵估计为相应的相关矩阵为正如预期的那样，我们观察到方差随着时间的推移而增加，而相关性降低。很明显，随机截距和随机斜率模型在为边际协方差阵建模时提供了更大的灵活性，但它再次施加了特定的关系（式 (2.6)），而这种关系可能并不总是适用于手头上的数据。例如，方差函数在时间上可能不是二次函数。为了实现更大的灵活性，并遵循与以前相同的方法，我们可以包含额外的随机效应项，从而更好地捕捉特定于受试者纵向轨迹的形状。这可以通过在随机效应设计矩阵 \\(Z_i\\) 的指定中使用多项式或回归样条等方法来实现。然而，我们需要注意，由于 \\(D\\) 需要是一个有效的、正定的协方差阵，因此任何随机效应结构都将意味着正的边际相关性。","code":"> data(aids, package = \"JM\")> aids[aids$patient %in% c(1,2), c(\"patient\", \"CD4\", \"obstime\")]\n  patient       CD4 obstime\n1       1 10.677078       0\n2       1  8.426150       6\n3       1  9.433981      12\n4       2  6.324555       0\n5       2  8.124038       6\n6       2  4.582576      12\n7       2  5.000000      18> lmeFit.int <- lme(CD4 ~ obstime, random = ~ 1 | patient,\ndata = aids)\n> summary(lmeFit.int)\n\nLinear mixed-effects model fit by REML\n  Data: aids \n\nRandom effects:\n Formula: ~1 | patient\n        (Intercept) Residual\nStdDev:    4.506494 1.961662\n\nFixed effects:  CD4 ~ obstime \n Correlation: \n        (Intr)\nobstime -0.194\n\nStandardized Within-Group Residuals:\n        Min          Q1         Med          Q3 \n-3.84004681 -0.44310988 -0.05388055  0.43593364 \n        Max \n 6.09265321 \n\nNumber of Observations: 1405\nNumber of Groups: 467 > margCov.int <- getVarCov(lmeFit.int, individuals = 12,\n                           type = \"marginal\")\n> margCov.int\n\npatient 12 \nMarginal variance covariance matrix\n       1      2      3      4      5\n1 24.157 20.308 20.308 20.308 20.308\n2 20.308 24.157 20.308 20.308 20.308\n3 20.308 20.308 24.157 20.308 20.308\n4 20.308 20.308 20.308 24.157 20.308\n5 20.308 20.308 20.308 20.308 24.157\n  Standard Deviations: 4.9149 4.9149 4.9149 4.9149 4.9149 > cov2cor(margCov.int[[1]])\n\n          1         2         3         4         5\n1 1.0000000 0.8407012 0.8407012 0.8407012 0.8407012\n2 0.8407012 1.0000000 0.8407012 0.8407012 0.8407012\n3 0.8407012 0.8407012 1.0000000 0.8407012 0.8407012\n4 0.8407012 0.8407012 0.8407012 1.0000000 0.8407012\n5 0.8407012 0.8407012 0.8407012 0.8407012 1.0000000> lmeFit.slp <- lme(CD4 ~ obstime, random = ~ obstime | patient,\n                    data = aids)\n> summary(lmeFit.slp)\n\ninear mixed-effects model fit by REML\n  Data: aids \n\nRandom effects:\n Formula: ~obstime | patient\n Structure: General positive-definite, Log-Cholesky parametrization\n            StdDev    Corr  \n(Intercept) 4.5898579 (Intr)\nobstime     0.1728716 -0.152\nResidual    1.7507927       \n\nFixed effects:  CD4 ~ obstime \n Correlation: \n        (Intr)\nobstime -0.218\n\nStandardized Within-Group Residuals:\n        Min          Q1         Med          Q3         Max \n-4.31678464 -0.41425064 -0.05227637  0.41094162  4.37414162 \n\nNumber of Observations: 1405\nNumber of Groups: 467 > margCov.slp <- getVarCov(lmeFit.slp, individuals = 12,\n                           type = \"marginal\")\n> margCov.slp\n\npatient 12 \nMarginal variance covariance matrix\n       1      2      3      4      5\n1 24.132 20.826 20.345 19.624 18.902\n2 20.826 23.771 20.463 20.101 19.738\n3 20.345 20.463 23.765 21.054 21.409\n4 19.624 20.101 21.054 25.550 23.915\n5 18.902 19.738 21.409 23.915 29.486\n  Standard Deviations: 4.9124 4.8755 4.8749 5.0547 5.4301 > cov2cor(margCov.slp[[1]])\n\n          1         2         3         4         5\n1 1.0000000 0.8695501 0.8495691 0.7903063 0.7086194\n2 0.8695501 1.0000000 0.8609738 0.8156372 0.7455397\n3 0.8495691 0.8609738 1.0000000 0.8544289 0.8087422\n4 0.7903063 0.8156372 0.8544289 1.0000000 0.8712910\n5 0.7086194 0.7455397 0.8087422 0.8712910 1.0000000"},{"path":"chap2.html","id":"sec2-3","chapter":"第 2 章 纵向数据分析","heading":"2.3 纵向研究中的缺失数据","text":"纵向数据分析的一个主要挑战是缺失数据问题。尽管纵向研究的目的是在一组预先指定的随访时间收集样本中每个受试者的数据，但经常出现一些受试者由于各种原因错过一些计划的测量的情况。根据缺失数据模式的特征，我们可以区分两种类型的缺失，即单调缺失和非单调缺失 (monotone non-monotone missingness). 单调缺失模式涵盖了受试者因各种原因在研究预期完成前退出的情况，即流失 (attrition) 或脱落 (drop-)，以及受试者未提供部分初始响应测量数据但随后加入并坚持完成研究的情况，即延迟入组 (late entry). 另一方面，非单调缺失，也称为间歇性缺失 (intermittent missingness)，是一种更普遍的类型，它涵盖了多种情况，例如，某个受试者在某次随访时缺失响应数据，在下一次随访时返回，但随后又可能在后续时间点再次缺失数据。表 2.1 给出了不同缺失数据模式的示例，其中受试者 1 完成了所有测量，受试者 2 在第四次就诊时退出，受试者 3 未提供第一次测量数据，而受试者 4 仅参加了第二次和第四次就诊。\n数据缺失的可能性给纵向研究的设计和这些研究的数据分析带来了一些挑战。第一个也是最明显的影响是效率的损失 (loss efficiency)，从这个意义上说，平均纵向演化变化的估计不如所有数据可用时那么精确。这对纵向研究的设计具有重要影响，因为我们需要招募更多的个体才能在检测重要效应方面达到相同水平的功效 (power). 精度的降低与缺失数据的数量直接相关，也受到所选分析方法的影响。此外，随着时间的推移，缺失会导致数据集不均衡，因为并非所有受试者在一组共同情况下都有相同数量的测量。这使得需要均衡数据的分析方法变得复杂，但这不会对线性混合效应模型带来任何影响。最后，在某些情况下，如果处理不当，缺失数据可能会带来偏差，从而得出误导性的推断。在不完全纵向响应的分析中，正是这最后一个因素引起了最大的关注。在更详细地讨论偏差问题是如何产生的之前，我们首先需要引入额外的术语，使我们能够对缺失值的机制设置正式条件，并确定该机制如何影响随后的推断。通常，我们假定研究中的每个受试者 \\(\\) 在时间点 \\(j=1,\\ldots,n_i\\) 进行测量，这意味着，对于该受试者，我们期望收集测量向量 \\(y_i=(y_{i1},\\ldots,y_{in_i})^\\top\\)。为了区分我们实际收集的响应测量值和计划收集的响应测量值，我们引入了缺失数据指示符，定义为\\[r_{ij}=\\left\\{\\begin{array}{ll}1&\\text{如果观测到 }y_{ij}\\\\0&\\text{其它}\\end{array}\\right.\\]因此，我们将完整响应向量 \\(y_i\\) 划分为两个子向量，观测数据子向量 \\(y^o_i\\) 包含那些 \\(r_{ij} = 1\\) 的 \\(y_{ij}\\)，而缺失数据子向量 \\(y^m_i\\) 包含其余分量。向量 \\(r_i = (r_{i1}, ..., r_{in_i} ) ^\\top\\) 以及生成 \\(r_i\\) 的过程称为缺失数据过程 (missing data process).当缺失仅限于流失或脱落时，缺失数据指示符 \\(r_i\\) 的形式始终为 \\((1, ..., 1, 0, ..., 0)\\)，因此可以用标量变量 \\(r^d_i\\) 替换，定义为\\[r_i^d=1+\\sum_{j=1}^{n_i}r_{ij}\\]对于不完全序列，\\(r^d_i\\) 表示发生脱落的时刻，而对于完全序列，\\(r^d_i = n_i+1\\)。在这两种情况下，\\(r^d_i\\) 等于一加上观测测量序列的长度，无论它是完全的还是不完全的。","code":""},{"path":"chap2.html","id":"sec2-3-1","chapter":"第 2 章 纵向数据分析","heading":"2.3.1 缺失数据机制","text":"不完全纵向数据分析的不同方法的适用性取决于缺失数据机制 (missing data mechanism). 缺失数据机制可认为是描述缺失数据 \\(r_i\\) 和响应数据 \\(y_i\\) 过程之间关系的概率模型。缺失数据机制的分类法首先由 Rubin (1976) 提出，并在 Little Rubin (2002) 中进一步发展，它基于缺失过程 \\(r_i\\) 的条件密度，给定完整响应向量 \\(y_i = (y^o_i , y^m_i)\\):\\[p(r_i\\mid y_i^o,y_i^m;\\theta_r)\\]其中 \\(\\theta_r\\) 表示相应的参数向量。这三种机制是 (Fitzmaurice et al., 2004; Molenberghs Kenward, 2007)：完全随机缺失 (Missing Completely Random, MCAR), 它假定响应缺失的概率与它们本应有的值以及观测响应集均无关。也就是说，当 \\(r_i\\) 与 \\(y^o_i\\) 和 \\(y^m_i\\) 均独立时，纵向数据是 MCAR，满足\\[\\begin{align}\np(r_i\\mid y_i^o,y_i^m;\\theta_r)=p(r_i;\\theta_r)\n\\tag{2.7}\n\\end{align}\\]MCAR 纵向数据的一个例子出现在健康调查中，调查对象进入研究，提供预定数量的重复测量后退出研究 (Fitzmaurice et al., 2004). 由于测量的次数和时间是由设计决定的，因此获得响应的概率与实际测量值无关。MCAR 的重要特征是，观测数据 \\(y^o_i\\) 可视为完全数据的随机样本。这反过来意味着观测数据的分布与完全数据的分布没有差异。因此，在 MCAR 下，我们可以使用任何有效的统计程序对手头的数据进行有效推断，同时可以忽略产生缺失值的过程。随机缺失 (Missing Random, MAR), 假定缺失的概率取决于观测响应集，但与本应有的值无关。也就是说，给定 \\(y_i^0\\)， \\(r_i\\) 条件独立于 \\(y^m_i\\) 时，纵向数据为 MAR，满足\\[\\begin{align}\np(r_i\\mid y_i^o,y_i^m;\\theta_r)=p(r_i\\mid y_i^o;\\theta_r)\n\\tag{2.8}\n\\end{align}\\]MAR 的等价表述是基于给定观测数据 \\(y^o_i\\) 和 \\(r_i\\) 的情况下，缺失纵向响应 \\(y^m_i\\) 的预测分布。具体来说，在 MAR 下，该分布具有以下形式。\\[\\begin{aligned}\np(y_i^m\\mid y_i^o,r_i;\\theta)& =\\quad\\frac{p(y_i^m,y_i^o,r_i;\\theta)}{p(y_i^o,r_i;\\theta)}  \\\\\n&=\\quad\\frac{p(r_i\\mid y_i^o,y_i^m;\\theta_r)p(y_i^o,y_i^m;\\theta_y)}{p(r_i\\mid y_i^o;\\theta_r)p(y_i^o;\\theta_y)} \\\\\n&=\\quad\\frac{p(r_i\\mid y_i^o;\\theta_r)p(y_i^o,y_i^m;\\theta_y)}{p(r_i\\mid y_i^o;\\theta_r)p(y_i^o;\\theta_y)} \\\\\n&=\\quad\\frac{p(y_i^o,y_i^m;\\theta_y)}{p(y_i^o;\\theta_y)} \\\\\n&=\\quad p(y_i^m\\mid y_i^o;\\theta_y),\n\\end{aligned}\\]其中 \\(\\theta\\) 表示测量和缺失过程的联合分布的参数向量，\\(\\theta_y\\) 表示测量模型的参数向量。MAR 缺失也经常称为随机缺失 (random missingness)，在缺失为脱落的情况下，称为随机脱落 (random drop-). 一个标准的 MAR 纵向数据例子出现在研究方案要求当患者的响应值超过特定医学相关阈值时，将该患者从研究中移除的情况。此时，缺失性是由研究者控制的，并且仅与观测到的 \\(y_i\\) 的分量相关。由于缺失数据机制依赖于 \\(y^o_i\\)（未观测到的 \\(y_i\\)），因此 \\(y^o_i\\) 的分布并不与 \\(y_i\\) 的分布完全吻合，因此我们不能认为观测数据是从目标总体中随机抽取的一个样本。只有每个受试者的缺失值 \\(y^m_i\\) 的分布，以她的观测值 \\(y^o_i\\) 为条件，与目标总体中相应观测值的分布相同。因此，在联合分布 \\(\\{y_i^o,y_i^m\\}\\) 的模型下，可以使用观测数据有效地预测缺失值。MAR 的这一特征的重要含义是，样本矩不是目标人群中相应矩的无偏估计。因此，基于这些矩而不考虑 MAR 的统计量，例如样本平均纵向演变的散点图，可能是误导性的。另一方面，在 MAR 下，即使我们忽略了 \\(r_i\\) 的贡献，基于观测数据的基于似然的分析可以提供有效的推断，前提是正确指定了测量过程 \\(y_i\\) 的模型。这可以从以下事实看出：第 \\(\\) 个受试者的完全数据 \\((y^o_i , y^m_i , r_i)\\) 的似然贡献被分解如下\\[\\begin{aligned}\nL_i(\\theta)& =\\quad\\int p(y_i,r_i;\\theta)dy_i^m  \\\\\n&=\\quad\\int p(y_i^o,y_i^m;\\theta_y)p(r_i\\mid y_i^o,y_i^m;\\theta_r)dy_i^m \\\\\n&=\\quad\\int p(y_i^o,y_i^m;\\theta_y)p(r_i\\mid y_i^o;\\theta_r)dy_i^m \\\\\n&=\\quad p(y_i^o;\\theta_y)p(r_i\\mid y_i^o;\\theta_r) \\\\\n&=\\quad L_i(\\theta_y)\\times L_i(\\theta_r)\n\\end{aligned}\\]因此，如果 \\(\\theta_y\\) 和 \\(\\theta_r\\) 是不相交的，即全向量 \\(\\theta=(\\theta^\\top y,\\theta_r^\\top)\\) 的参数空间等于 \\(\\theta_y\\) 和 \\(\\theta_r\\) 各自参数空间的乘积，则可以基于边际观测数据密度 \\(p(y_i^o;\\theta_y)\\) 来推断 \\(\\theta_y\\)，并且忽略缺失过程的可能性。MAR 下基于似然的推断的这种性质称为可忽略性 (ignorability).非随机缺失 (Missing Random, MNAR) 假定纵向响应缺失的概率取决于我们观测到的响应的子集。具体来说，\\(r_i\\) 的分布仍至少取决于子向量 \\(y^m_i\\) 中的某些元素，即使在给定 \\(y^o_i\\) 的条件下，即\\[\\begin{align}\np(r_i\\mid y_i^m;\\theta_r)\\quad\\mathrm{或}\\quad p(r_i\\mid y_i^o,y_i^m;\\theta_r)\n\\tag{2.9}\n\\end{align}\\]与 MAR 类似，MNAR 缺失也常称为非随机缺失，在脱落的情况下称为非随机脱落。MNAR 纵向数据的一个例子出现在疼痛研究中，当患者的疼痛水平超过其可以忍受的阈值时，他们可能会要求使用急救药物。当患者退出研究并要求使用急救药物时，我们通常没有他们的结果记录。与 MAR 的情况一样，在 MNAR 下，观测数据并不构成目标总体的随机样本。然而，与 MAR 相反，\\(y^m_i\\) 在给定 \\(y^o_i\\) 的条件下的预测分布与目标总体中的分布不同，而是取决于 \\(y^o_i\\) 和 \\(p(r_i\\mid y_i)\\)。因此，为缺失过程假定的模型至关重要，必须纳入分析。为了说明不同的缺失机制如何影响仅基于观测数据的推断，我们在图 2.3 中展示了 loess 散点平滑器对一个模拟数据集的拟合情况。该数据集来自一个线性混合效应模型，其中数据在 MAR 和 MNAR 机制下删除。我们可以清楚地观察到 loess 平滑器拟合（实线）与真实平均变化（虚线）之间的差异，尤其是在 MNAR 情况下。\n关于上述缺失数据机制定义，最后要说明的一点是，我们隐含地假定了缺失的概率可能取决于协变量。这引出了一个微妙但重要的问题。例如，如果缺失与某个协变量有关但与 \\(y_i\\) 无关（即 MCAR），并且在我们对测量过程的分析中，我们不以该协变量为条件，则 MCAR 不再有效。","code":""},{"path":"chap2.html","id":"sec2-3-2","chapter":"第 2 章 纵向数据分析","heading":"2.3.2 非随机缺失模型族","text":"根据上一节中的描述，很明显，最难处理的缺失数据机制类型是 MNAR 机制。当纵向数据是 MNAR 时，我们只能从基于测量和缺失过程的联合分布的分析中获得有效的推断。相关文献已经为这种联合分布提出了三个主要的模型族：选择模型 (selection models)、模式混合模型 (pattern mixture models) 和共享参数模型 (shared-parameter models) (Little, 1995; Molenberghs Kenward, 2007).选择模型的因子分解基于\\[p(y_i^o,y_i^m,r_i;\\theta)=p(y_i^o,y_i^m;\\theta_y)p(r_i\\mid y_i^o,y_i^m;\\theta_r)\\]其中右边第一项是测量过程的边际密度，第二项是以纵向结果为条件的缺失过程的密度。该建模框架的名称来自计量经济学文献 (Heckman, 1976)，基于以下事实：项 \\(p(r_i\\mid y_i^o,y_i^m;\\theta_r)\\) 可视为描述每个受试者选择继续参与研究或退出研究的概率机制。对于非随机脱落（即 MNAR）的纵向数据的分析，选择模型主要是在 Diggle Kenward (1994) 开创性工作之后受到关注的。模式混合模型 (Little, 1993, 1994) 基于与之相反的联合分布的因子分解，即\\[p(y_i^o,y_i^m,r_i;\\theta)=p(y_i^o,y_i^m\\mid r_i;\\theta_y)p(r_i;\\theta_r)\\]现在，我们有了给定缺失过程的测量过程的条件模型，以及缺失过程的边际模型。顾名思义，模式混合模型允许为每种缺失值模式采用不同的测量模型。因此，测量过程的边际分布是一个混合分布，其权重是每种缺失模式的概率。共享参数模型 (Wu Carroll, 1988; Wu Bailey, 1988, 1989; Follmann Wu, 1995; Hogan Laird, 1997, 1998) 引入随机效应来捕捉测量和缺失过程之间的关联，即\\[\\begin{aligned}p(y_i^o,y_i^m,r_i;\\theta)=\\int p(y_i^o,y_i^m\\mid b_i;\\theta_y)p(r_i\\mid b_i;\\theta_r)p(b_i;\\theta_b)db_i\\end{aligned}\\]因此，给定随机效应，假定这两个过程是独立的。该建模框架背后的想法是，有一个由随机效应刻画的潜在的潜过程，它驱动着两个直接观察到的过程。Verbeke Molenberghs (2000), Molenbergh Verbeke (2005) 以及 Molenbergs Kenward (2007) 全面介绍了用于分析不完全纵向数据的选择和模式混合建模框架的特征和特性。共享参数模型是本专著的重点，将在后续章节详细介绍。","code":""},{"path":"chap2.html","id":"sec2-4","chapter":"第 2 章 纵向数据分析","heading":"2.4 延伸阅读","text":"在本章中，我们介绍了线性混合效应模型的基本知识，该模型稍后将用作纵向与生存数据的联合模型的组成部分。对于混合模型和一般的纵向数据分析的全面概括，感兴趣的读者可以参考文献中的优秀文本。特别是，Verbeke Molenberghs (2000) 以及 Pinheiro Bates (2000) 中涵盖了连续数据的混合效应模型。第一本书对线性混合模型进行了全面论述，其中很大一部分内容集中在纵向研究中缺失数据的处理上；而第二本书则介绍了使用 nlme 包在 S 和 R 中实现线性和非线性混合模型的软件方法。Gelman Hill (2007) 以及 Snijders Bosker (1999) 涵盖了相关的分层模型 (hierarchical models) 和多水平模型 (multilevel models)，Searle et al. (1992) 和 Rao (1997) 详细阐述了方差分量估计的相关理论。Demidenko (2004), McCulloch et al. (2008) 以及 Jiang (2010) 这三本书则对连续数据和分类数据的混合模型进行了论述。Molenberghs Verbeke (2005) 重点关注离散纵向数据分析的模型，包括混合效应模型和边际模型。Diggle et al. (2002), Fitzmaurice et al. (2004) 以及 Hedeker Gibbons (2006) 则提供了对连续和分类纵向数据分析的不同建模框架的更一般概述。Skrondal Rabe-Hesketh (2004) 讨论了更一般的潜变量模型，其中混合效应模型是其特例。","code":""},{"path":"chap3.html","id":"chap3","chapter":"第 3 章 事件时间数据分析","heading":"第 3 章 事件时间数据分析","text":"本章介绍了生存数据分析的基本概念，以及相对风险模型类别，这是构成纵向与事件时间数据的联合模型的第二个组成部分。尤其关注时依协变量的处理。我们特别介绍了两种类型的时变协变量（即内生性和外源性），并解释了何时需要对协变量过程和事件发生风险进行联合建模，以得出有效的推论。","code":""},{"path":"chap3.html","id":"sec3-1","chapter":"第 3 章 事件时间数据分析","heading":"3.1 事件时间数据的特征","text":"许多研究的主要目的是分析发生预先指定的感兴趣事件之前的时间。在这些设定中，响应变量是事件发生之前的时间，通常称为失效时间 (failure time)、生存时间 (survival time) 或事件时间 (event time). 生存分析在临床和流行病学研究中使用最多，其中事件可能是死亡、肿瘤的出现、某些疾病的发展、疾病的复发、怀孕或戒烟。然而，在其他学科中也经常遇到事件时间。例如，在社会学中，我们可能对第一次婚姻的持续时间感兴趣，对报纸或杂志订阅时间的营销感兴趣，以及对工业中机器组件正常运行的时间感兴趣。过去，对生存数据的研究主要集中在生存概率的估计，以及在不同条件下对实验对象的生存分布进行简单的分组比较。近年来，研究重点主要转向了生存数据的统计建模。生存分析中使用的回归模型具有诸多优势，可以同时分析多个独立的预后因素，在调整基线特征的异质性和不均衡性的同时评估治疗差异，并使预测结果更加准确。在分析失效时间的统计数据时，必须考虑的首要特征是它们分布的形状。具体来说，由于事件时间必须为正数，因此它们的分布形状通常是有偏的。因此，依赖于正态分布的统计方法并不直接适用，如果用于生存数据，可能会产生无效的结果。然而，在许多情况下，通过对事件时间进行适当的变换（例如取对数或平方根）可以轻松克服这个问题。生存时间分析与其他统计领域最重要的区别在于删失 (censoring). 删失数据的特点是，并非所有研究对象的事件时间都能得到完全观测。这会产生两方面的影响。首先，标准的统计工具，如样本均值和标准差、\\(t\\) 检验和线性回归，它们假定我们拥有完整的信息，因此会对事件时间和有关量的分布产生有偏估计。其次，与完全数据相比，推断对生存时间分布的错误指定更为敏感。删失数据的分析取决于描述删失发生方式的删失机制的性质。首先，我们可以根据删失时间和实际事件时间在时间轴上的相对位置对删失机制进行分类，具体有如下类别：右删失 (right censoring)：对于研究对象的一个子集，只知道感兴趣的事件在某个时间点之后发生。例如，一个研究对象可能在研究结束时尚未经历感兴趣的事件（固定的 型删失），或者在记录了一定数量的事件后研究终止，因此并非所有研究对象在研究结束时都发生了事件（固定的 II 型删失），或者一个研究对象可能离开研究区域，因此无法继续参与（随机删失）。在这些例子中，对于一些研究对象，我们知道他们的事件发生在最后一次观测时间之后。左删失 (left censoring)：对于研究对象的一个子集，只知道感兴趣的事件发生在某个时间点之前。左删失的一个典型例子是一年级的孩子能够拼写自己名字的年龄。有些孩子能够在一年级之前做到这一点，但具体时间尚不清楚。区间删失 (interval censoring)：对于研究对象的一个子集，只知道感兴趣的事件发生在两个特定的时间点之间。区间删失通常发生在对疾病发病时间感兴趣的研究中。例如，艾滋病毒感染者定期接受艾滋病发病检测。当一名患者发现呈阳性时，实际上知道的是，该患者在当次就诊前与当次就诊之间的某个时间点患上了这种疾病。区间删失是最常见的删失类型，因为当包含真实失效时间的区间的上限为无穷大或下限为零时，它实际上分别是右删失和左删失。删失机制的第二种分类与研究对象删失的概率是否取决于失效过程有关。更具体地说，我们有：信息性删失 (informative censoring)：研究对象因直接与预期失效时间相关的原因退出研究（例如由于预后恶化）。更正式地说，如果在任何时间 \\(t\\)，仍在研究中的研究对象的失效率与退出研究的研究对象的失效率不同，那么删失机制就是信息性的。在某种意义上，信息性删失与 2.3.1 节中介绍的纵向研究中的 MNAR 缺失数据机制在精神上是相似的。非信息性删失 (noninformative censoring)：当受试者因与预后无关的原因退出研究时，但这可能取决于协变量。同样与纵向研究进行类比，非信息性删失对应于 MCAR 缺失数据机制。对于不同的删失机制类型，应采用不同的推断程序。就第一种分类而言，大多数文献都集中在能够处理右删失数据的方法上，因为这类数据最常见。就第二种分类而言，当删失机制具有信息性时，不幸的是，我们能做的事情很少。与纵向研究中的 MNAR 缺失数据机制类似，问题在于观察到的数据不足以对删失机制进行建模。因此，除非提供外部信息，否则在这些情况下进行有意义的分析的可能性相当有限。由于这些复杂性，大多数文献都集中在非信息性删失数据的方法上。在本书中，我们也只考虑非信息性右删失。","code":""},{"path":"chap3.html","id":"sec3-2","chapter":"第 3 章 事件时间数据分析","heading":"3.2 生存分析的基本函数","text":"令 \\(T^*\\) 表示所研究的失效时间的随机变量。主要用于描述 \\(T^*\\) 分布的函数是生存函数 (survival function). 如果事件是死亡，它表示死亡发生在 \\(t\\) 之后的概率，即存活时间 \\(t\\) 的概率。假定 \\(T^*\\) 是连续的，则生存函数定义为\\[\\mathcal{S}(t)=\\Pr(T^*>t)=\\int_t^\\infty p(s)ds\\]其中 \\(p(\\cdot)\\) 表示相应的概率密度函数。生存函数必须是随着 \\(t\\) 的增加而非增的，其中 \\(\\mathcal{S}(t=0)\\) 总是等于 1. 在生存分析中发挥突出作用的另一个函数是风险函数 (hazard function)。它描述了一个事件在时间区间 \\([t,t+dt)\\) 内的瞬时风险，前提是生存到 \\(t\\)，它定义为\\[\\begin{aligned}h(t)=\\lim_{dt\\to0}\\frac{\\Pr(t\\leq T^*<t+dt\\mid T^*\\geq t)}{dt},\\quad t>0.\\end{aligned}\\]根据其定义，\\(h(\\cdot)\\) 也称为瞬时风险函数 (instantaneous risk function) 或简称为风险函数 (risk hazard). 生存函数也可用风险函数表示为\\[\\begin{align}\n\\mathcal{S}(t)=\\exp\\bigl\\{-\\mathcal{H}(t)\\bigr\\}=\\exp\\bigl\\{-\\int_0^th(s)ds\\bigr\\}\n\\tag{3.1}\n\\end{align}\\]其中 \\(\\mathcal H(t)\\) 称为累积风险函数 (cumulative risk/hazard function)，描述直到时间 \\(t\\) 为止的累积风险。函数 \\(\\mathcal H(t)\\) 也可以解释为在时间 \\(t\\) 之前观察到的事件的预期数量。当我们有兴趣根据手头的随机样本估计这两个函数或事件时间分布的任何其他特征时，必须考虑删失。具体来说，令 \\(T_i\\) 表示受试者 \\(\\) 的观测事件时间，定义为真实事件时间和删失时间 \\(C_i\\) 的较小值。我们还引入了事件指示符 \\(\\delta_i=(T^*_i\\leqslant C_i)\\)，如果观测事件时间对应于真实事件时间，则取 1，否则取 0，其中 \\((\\cdot)\\) 表示指示函数 (indicator function). 一般来说，在生存分析中，我们感兴趣的是仅使用可用信息，即使用 \\(\\{T_i,\\delta_i\\}\\)来估计 \\(T^*_i\\) 的分布特征。我们首先讨论生存函数的估计。Kaplan Meier (1958) 提出了最著名的估计。这是一个非参数估计，不对失效时间的潜在分布做出任何假定。为引入该估计，令 \\(t_1,\\ldots,t_k\\) 表示手头样本中的唯一事件时间。使用全概率定律 (law total probability)，在任何时间点 \\(t\\) 生存的概率可以写为条件概率的乘积：\\[\\begin{aligned}\\Pr(T^*>t)=\\Pr(T^*>t\\mid T^*>t-1)\\times\\Pr(T^*>t-1\\mid T^*>t-2)\\times\\ldots\\end{aligned}\\]为了估计每个唯一事件时间的生存概率，我们利用上述展开式，并在计算条件概率时，通过适当调整处于风险中的研究对象（即尚未发生事件且未删失的研究对象）的数量来考虑删失，从而得到如下估计\\[\\begin{align}\n\\hat{\\mathcal{S}}_{KM}(t)=\\prod_{\\begin{array}{c}:t_i\\leq t\\\\\\end{array}}\\frac{r_i-d_i}{r_i}\n\\tag{3.2}\n\\end{align}\\]其中 \\(r_i\\) 表示在唯一事件 \\(t_i\\) 处仍处于风险中的受试者的数量，\\(d_i\\) 是在 \\(t_i\\) 处的事件数。可以使用 Greenwood 公式 (Greenwood, 1926; Kalbfleisch Prentice, 2002, Section 1.4) 来计算 \\(\\hat{\\mathcal{S}}_{KM}(t)\\) 的方差，并使用 \\(\\hat{\\mathcal{S}}_{KM}(t)\\) 的渐近正态性，可求出 \\({\\mathcal{S}}(t)\\) 的置信区间。然而，更好的方法是基于 \\(\\log\\mathcal{H}(t)\\) 的对称区间推导 \\({\\mathcal{S}}(t)\\) 的非对称置信区间。这确保了 \\({\\mathcal{S}}(t)\\) 的置信限不会跨越区间 \\([0,1]\\) 的界。\\(\\log\\hat{\\mathcal{H}}_{KM}(t)\\) 的方差是使用与 Greenwood 公式中 \\(\\hat{\\mathcal{S}}_{KM}(t)\\) 的方差相似的原理得出的，结果为\\[\\begin{aligned}\\text{v}\\hat{\\text{}}\\text{r}\\big\\{\\log\\hat{\\mathcal{H}}_{KM}(t)\\big\\}&=\\frac{\\sum_{:t_i\\leq t}d_i/\\{r_i(r_i-d_i)\\}}{\\left[\\sum_{:t_i\\leq t}\\log\\{(r_i-d_i)/r_i\\}\\right]^2}\\end{aligned}\\]在上述 \\({\\mathcal{S}}(t)\\) 的非对称置信区间的推导中，我们使用了累积风险函数的 Kaplan-Meier 估计 \\(\\hat{\\mathcal{H}}_{KM}(t)\\)。利用关系式 (3.1)，这实际上由 \\(\\hat{\\mathcal{H}}_{KM}(t)=-\\log\\hat{\\mathcal{S}}_{KM}(t)\\) 给出。另一个类似的累积风险函数非参数估计量是 Nelson-Aalen 估计，为此已经发展了丰富的渐近理论 (Altschuler, 1970; Nelson, 1972; Aalen, 1976; Fleming Harrington, 1991)\\[\\hat{\\mathcal{H}}_{NA}(t)=\\sum_{:t_i\\leq t}\\frac{d_i}{r_i}\\]其中 \\(d_i\\) 和 \\(r_i\\) 的解释与 Kaplan-Meier 估计相同。基于 Nelson-Aalen 估计并再次使用关系式 (3.1)，我们可以推导出以下生存函数估计\\[\\begin{align}\n\\hat{\\mathcal{S}}_B(t)=\\exp\\bigl\\{-\\hat{\\mathcal{H}}_{NA}(t)\\bigr\\}=\\prod_{:t_i\\leq t}\\exp(-d_i/r_i)\n\\tag{3.3}\n\\end{align}\\]这由 Breslow (1972) 提出。为了基于 Breslow 估计推导 \\(\\mathcal S(t)\\) 的置信区间，，我们再次使用与 Greenwood 公式中 \\(\\log\\hat{\\mathcal{H}}_{KM}(t)\\) 的方差相似的公式来估计 \\(\\log\\hat{\\mathcal{H}}_{NA}(t)\\) 的方差。生存函数的两个估计是渐近等价的。然而，在有限样本中 \\(\\hat{\\mathcal{S}}_B(t)\\geq\\hat{\\mathcal{S}}_{KM}(t)\\)，更重要的是，如果最大观测事件时间 \\(T_i\\) 对应于真实事件时间，则 \\(\\hat{\\mathcal{S}}_{KM}(T_i)=0\\)，而 \\(\\hat{\\mathcal{S}}_{B}(T_i)>0\\)。一般来说，Breslow 估计具有比 Kaplan-Meier 一致更小 (uniformly lower) 的方差，但它是上偏的 (biased upward)，特别是当 \\(\\hat{\\mathcal{S}}(t)\\) 接近零时。在比较均方误差时，这些方面会权衡 (Fleming Harrington, 1984)。图 3.1 给出了针对 PBC 数据集分别计算生存函数和累积风险函数的 Kaplan-Meier 和 Nelson-Aalen 估计的图示。","code":""},{"path":"chap3.html","id":"sec3-2-1","chapter":"第 3 章 事件时间数据分析","heading":"3.2.1 删失数据的似然构造","text":"当生存函数 \\(\\mathcal S(t)\\) 假定为一个特定的参数形式时，所关心参数的估计通常基于最大似然法，具体来说，令 \\(\\{T_i,\\delta_i\\},= 1,\\ldots,n\\) 表示来自分布函数 \\(\\mathcal P\\) 的随机样本中的生存信息，分布函数 \\(\\mathcal P\\) 由 \\(\\theta\\) 参数化，概率密度函数 \\(p(t;\\theta)\\)。在似然函数的构造中，我们需要考虑删失。更具体地说，在时间 \\(T_i\\) 观察到事件的受试者 \\(\\) 对似然贡献了 \\(p(T_i; \\theta)\\)，而对于在时间 \\(T_i\\) 删失的受试者 \\(\\)，我们所知道的是她存活到该点，即，\\(T^*> T_i = C_i\\)，因此，该受试者对似然贡献了 \\(\\mathcal S_i(T_i ; \\theta)\\)。因此，结合删失和未删失观测的信息，我们得到了对数似然函数\\[\\begin{align}\n\\ell(\\theta)=\\sum_{=1}^n\\delta_i\\log p(T_i;\\theta)+(1-\\delta_i)\\log\\mathcal{S}_i(T_i;\\theta)\n\\tag{3.4}\n\\end{align}\\]使用关系 \\(h(t)=p(t)\\big/\\mathcal{S}(t)\\) 和 \\(\\mathcal{S}(t)=\\exp\\{-\\mathcal{H}(t)\\}\\)，对数似然也可根据风险函数写为\\[\\begin{align}\n\\ell(\\theta)=\\sum_{=1}^n\\delta_i\\log h_i(T_i;\\theta)-\\int_0^{T_i}h_i(s;\\theta)ds\n\\tag{3.5}\n\\end{align}\\]从该等价公式中可以清楚地看出，所有受试者对对数似然的贡献量等于在其相应的观测事件时间\\(T_i\\) 处计算的累积风险函数的负值。经历该事件的受试者额外贡献的量等于在 \\(T_i=T^*_i\\) 处计算的对数风险函数。因此，与未删失的观测相比，删失观测对统计推断的贡献更少。一旦构建了对数似然函数，就可以利用 Newton-Raphson 算法 (Lange, 2004) 之类的迭代优化程序来找到最大似然估计值 \\(\\hat\\theta\\)。接下来，按照经典的渐近最大似然理论框架 (Cox Hinkley, 1974) 进行推断。","code":""},{"path":"chap3.html","id":"sec3-3","chapter":"第 3 章 事件时间数据分析","heading":"3.3 相对风险回归模型","text":"由于 Cox 模型 (Cox, 1972) 在现代生存分析中的普及，比例风险模型（也称为相对风险或相对危险模型）已占据了主导地位。这些模型假定协变量对事件的风险具有乘性效应，公式为\\[\\begin{align}\n\\begin{array}{rcl}h_i(t\\mid w_i)&=&\\lim_{dt\\to0}\\Pr(t\\leq T^*<t+dt\\mid T^*\\geq t,w_i)\\Big/dt\\\\&=&h_0(t)\\exp(\\gamma^\\top w_i)\\end{array}\n\\tag{3.6}\n\\end{align}\\]其中 \\(w_i^\\top=(w_{i1},\\ldots,w_{ip})\\) 表示假定与每个受试者的风险相关的协变量向量，\\(\\gamma\\) 表示相应的回归系数向量。函数 \\(h_0(t)\\) 称为基线危险或基线风险函数 (baseline hazard risk function)，对应于 \\(\\gamma^\\top w_i=0\\) 的受试者的危险函数。\\(\\gamma^\\top w_i\\) 是否包括截距 \\(\\gamma_0\\) 取决于基线风险函数是否具有恒定的尺度参数。将模型写为对数尺度\\[\\begin{aligned}\\log h_i(t\\mid w_i)=\\log h_0(t)+\\gamma_1w_{i1}+\\gamma_2w_{i2}+\\ldots+\\gamma_pw_{ip}\\end{aligned}\\]我们观察到，预测变量 \\(w_j\\) 的回归系数 \\(\\gamma_j\\) 表示如果 \\(w_j\\) 增加一个单位而所有其他预测变量保持不变，任何固定时间点 \\(t\\) 的对数风险的变化。类似地，\\(\\exp(\\gamma_j)\\) 表示在任意时间 \\(t\\)，\\(w_{ij}\\) 变化一个单位的风险比。一般来说，具有协变量向量 \\(w_i\\) 的受试者 \\(\\) 与具有协变量向量 \\(w_k\\) 的受试者 \\(k\\) 的风险比为：\\[\\begin{aligned}\\frac{h_i(t\\mid w_i)}{h_k(t\\mid w_k)}=\\exp\\{\\gamma^\\top(w_i-w_k)\\}\\end{aligned}\\]如 3.1 节所述，删失的影响之一是推断可能对事件时间分布的错误指定很敏感。在相对风险模型 (3.6) 下，\\(T^*_i\\) 的分布假定隐藏在基线风险函数的指定中。例如，当 \\(T^*_i\\) 服从 Weibull 分布时，基线风险函数将形如 \\(h_0(t)=\\phi\\sigma_tt^{\\sigma_t-1}\\)。在这种情况下，模型中所有参数的估计，即回归系数 \\(\\gamma\\) 和 \\(h_0(t)\\) 指定中的参数，通过最大化相应的对数似然函数 (3.5) 来进行。然而，Cox (1972) 表明，感兴趣的主要参数（即 \\(\\gamma\\)）的估计可以基于偏对数似然函数\\[\\begin{align}\np\\ell(\\gamma)=\\sum_{=1}^n\\delta_i\\bigg[\\gamma^\\top w_i-\\log\\bigg\\{\\sum_{T_j\\ge T_i}\\exp(\\gamma^\\top w_j)\\bigg\\}\\bigg]\n\\tag{3.7}\n\\end{align}\\]不需要指定 \\(h_0(t)\\)，即无需指定 \\(T^*_i\\) 的分布。因此，具有未指定基线风险函数的相对风险模型 (3.6) 是一个半参数模型，它不对事件时间的分布做出任何假定，但假定协变量对风险率具有乘法作用。直观上，偏似然可视为模型对患者生存时间排序良好程度的度量。尽管这不等于全对数似然 (3.5)，但可以这样处理。特别是，通过求解偏对数似然得分方程找到最大偏似然估计\\[\\begin{aligned}\\frac{\\partial p\\ell(\\gamma)}{\\partial\\gamma^\\top}=\\sum_{=1}^n\\delta_i\\bigg\\{w_i-\\frac{\\sum_{T_j\\ge T_i}w_j\\exp(\\gamma^\\top w_j)}{\\sum_{T_j\\ge T_i}\\exp(\\gamma^\\top w_j)}\\bigg\\}=0\\end{aligned}\\]解 \\(\\hat\\gamma\\) 与均值为 \\(\\gamma_0\\)（真参数向量）和方差为 \\(\\left[E\\{\\mathcal{}(\\gamma^0)\\}\\right]^{-1}\\)（对应于 (3.7) 的期望信息矩阵的逆）一致且渐近正态分布。由于该期望需要删失分布的知识，因此通常使用观测信息 \\(\\{\\mathcal{}(\\hat{\\gamma})\\}^{-1}\\) 来估计标准误，其中\\[\\mathcal{}(\\hat{\\gamma})=-\\sum_{=1}^n\\frac{\\partial^2p\\ell_i(\\gamma)}{\\partial\\gamma^\\top\\partial\\gamma}\\Big|_{\\gamma=\\hat{\\gamma}}\\]关于最大偏似然估计相对于最大似然估计（其中 \\(h_0(t)\\) 指定为某些未知参数）的相对效率的全面讨论，可参考 Kalbfleisch Prentice (2002, Section 5.9).","code":""},{"path":"chap3.html","id":"sec3-3-3","chapter":"第 3 章 事件时间数据分析","heading":"3.3.1 在 R 中的实现","text":"用于分析事件时间数据的主要 R 包是 survival 包 (Theerneau Lumley, 2012). 为了加载这个包，我们使用命令 library(\"survival\")。CRAN 中与生存分析相关的其他软件包的完整列表可从 CRAN Task View: Survival Analysis (Allignol Latouche, 2012) 中获取。用于拟合 Cox 模型的函数是 coxph()，它有两个主要参数，formula 参数指定观测失效时间与协变量之间的关系，data 参数指定包含这些变量的数据框。在 formula 参数的左侧，函数 Surv() 用于指定失效时间的可用信息，即观测失效时间和删失类型（即右、左、区间和计数5）。以下命令说明了如何使用 coxph() 将 Cox 模型拟合到 PBC 数据集，该数据集可从包 JM 中作为数据框 pbc2.id 获得。在前两行中，我们加载并定义复合事件的指标，即死亡或移植，以先到者为准。第三行拟合 Cox 模型。在函数 Surv() 中，我们指定变量 years 表示观测事件时间，变量 status2 表示事件指示符。默认情况下，假定为右删失。在 formula 参数右侧，我们指定死亡或移植的对数相对风险以加性方式取决于患者的治疗、年龄和性别。在最后一行中，调用 summary()来总结 Cox 模型的拟合情况。输出中的列 coeffe 包含回归系数估计。更容易解释的是 exp(coeff) 列提供的指数系数，它表示由于每个协变量导致的风险的乘性变化。我们观察到，积极治疗将复合事件的风险降低了约 12.9%，尽管没有统计学意义。另一方面，基线年龄增加一年与风险增加 2.2% 相关，男性发生事件的风险比女性高 63.8%.","code":"> data(pbc2.id, package = \"JM\")\n> pbc2.id$status2 <- as.numeric(pbc2.id$status != \"alive\")\n> coxFit <- coxph(Surv(years, status2) ~ drug + age + sex,\n                  data = pbc2.id)\n> summary(coxFit)\n\nCall:\ncoxph(formula = Surv(years, status2) ~ drug + age + sex, data = pbc2.id)\n\n  n= 312, number of events= 169 \n\n                  coef exp(coef) se(coef)      z Pr(>|z|)   \ndrugD-penicil -0.13759   0.87146  0.15597 -0.882  0.37770   \nage            0.02149   1.02172  0.00772  2.784  0.00537 **\nsexfemale     -0.49330   0.61061  0.20735 -2.379  0.01735 * \n---\nSignif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\n              exp(coef) exp(-coef) lower .95 upper .95\ndrugD-penicil    0.8715     1.1475    0.6419    1.1831\nage              1.0217     0.9787    1.0064    1.0373\nsexfemale        0.6106     1.6377    0.4067    0.9168\n\nConcordance= 0.573  (se = 0.023 )\nLikelihood ratio test= 14.97  on 3 df,   p=0.002\nWald test            = 16.1  on 3 df,   p=0.001\nScore (logrank) test = 16.3  on 3 df,   p=0.001"},{"path":"chap3.html","id":"sec3-4","chapter":"第 3 章 事件时间数据分析","heading":"3.4 时依协变量","text":"在 3.3 节介绍的相对风险模型中，我们假定风险仅取决于随访期间值不变的协变量，如基线年龄、性别、随机分配的治疗等。然而，在许多研究中，研究时依协变量 (time-dependent covariates) 是否与事件风险相关也可能是有意义的。其中可能包括环境因素、随访期间测量的生化和临床参数以及治疗剂量的调整。在我们解释如何在实践中处理这些协变量之前，我们应该首先区分两类不同的时依协变量，即外部或外源协变量和内部或内生协变量。区分时变协变量很重要的原因是，与外源协变量相比，内生协变量需要特殊处理。为了引入这两种类型的协变量，令 \\(y_i(t)\\) 表示受试者 \\(\\) 在时间 \\(t\\) 的协变量向量，\\(\\mathcal{Y}_i(t)=\\{y_i(s),0\\leq s<t\\}\\) 表示直到 \\(t\\) 的协变量史 (covariate history). 根据 Kalbfleisch Prentice (2002, Section 6.3)，对于所有满足 \\(0<s\\le s\\) 且 \\(ds\\rightarrow 0\\) 的 \\(s,t\\)，外源协变量的正式定义要求这些协变量满足以下关系\\[\\begin{align}\n\\Pr\\bigl\\{s\\leq T_i^*<s+ds\\mid T_i^*\\geq s,\\mathcal{Y}_i(s)\\bigr\\}\\\\=\\quad\\Pr\\bigl\\{s\\leq T_i^*<s+ds\\mid T_i^*\\geq s,\\mathcal{Y}_i(t)\\bigr\\}\n\\tag{3.8}\n\\end{align}\\]与其等价的定义为\\[\\begin{align}\n\\Pr\\bigl\\{\\mathcal{Y}_i(t)\\mid\\mathcal{Y}_i(s),T_i^*\\ge s\\bigr\\}=\\Pr\\bigl\\{\\mathcal{Y}_i(t)\\mid\\mathcal{Y}_i(s),T_i^*=s\\bigr\\},\\quad s\\le t\n\\tag{3.9}\n\\end{align}\\]它正式定义了这样的观点：\\(y_i(\\cdot)\\) 与时依失效率相关联，但到任何时间 \\(t > s\\) 的未来路径都不会受到时间 \\(s\\) 时发生失效的影响。特别是，外源协变量是一个可预测过程 (predictable process)，这意味着在任何时间 \\(t\\)，其值在 \\(t\\) 之前无限小的时间段内即可得知。另一方面，内生时变协变量是不满足(3.8) 或等价地不满足 (3.9) 的协变量，并且它们是不可预测的。外源协变量的一个标准例子是一天中的时间或一年中的季节。例如，自杀未遂事件的季节性模式已经得到认可，在冬季的几个月里发生率更高。外源协变量的另一个例子是那些从研究开始就预先确定了完整路径的协变量。例如，在一些研究中，人们有兴趣比较根据预定标准调整治疗剂量的治疗策略。另一种类型的外源协变量是受试者外部的随机过程。例如，环境因素的水平，如空气污染，可能与哮喘发作的频率有关。在所有这些例子中，很明显，这些协变量在任何时间点 \\(t\\) 的值都不受真实失效时间的影响，因此满足 (3.9)。对于外源协变量，在条件 (3.8) 或 (3.9) 下，我们可以直接定义以协变量路径为条件的生存函数，使用其与风险函数的关系，即\\[\\begin{array}{rcl}\\mathcal{S}_i(t\\mid\\mathcal{Y}_i(t))&=&\\Pr\\bigl(T_i^*>t\\mid\\mathcal{Y}_i(t)\\bigr)\\\\&=&\\exp\\Bigl\\{-\\int_0^th_i(s\\mid\\mathcal{Y}_i(s))ds\\Bigr\\}\\end{array}\\]另一方面，内生协变量通常是随着对研究对象进行的时依测量而出现的。这些包括生物标志物和临床参数，如原发性胆汁性肝硬化患者的血清胆红素水平、HIV 感染患者的 CD4 细胞计数、肝硬化患者的凝血酶原指数和主动脉狭窄患者的主动脉梯度水平（见 1.2 节）。有几个重要的特征使这种协变量的统计分析复杂化。首先，它们通常需要受试者的生存才能存在。因此，当失效定义为受试者的死亡时，他们的路径携带了关于失效时间的直接信息。更具体地说，只要 \\(y_i(t−ds)\\) 在 \\(ds \\rightarrow 0\\) 时存在，生存函数就满足\\[\\begin{align}\n\\mathcal{S}_i(t\\mid\\mathcal{Y}_i(t))=\\Pr\\bigl(T_i^*>t\\mid\\mathcal{Y}_i(t)\\bigr)=1\n\\tag{3.10}\n\\end{align}\\]另一方面，受试者在时间 \\(s\\) 的失效对应于在 \\(t\\ge s\\) 时不存在协变量，这直接意味着违反了条件 (3.9)。此外，式 (3.10) 的一个结果是，与外源协变量相反，之前定义为的风险函数为\\[\\begin{aligned}h_{}(t\\mid\\mathcal{Y}_{}(t))=\\lim_{dt\\to0}\\Pr\\{t\\leq T^{*}<t+dt\\mid T^{*}\\geq t,\\mathcal{Y}_{}(t)\\}\\big/dt\\end{aligned}\\]与生存函数没有直接关系。也就是说，函数\\[\\mathcal{S}_i(t\\mid\\mathcal{Y}_i(t))=\\exp\\Bigl\\{-\\int_0^th_i(s\\mid\\mathcal{Y}_i(s))ds\\Bigr\\}\\quad\\text{以及}\\quad p(t\\mid\\mathcal{Y}_i(t))=\\frac{h_i(t\\mid\\mathcal{Y}_i(t))}{\\mathcal{S}_i(t\\mid\\mathcal{Y}_i(t))}\\]没有通常的生存和密度函数解释。由于这一特征，基于 \\(p(·)\\) 和 \\(\\mathcal S(·)\\) 的对数似然构造 (3.4) 对于内生协变量没有意义。内生协变量的另一个特征是它们的测量通常存在误差。该测量误差主要是指由患者自身引起的生物变异，而不是由确定该协变量值的程序/机器引起的误差。特别是，即使在同一天内对同一患者进行两次测量，我们也不期望观察到内生性协变量（如生物标志物）的完全相同的值。因此，对于此类协变量，更合理的假设是观察到的标志物水平实际上是真实标志物水平受到生物变异污染的版本。然而，应该指出的是，测量误差并不是内生性协变量的独特特征，因为一些外源性协变量也存在测量误差（例如空气污染）。内生性协变量的最后一个重要含义是，它们的完整路径到任何时间 \\(t\\) 并没有被完全观测。也就是说，患者的生物标志物或其他临床参数水平仅在患者访问研究中心以提供测量数据的特定场合下才已知，而在这些就诊时间之间是未知的。","code":""},{"path":"chap3.html","id":"sec3-5","chapter":"第 3 章 事件时间数据分析","heading":"3.5 扩展的 Cox 模型","text":"3.3 节所介绍的 Cox 模型可通过 Andersen Gill (1982) 详细研究的计数过程公式进行扩展，以处理外源时依协变量，并在 Fleming Harrington (1991) 以及 Andersen et al. (1993) 中进行了更详细的介绍。Cox 模型这一公式的直观想法是将事件的发生视为一个非常缓慢的泊松过程的实现 (realization). 在计数过程表示法中，受试者 \\(\\) 的事件过程写为 \\(\\{N_i(t),R_i(t)\\}\\)，其中 \\(N_i(t)\\) 表示到时间 \\(t\\) 为止受试者 \\(\\) 的事件数，\\(R_i(t)\\) 是一个左连续的风险过程，当受试者 \\(\\) 在时间 \\(t\\) 处于风险时，\\(R_i(t) = 1\\)，否则 \\(R_i(t) = 0\\)。扩展的 Cox 模型（也称为 Andersen-Gill 模型）可表示为：\\[\\begin{align}\nh_i(t\\mid\\mathcal{Y}_i(t),w_i)=h_0(t)R_i(t)\\exp\\{\\gamma^\\top w_i+\\alpha y_i(t)\\}\n\\tag{3.11}\n\\end{align}\\]其中，如 (3.6) 所示，\\(w_i\\) 表示基线协变量向量，如性别或随机分配的治疗，\\(y_i(t)\\) 表示时依协变量向量。回归系数向量 \\(\\alpha\\) 的解释与 \\(\\gamma\\) 的解释完全相同。具体来说，简单起见，假定只有一个时依协变量，那么在任何特定的时间点 \\(t\\)，\\(\\exp(\\alpha)\\) 表示由于在同一时间点 \\(y_i(t)\\) 增加一个单位而导致的事件在时间 \\(t\\) 的风险的相对增加。此外，请注意，由于 \\(y_i(t)\\) 是时依的，模型 (3.11) 不再假定风险比在时间上是恒定的。\\(\\gamma\\) 和 \\(\\alpha\\) 的估计再次基于相应的偏对数似然函数，该函数可写为\\[\\begin{aligned}p\\ell(\\gamma)=\\,&\\sum_{=1}^{n}\\int_{0}^{\\infty}\\Big\\{R_{}(t)\\exp\\{\\gamma^{\\top}w_{}+\\alpha y_{}(t)\\}\\\\&-\\log\\Big[\\sum_{j}R_{j}(t)\\exp\\{\\gamma^{\\top}w_{j}+\\alpha y_{j}(t)\\}\\Big]\\Big\\}dN_{}(t)\\end{aligned}\\]其中使用了计数过程积分表示法 (Fleming Harrington, 1991; Andersen et al., 1993). 例如，我们为肝硬化数据集拟合了 Cox 模型，该模型假定死亡风险取决于凝血酶原指数和随机分配的治疗。\\[\\begin{aligned}h_i(t)=h_0(t)\\exp\\{\\gamma\\mathtt{Predns}_i+\\alpha y_i(t)\\}\\end{aligned}\\]其中，Predns 是泼尼松治疗组的指示变量，\\(y_i(t)\\) 表示时间 \\(t\\) 的凝血酶原指数水平。在扩展的 Cox 模型中，时依协变量通常使用 (start, stop) 符号进行编码。特别是，每个受试者由多行表示，每行存储了特定时间区间 \\(y_i(t)\\) 的信息。肝硬化数据集中第一位患者的行为start 和 stop 变量表示记录凝血酶原指数的时间区间的限。特别是，对于患者1，凝血酶原在基线时等于 38，在 0.24 年时等于 31，在 0.38 年时为 27. 如果事件发生在相应时间区间的终点，则变量 event 等于1。treat 表示治疗变量，在每个患者的整个随访期内都是固定的。使用以下语法拟合相应的扩展的 Cox 模型：与 3.3 节中用于拟合标准 Cox 模型的语法相比，唯一的区别在于 Surv() 函数的指定，其中前两个参数表示区间的限，最后一个参数是相应的事件指示符。此外，在 data 参数中，数据应以长格式提供。从结果中我们观察到，在校正治疗差异后，凝血酶原指数与死亡风险密切相关，凝血酶原每减少一个单位，风险就会增加为原来的 1.036 倍 (95%CI: 1.031, 1.041).Cox 模型的计数过程公式是一个相当通用的公式，它不仅可考虑时依协变量，还可考虑左截断、多个时间尺度、每个受试者的多个事件以及各种形式的病例队列模型等 (Therneau Grambsch, 2000). 然而，尽管具有这种灵活性，但当时依协变量具有内生性时，扩展的 Cox 模型并不适用。这是因为扩展的 Cox 模型假定时依协变量是可预测过程，测量时没有误差，并且完全指定了它们的完整路径。Cox 模型在计数过程公式下处理时依协变量的特殊方式如图 3.2 所示。更具体地说，假定时依协变量在随访时改变值，并在随访之间的时间区间内保持不变。那么，该模型假定一个事件在任何时间点 \\(t\\) 的风险与同一时间点的协变量的外推值有关。很明显，对于许多内生协变量，如生物标志物，这种阶跃函数近似是不现实的。例如，在上述肝硬化数据集的分析中，假定凝血酶原指数在随访之间保持不变是不合理的，特别是因为随访可能相隔几个月。这实际上意味着这种基于肝硬化数据集的扩展的 Cox 模型的分析不是最佳分析。特别是，这种末次结转 (Last\nValue Carried Forward) 法产生的问题是，参数估计和标准误可能存在严重偏差 (Prentice, 1982). 在本书的其余部分中，我们将介绍一个建模框架，该框架专门用于解释内生时依协变量的特殊特征。","code":"> data('prothro',package = 'JM')\n> head(prothro[c(\"id\", \"pro\", \"start\", \"stop\", \"event\")], n = 3)\n\n  id pro     start      stop event\n1  1  38 0.0000000 0.2436754     0\n2  1  31 0.2436754 0.3805717     0\n3  1  27 0.3805717 0.4134268     1> tdCox.pro <- coxph(Surv(start, stop, event) ~ pro + treat,\n                     data = prothro)\n> summary(tdCox.pro)\n\nCall:\ncoxph(formula = Surv(start, stop, event) ~ pro + treat, data = prothro)\n\n  n= 2968, number of events= 292 \n\n                     coef exp(coef)  se(coef)\npro             -0.034985  0.965620  0.002494\ntreatprednisone -0.137770  0.871299  0.118738\n                     z Pr(>|z|)    \npro             -14.03   <2e-16 ***\ntreatprednisone  -1.16    0.246    \n---\nSignif. codes:  \n0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\n                exp(coef) exp(-coef) lower .95\npro                0.9656      1.036    0.9609\ntreatprednisone    0.8713      1.148    0.6904\n                upper .95\npro                0.9704\ntreatprednisone    1.0996\n\nConcordance= 0.725  (se = 0.018 )\nLikelihood ratio test= 207.1  on 2 df,   p=<2e-16\nWald test            = 197.2  on 2 df,   p=<2e-16\nScore (logrank) test = 203.2  on 2 df,   p=<2e-16"},{"path":"chap3.html","id":"sec3-6","chapter":"第 3 章 事件时间数据分析","heading":"3.6 延伸阅读","text":"本章的目的是简要介绍失效时间数据的特殊特征，以及相关文献中开发的用于分析此类数据的基本统计工具。然而，这一介绍不是详尽无遗。文献中有许多优秀的文本对生存数据分析的不同方面进行了更深入的研究。特别是，Cox Oakes (1984), Kalbfleisch Prentice (2002), Lawless (2002) 以及 Klein Moeschberger (2003) 详细解释了事件时间数据的特殊特征，如删失和截尾，并详细举例说明了目前可用于其分析的不同统计工具。Fleming Harrington (1991), Andersen et al. (1993) 和 Aalen et al. (2008) 对使用点过程和鞅的 Cox 模型进行了更为理论化的处理，而 Therneau Grambsch (2000), Harrell (2001, Chapters 16-20) 以及 Tableman Kim (2003) 则从更实际的角度出发，主要关注模型构建和模型检验技术，以及它们在标准软件中的实现。Hougaard (2000) 提出了几种多变量生存数据的方法，包括脆弱和边际模型。Duchateauand Janssen (2008) 以及 Wienke (2011) 更详细地介绍了脆弱模型。Sun (2006) 概述了用于分析区间删失失效的可用方法。最后，Ibrahim et al. (2001) 说明了如何在贝叶斯范式下拟合先前文本中提出的标准生存模型。","code":""},{"path":"chap4.html","id":"chap4","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"第 4 章 纵向与事件时间数据的联合模型","text":"基于前两章提出的线性混合效应和相对风险模型，我们在这里介绍了纵向与事件时间数据的标准联合模型。我们讨论了模型参数的最大似然估计，包括优化和数值积分算法、回归系数的推断和随机效应，并提出了一种工具来研究纵向结果的推断对脱落过程假定的敏感性。","code":""},{"path":"chap4.html","id":"sec4-1","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.1 基本联合模型","text":"正如我们在 3.5 节看到的，扩展的 Cox 模型仅适用于外源时依协变量，因此无法处理纵向生物标志物。当主要关注的是这类内生时依协变量与生存之间的关联时，相关文献引入了一种替代的建模框架，称为纵向与事件时间数据的联合建模框架 (Faucett Thomas, 1996; Wulfsohn Tsiatis, 1997; Henderson et al, 2000; Tsiatis Davidian, 2004). 这些联合模型背后的主要动机是将作为主要关注的生存模型与用于内生协变量重复测量的模型相结合，以解释 3.4 节阐述的特殊特征。为介绍该建模框架，我们将使用与第 2 章和第 2 章中类似的符号。特别地，我们用 \\(T^*_i\\) 表示第 \\(\\) 个受试者的真实事件时间，\\(T_i\\) 表示观测事件时间，定义为潜在删失时间 \\(C_i\\) 和 \\(T^*_i\\) 的较小值，\\(\\delta_i = (T^*_i \\le C_i)\\) 表示事件指示符。对于内生时依协变量（例如生物标志物），我们令 \\(y_i(t)\\) 表示第 \\(\\) 个受试者在时间点 \\(t\\) 的观测值。我们应注意到，我们实际上并没有在任何时间 \\(t\\) 观测 \\(y_i(t)\\)，而只是在进行测量的特定时刻 \\(t_{ij}\\) 。因此，纵向观测数据由测量值 \\(y_{ij}=\\{y_i(t_{ij}),j=1,\\ldots,n_i\\}\\) 组成。","code":""},{"path":"chap4.html","id":"sec4-1-1","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.1.1 生存子模型","text":"我们的目标是度量纵向标志物水平与事件风险之间的关联，同时考虑前者的特殊特征。为了实现这一点，我们引入了项 \\(m_i(t)\\)，它表示时间 \\(t\\) 时纵向结果的真实但未观测到的值。注意，\\(m_i(t)\\) 与 \\(y_i(t)\\) 不同，后者是时间 \\(t\\) 时纵向结果受测量误差影响的值。为了量化 \\(m_i(t)\\) 与事件风险之间的关联强度，一种直接的方法是假定以下形式的相对风险模型\\[\\begin{align}\nh_{}(t\\mid\\mathcal{M}_{}(t),w_{})&=\\quad\\lim_{dt\\to0}\\Pr\\{t\\leq T_i^*<t+dt\\mid T_i^*\\geq t,\\mathcal{M}_i(t),w_i\\}\\big/dt\\\\&=\\quad h_0(t)\\exp\\bigl\\{\\gamma^\\top w_i+\\alpha m_i(t)\\bigr\\},\\quad t>0\n\\tag{4.1}\n\\end{align}\\]其中 \\(\\mathcal{M}_i(t)=\\{m_i(s),0\\leq s<t\\}\\) 表示截至时间点 \\(t\\) 的真实但未观测的纵向过程史，\\(h_0(\\cdot)\\) 表示基线风险函数，\\(w_i\\) 是基线协变量向量（例如治疗指标、疾病史等）与相应的回归系数向量 \\(\\gamma\\)。同样，参数 \\(\\alpha\\) 量化了潜在纵向结果对事件风险的影响。\\(\\gamma\\) 和 \\(\\alpha\\) 的解释与 3.5 节中的解释完全相同。具体来说，\\(\\exp(\\gamma_j)\\) 表示在任何时间 \\(t\\) 中 \\(w_{ij}\\) 的单位变化的风险比，而 \\(\\exp(\\alpha)\\) 表示在时间 \\(t\\) 时由于 \\(m_i(t)\\) 增加一单位而导致的事件风险的相对增加。此外，请注意，相对风险模型 (4.1) 假定时间 \\(t\\) 时事件的风险仅取决于时依标志物的当前值 \\(m_i(t)\\)。然而，这不适用于生存函数。特别地，利用生存函数和累积风险函数之间的已知关系，我们得到\\[\\begin{align}\n\\mathcal{S}_{}(t\\mid\\mathcal{M}_{}(t),w_{})&=\\quad\\Pr\\big(T_i^*>t\\mid\\mathcal{M}_i(t),w_i\\big)\\\\&=\\quad\\exp\\biggl(-\\int_0^th_0(s)\\exp\\bigl\\{\\gamma^\\top w_i+\\alpha m_i(s)\\bigr\\}ds\\biggr)\n\\tag{4.2}\n\\end{align}\\]这意味着相应的生存函数依赖于整个协变量史 \\(\\mathcal M_i(t)\\)。正如我们将在 4.3 节后面看到的，这一特征在联合模型的估计中具有实际重要性，因为生存函数是模型的似然的一部分。为了完成 (4.1) 的指定，我们需要讨论基线风险函数 \\(h_0(\\cdot)\\) 的选择。正如我们在第 3 章中所看到的，在标准生存分析中，为了避免错误指定生存时间分布的影响，习惯上完全不指定 \\(h_0(\\cdot)\\)。然而，在联合建模框架内，正如我们稍后将在 4.3.3 节中解释的那样，事实证明，遵循这样的路线可能会导致低估参数估计的标准误 (Hsieh et al., 2006)。为了避免此类问题，我们需要明确定义 \\(h_0(\\cdot)\\)。标准方案是使用与已知参数分布相对应的风险函数。在生存分析中，通常使用的分布包括 Weibull 分布、log-normal 分布和 Gamma 分布。或者，我们可以选择基线风险函数的参数但灵活的指定。相关文献中提出了几种方法来灵活地对基线风险函数进行建模。例如，Whittemore Killer (1986) 使用阶跃函数和线性样条来获得风险函数的非参数估计，Rosenberg (1995) 使用 B 样条近似，Herndon Harrell (1996) 使用限制性立方样条。两个在实践中通常非常令人满意的简单选项是分段常数和回归样条方法。在分段常数模型下，基线风险函数采用以下形式\\[\\begin{align}\nh_0(t)=\\sum_{q=1}^Q\\xi_qI(v_{q-1}<t\\leq v_q)\n\\tag{4.3}\n\\end{align}\\]其中 \\(0=v_{0}<v_{1}<\\cdots<v_{Q}\\) 表示表示时间尺度的分割，其中 \\(v_Q\\) 大于最大观测时间，\\(\\xi_q\\) 表示区间 \\((v_{q−1}, v_q]\\) 中的风险值。随着结数的增加，基线风险的指定变得更加灵活。在每个区间 \\((v_{q−1}, v_q]\\) 仅包含单个真实事件时间的极限情况下（假定没有结），该模型相当于完全不指定 \\(h_0(\\cdot)\\) 并使用非参数最大似然对其进行估计。对于回归样条模型，对数基线风险函数 \\(\\log h_0(t)\\) 扩展为立方样条的 B 样条基函数，如下所示\\[\\begin{align}\n\\log h_0(t)=\\kappa_0+\\sum_{d=1}^m\\kappa_dB_d(t,q)\n\\tag{4.4}\n\\end{align}\\]其中 \\(\\kappa^\\top=(\\kappa_0,\\kappa_1,\\ldots,\\kappa_m)\\) 为样条系数，\\(q\\) 表示 B 样条基函数 \\(B(\\cdot)\\) 的次数，以及 \\(m=\\ddot{m}+q-1\\)，其中 \\(\\ddot{m}\\) 表示内部结数。与分段常数模型类似，增加结数会增加近似 \\(h_0(\\cdot)\\) 的灵活性。然而，在这两种方法中，我们应该在偏差和方差之间保持平衡，避免过度拟合。一个标准的经验法则是将参数的总数，包括 (4.1) 中线性预测器和 \\(h_0(\\cdot)\\) 模型中的参数，保持在样本中事件总数的 1/10 到 1/20 之间 (Harrell, 2001, Section 4.4). 在确定了结数后，它们的位置通常基于观测事件时间 \\(T_i=\\min(T_i^*,C_i)\\) 的百分位数或仅基于真实事件时间 \\(\\{T_i:T_i^*\\leq C_i,=1,\\ldots,n\\}\\) ，以便在最大密度的区域中具有更大的灵活性。","code":""},{"path":"chap4.html","id":"sec4-1-2","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.1.2 纵向子模型","text":"在上面提出的生存模型的定义中，我们使用 \\(m_i(t)\\) 来表示时间点 \\(t\\) 的潜在纵向协变量的真实值。然而，如前所述，纵向信息实际上是间歇性收集的，并且在每个受试者的一组几个时间点 \\(t_{ij}\\) 处都有误差。因此，为了度量纵向协变量对事件风险的影响，我们需要估计 \\(m_i(t)\\) 并成功重建每个受试者的完整纵向史 \\(\\mathcal M_i(t)\\)。为了实现这一目标，我们假设一个合适的混合效应模型来描述特定于受试者的时间演变。现在我们将重点关注正态分布的纵向结果并使用线性混合效应模型。具体来说，使用类似于 2.2 节的符号，我们有\\[\\begin{align}\n\\left.\\left\\{\\begin{array}{rcl}y_i(t)&=&m_i(t)+\\varepsilon_i(t),\\\\m_i(t)&=&x_i^\\top(t)\\beta+z_i^\\top(t)b_i,\\tag{4.5}\\\\b_i&\\sim&\\mathcal{N}(0,D),\\quad\\varepsilon_i(t)\\sim\\mathcal{N}(0,\\sigma^2),\\end{array}\\right.\\right.\n\\end{align}\\]其中我们注意到固定效应 \\(\\beta\\) 的设计向量 \\(x_i(t)\\) 和随机效应 \\(b_i\\) 的设计向量 \\(z_i(t)\\) 以及误差项 \\(\\varepsilon_i(t)\\) 是时依的。此外，与 2.2 节类似，我们假定误差项是相互独立的，与随机效应无关，并且服从正态分布，均值为零，方差为 \\(\\sigma^2\\)。混合模型通过假设纵向结果 \\(y_i(t)\\) 的观测水平等于真实水平 \\(m_i(t)\\) 加上随机误差项来解释测量误差问题。此外，\\(x_i(t)\\) 和 \\(z_i(t)\\) 定义中的时间结构以及特定于受试者的随机效应的使用允许为每个受试者重建时依过程 \\(\\mathcal M_i(t)\\) 的完整路径。特别是，联合模型背后的直观想法如图 4.1 所示，其中在每个时间点，我们希望将标志物的真实水平（底部面板）与事件风险（顶部面板）相关联。虚线表示扩展的 Cox 模型在处理时变协变量时所假设的阶跃函数，这在许多情况下并不是对特定于受试者的纵向轨迹的真实描述。\n如前所述，生存函数 (4.2) 依赖于真实标志物水平的整个历史，因此，为了准确估计 \\(S_i(t)\\)，获得良好的 \\(\\mathcal M_i(t)\\) 估计是重要的。这需要考虑 \\(x_i(t)\\) 和 \\(z_i(t)\\) 中时间结构的详细说明，以及可能假设的时间结构和基线协变量之间的交互作用项。例如，在受试者表现出高度非线性纵向轨迹的应用中，建议使用灵活的方式来表示 \\(x_i(t)\\) 和 \\(z_i(t)\\)，这可以通过使用可能的时间 \\(t\\) 的函数的高维向量来实现，这些函数可以表示为高阶多项式或样条。与多项式相比，样条通常因其局部自然性和更好的数值性质而受到青睐 (Ruppert et al., 2003). 在联合建模框架中，一些作者已经考虑了基于样条的方法，以灵活地模拟受试者特定的纵向轨迹。例如，Rizopoulos et al. (2009) 和 Brown et al. (2005) 使用了具有多维随机效应的 B 样条，Ding Wang (2008) 提出了使用具有单一乘性随机效应的 B 样条，而 Rizopoulos Ghosh (2011) 则考虑了自然立方样条。对受试者特定进演变的高度非线性形状进行建模的另一种方法是在线性混合模型中加入一个额外的随机项，该项用于捕获未被随机效应捕获的观测测量中的剩余序列相关性。在此框架中，线性混合模型采用以下形式\\[\\begin{align}\ny_i(t)=m_i(t)+u_i(t)+\\varepsilon_i(t)\n\\tag{4.6}\n\\end{align}\\]其中 \\(u_i(t)\\) 是一个均值为零的随机过程，与 \\(b_i\\) 和 \\(\\varepsilon_i(t)\\) 无关，\\(m_i(t)\\) 具有与 (4.5) 中相同的混合效应模型结构。Wang Taylor (2001) 假设了一个集成的 Ornstein-Uhlenbeck 过程，Henderson et al. (2000) 则考虑了纵向过程和事件过程共享的潜在平稳高斯过程。这两种方法之间的选择在很大程度上是一个哲学问题，部分由分析师对生成数据的“真实”潜在生物机制的信念所决定。特别是，模型 (4.5) 假设受试者在整个时间内遵循的轨迹仅由与时间无关的随机效应 \\(b_i\\) 决定。这意味着每个对象的纵向曲线的形状是该对象随时间恒定的固有特征。另一方面，包含序列相关随机项和随机效应的模型 (4.6) 试图通过允许特定于受试者的趋势随时间变化来更精确地捕获纵向轨迹的特征。我们应该注意到，由于随机效应和随机序列相关过程都试图对数据中的边际相关性进行适当建模，因此两种方法之间存在信息的竞争。例如，如果我们假设一个具有随机截距和随机斜率结构的线性混合模型，并且随机效应未能充分捕捉过多的序列相关性，那么通过包含序列相关性项 \\(u_i(t)\\) 或者考虑更复杂的随机效应结构（例如，在设计矩阵 \\(Z_i(t)\\) 中使用样条）来扩展这个模型，可能会产生对数据的实际拟合效果难以区分的情况。因此，尽管同时使用精心设计的随机效应和序列相关结构在直觉上可能很有吸引力，但最好选择其中一种。从计算上讲，随机效应方法在实践中更容易实现，因为它只需要适当指定随机效应设计矩阵 \\(Z_i(t)\\)。","code":""},{"path":"chap4.html","id":"sec4-2","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.2 R 中的联合建模：与扩展的 Cox 模型比较","text":"为了说明联合建模方法的优点，我们将其与艾滋病数据集的扩展的 Cox 模型进行比较。具体来说，我们想评估时间 \\(t\\) 时的 CD4 细胞计数平方根与同一时间点的死亡风险之间的关联强度。艾滋病数据集在 R 中作为 JM 包中的数据框 aids (Rizopoulos, 2010, 2012b). 为了加载这个包，我们使用 library(\"JM\")。艾滋病数据集以长格式包含每个患者的纵向信息和生存信息。前两名患者的记录信息是其中 start, stop 和 event 表示风险区间和事件状态指示符，使用 3.5 节中介绍的计数过程公式，CD4 列包含 CD4 细胞计数测量值的平方根，obstime 为记录这些测量值的时间点（事实上它只是 start 列的副本）。我们通过拟合扩展的 Cox 模型开始分析，其中 CD4 细胞计数平方根视为外源时依协变量，并且我们另外控制治疗。模型为\\[\\begin{aligned}h_i(t)=h_0(t)\\exp\\{\\gamma\\mathtt{ddI}_i+\\alpha y_i(t)\\}\\end{aligned}\\]其中 \\(\\mathtt{ddI}_i\\) 为 ddI 组的虚拟变量，\\(y_i(t)\\) 表示观测 CD4 细胞计数水平的平方根。正如我们在 3.5 节中看到的，为了在 R 中拟合这个模型，我们使用以下语法我们观察到 CD4 细胞计数确实与死亡风险密切相关。具体来说，CD4 细胞计数平方根的单位减少对应于死亡风险增加为原来的 \\(\\exp(-\\alpha) = 1.2\\) 倍 (95% CI: 1.16, 1.27). 我们通过指定并拟合一个明确解释 CD4 细胞计数标志物内生性的联合模型来进行。特别是，利用研究的随机化设定，我们拟合了线性混合模型\\[\\begin{array}{rcl}y_i(t)&=&m_i(t)+\\varepsilon_i(t)\\\\&=&\\beta_0+\\beta_1t+\\beta_2\\{t\\times\\mathtt d\\mathtt d\\mathtt I_i\\}+b_{i0}+b_{i1}t+\\varepsilon_i(t)\\end{array}\\]其中，在固定效应部分，我们包括时间的主效应和治疗与时间的交互作用，在随机效应设计矩阵中，我们包括截距和时间项。对于生存子模型，类似于上述 Cox 模型，我们将治疗作为与时间无关的协变量，并将根据纵向模型估计的 CD4 细胞计数的真实潜在分布作为时依协变量，即\\[h_i(t)=h_0(t)\\exp\\{\\gamma\\mathtt{ddI}_i+\\alpha m_i(t)\\}\\]与未指定 \\(h_0(t)\\) 的 Cox 模型相反，这里假定基线风险函数是分段常数，其中六个结置于观测事件时间的等距百分位数处。为了使用 JM 包拟合该联合模型，我们首先需要分别拟合线性混合效应模型和 Cox 模型，然后在函数 jointModel() 中提供返回的对象作为主要参数。更具体地说，在默认指定中，由 jointModel() 拟合的联合模型对于纵向和生存子模型具有与这两个单独拟合的模型完全相同的结构，此外，在生存子模型中，估计的“真实”纵向结果 \\(m_i(t)\\) 的效应包含在线性预测器中。Cox 模型需要拟合在仅包含生存信息的数据集中（即每个患者单行观测）。对于艾滋病数据集，这可以使用如下语法构建 aids.id 数据框来生成函数 jointModel() 使用拟合的线性混合模型和 Cox 模型（作为前两个参数）来提取所有所需信息（例如，响应向量、设计矩阵、事件指示符等），以拟合联合模型；因此，在对 coxph() 的调用中，我们需要指定 x=TRUE6，这样 Cox 模型的设计矩阵就包含在返回的对象中。下面的代码说明了如何为艾滋病数据集拟合联合模型jointModel() 的主参数 timeVar 用于指定线性混合效应模型中时间变量的名称，这是 \\(m_i(t)\\) 的内部计算所必需的。method 参数指定了基线风险函数的类型，此处假定其为分段常数，以及数值积分方法（有关数值积分选项的更多信息，请参阅 4.3.5 节）。拟合联合模型的详细输出由函数 summary() 生成，该函数返回参数估计及其标准误以及纵向和生存子模型的渐近 Wald 检验等。在 Event Process 的结果中，标记为 Assoct 的参数实际上是 (4.1) 中的参数 \\(\\alpha\\)，用于度量 \\(m_i(t)\\)（在这个例子中为真实 CD4 细胞计数平方根）与死亡风险之间的关联。参数 xi.1, . . . , xi.7是 (4.3) 中分段恒定基线风险函数的参数 \\(\\xi_q(q=1,\\ldots,7)\\)。联合模型还发现，CD4 细胞计数平方根与死亡风险之间存在强烈关联，标志物的单位减少对应于死亡风险增加为原来的 \\(\\exp(-\\alpha)=1.3\\) 倍 (95% CI: 1.24, 1.43). 比较扩展的 Cox 模型和联合模型的点估计以及相应的 95% 置信区间，我们能清楚地看到不可忽略的差异。特别地，联合模型中的 CD4 细胞计数平方根的对数风险比比扩展的 Cox 模型中的大大约 49%，并且 Cox 模型的风险比的 95% 置信区间的上限刚好高于联合模型的相同置信区间的下限。这些发现说明了由于 CD4 细胞计数水平测量误差导致的标准 Cox 分析回归系数衰减的程度。JM 包遵循随机效应范式，目前仅适用于具有独立同分布的误差项的线性混合效应子模型，没有如 (4.6) 所示的序列相关结构。因此，在调用 lm() 以生成作为 jointModel() 的第一个参数提供的对象时，用户不应指定相关结构（correlation 参数）或方差函数（weights 参数）。关于随机效应的协方差矩阵，默认情况下 jointModel() 假定它是非结构化的，并估计其所有自由参数。然而，它也允许使用对角协方差阵，该矩阵可以使用 lme() 的 random 参数中的函数 pdDiag() 来指定。当考虑高维随机效应结构时，此选项特别有用。此外，除了拟合艾滋病数据的联合模型中假定的分段恒定基线风险函数外，jointModel() 还允许生存子模型的其他公式。这些是由 method 参数指定的，可用选项有7method = \"piecewise-PH-GH\"：具有分段恒定基线风险函数 (4.3) 的相对风险模型 (4.1)。默认情况下，使用六个内部结，这些结位于观测事件时间的等距百分位数处。要更改内部结的默认数量，可以使用控制参数 lng..kn，而若要直接指定结的位置，可以使用控制参数 knots。method = \"spline-PH-GH\"：具有对数基线风险函数 (4.4) 的样条近似的相对风险模型 (4.1)。与分段常数类似，默认情况下，使用五个内部结，这些结位于观测事件时间的等距百分位数处，参数 lng..kn 和 knots 可用于更精细的控制。method = \"Cox-PH-GH\"：具有未指定的基线风险函数的相对风险模型 (4.1)。这一假定等价于假定 \\(h_0(\\cdot)\\) 在唯一的事件发生时刻是离散的，即具有点质量，即\n\\[h_0(t)=\\left\\{\\begin{array}{ll}\\xi_q,&t=T_q^*\\\\0,&t\\neq T_q^*\\end{array}\\right.\\]\n其中 \\(T^*_q\\) 表示第 \\(q\\) 个唯一真实事件时间。该选项对应于 Wulfsohn Tsiatis (1997) 提出的联合模型。method = \"weibull-PH-GH\"：具有 Weibull 基线风险函数的相对风险模型 (4.1)。此时 \\(h_0(t)=\\sigma_tt^{\\sigma_t-1}\\) 并且 (4.1) 中基线协变量的设计矩阵 \\(W\\) 也包含截距项8。method = \"weibull-AFT-GH\"：具有 Weibull 基线风险函数的加速失效时间模型。有关此公式的更多详细信息请参见 5.6 节。","code":"> head(aids[c(\"patient\", \"start\", \"stop\", \"event\",\n              \"CD4\", \"obstime\", \"drug\")], 7)\n\n  patient start  stop event       CD4 obstime drug\n1       1     0  6.00     0 10.677078       0  ddC\n2       1     6 12.00     0  8.426150       6  ddC\n3       1    12 16.97     0  9.433981      12  ddC\n4       2     0  6.00     0  6.324555       0  ddI\n5       2     6 12.00     0  8.124038       6  ddI\n6       2    12 18.00     0  4.582576      12  ddI\n7       2    18 19.00     0  5.000000      18  ddI> td.Cox <- coxph(Surv(start, stop, event) ~ drug + CD4,\n                  data = aids)\n> td.Cox\n\n  patient start  stop event       CD4 obstime drug\n1       1     0  6.00     0 10.677078       0  ddC\n2       1     6 12.00     0  8.426150       6  ddC\n3       1    12 16.97     0  9.433981      12  ddC\n4       2     0  6.00     0  6.324555       0  ddI\n5       2     6 12.00     0  8.124038       6  ddI\n6       2    12 18.00     0  4.582576      12  ddI\n7       2    18 19.00     0  5.000000      18  ddI\n> td.Cox <- coxph(Surv(start, stop, event) ~ drug + CD4,\n+                 data = aids)\n> td.Cox\nCall:\ncoxph(formula = Surv(start, stop, event) ~ drug + CD4, data = aids)\n\n            coef exp(coef) se(coef)      z        p\ndrugddI  0.30948   1.36271  0.14653  2.112   0.0347\nCD4     -0.19343   0.82412  0.02437 -7.937 2.08e-15\n\nLikelihood ratio test=94.62  on 2 df, p=< 2.2e-16\nn= 1405, number of events= 188 > aids.id <- aids[!duplicated(aids$patient), ]> lmeFit.aids <- lme(CD4 ~ obstime + obstime:drug,\n                     random = ~ obstime | patient, data = aids)\n> coxFit.aids <- coxph(Surv(Time, death) ~ drug,\n                       data = aids.id, x = TRUE)\n> jointFit.aids <- jointModel(lmeFit.aids, coxFit.aids,\n                              timeVar = \"obstime\", method = \"piecewise-PH-aGH\")\n> summary(jointFit.aids)\n\nCall:\njointModel(lmeObject = lmeFit.aids, survObject = coxFit.aids, \n    timeVar = \"obstime\", method = \"piecewise-PH-aGH\")\n\nData Descriptives:\nLongitudinal Process        Event Process\nNumber of Observations: 1405    Number of Events: 188 (40.3%)\nNumber of Groups: 467\n\nJoint Model Summary:\nLongitudinal Process: Linear mixed-effects model\nEvent Process: Relative risk model with piecewise-constant\n        baseline risk function\nParameterization: Time-dependent \n\n   log.Lik      AIC      BIC\n -4328.261 8688.523 8754.864\n\nVariance Components:\n             StdDev    Corr\n(Intercept)  4.5839  (Intr)\nobstime      0.1822 -0.0468\nResidual     1.7377        \n\nCoefficients:\nLongitudinal Process\n                  Value Std.Err z-value p-value\n(Intercept)      7.2203  0.2218 32.5537 <0.0001\nobstime         -0.1917  0.0217 -8.8374 <0.0001\nobstime:drugddI  0.0116  0.0302  0.3834  0.7014\n\nEvent Process\n            Value Std.Err  z-value p-value\ndrugddI    0.3348  0.1565   2.1397  0.0324\nAssoct    -0.2875  0.0359  -8.0141 <0.0001\nlog(xi.1) -2.5438  0.1913 -13.2953        \nlog(xi.2) -2.2722  0.1784 -12.7328        \nlog(xi.3) -1.9554  0.2403  -8.1357        \nlog(xi.4) -2.5011  0.3412  -7.3297        \nlog(xi.5) -2.4152  0.3156  -7.6531        \nlog(xi.6) -2.4018  0.4007  -5.9941        \nlog(xi.7) -2.4239  0.5301  -4.5725        \n\nIntegration:\nmethod: (pseudo) adaptive Gauss-Hermite\nquadrature points: 5 \n\nOptimization:\nConvergence: 0 "},{"path":"chap4.html","id":"sec4-3","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.3 联合模型的估计","text":"","code":""},{"path":"chap4.html","id":"sec4-3-1","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.3.1 两阶段法","text":"由于联合模型可能性的数值计算的复杂性（将在以下各节中解释），拟合这些模型的初始方法集中于两阶段法。具体来说，Self Pawitan (1992) 提出了一种联合模型，其相对风险子模型形如 (4.1)，具有未指定的基线风险函数 \\(h_0(t)\\)，并且项 \\(\\exp\\{\\alpha m_i(t)\\}\\) 替换为 \\(\\{1 +\\alpha m_i(t)\\}\\)，使得模型在随机效应 \\(b_i\\) 中呈线性9。作者建议使用两步推理法来估计该联合模型，其中第一步使用最小二乘法估计随机效应，第二步则利用这些估计来估计合适的 \\(m_i(t)\\) 值，并将其代入 Cox 模型的偏似然中。Tsiatis et al. (1995) 还开发了一种两阶段法来估计联合模型，该方法结合了 (4.1) 和 (4.5)，但没有对风险函数线性化。特别地，对于每个唯一的事件时间，他们建议用估计 \\(E\\{m_i(t)\\mid\\mathcal{Y}_i(t),T_i\\geq t\\}\\) 来代替偏似然贡献中的项 \\(m_i(t)\\)。对于任何事件时间 \\(t\\)，可通过使用在 \\(t\\) 时仍处于风险的所有受试者直到时间 \\(t\\) 的观测响应来拟合相应的混合模型，并使用随机效应 \\(b_i\\) 的经验贝叶斯估计来计算 \\(m_i(t)\\) 的最佳线性无偏预测因子 (best linear unbiased predictor)，来获得该估计。尽管这些方法相对容易用标准软件实现，但在许多情况下，它们会产生有偏的结果。Dafni Tsiatis(1998), Tsiatis daviddian (2001), Ye et al. (2008b) 以及 Sweeting Thompson (2011) 的一系列模拟研究都证明了这一点。出于这个原因，这类联合模型的文献主要集中在消除这种偏差的全似然方法上，而非依赖于近似。","code":""},{"path":"chap4.html","id":"sec4-3-2","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.3.2 联合似然公式","text":"为联合模型提出的主要估计方法是（半参数）最大似然 (Wulfsohn Tsiatis, 1997; Henderson et al., 2000; Hsieh et al., 2006)。Zeng Cai (2005) 研究了未指定基线风险函数下半参数最大似然估计的渐近性质。Hanson et al. (2011), Chi Ibrahim (2006), Brown Ibraham (2003), Xu Zeger (2001) 以及 Wang Taylor (2001) 等已经考虑了使用 MCMC 技术的联合模型的贝叶斯估计。此外，Tsiatis Davidian (2001) 提出了一种条件得分方法，其中随机效应视为讨厌参数 (nuisance parameter)，他们开发了一组无偏估计方程，该方程生成一致和渐近的正态估计。作为更传统的方法之一，我们在这里给出了联合模型的最大似然方法的基本原理。最大似然估计是通过与观测结果 \\(\\{T_i,\\delta_i,y_i\\}\\) 的联合分布相对应的对数似然函数的众数推导出来的。为了定义该联合分布，我们假定与时间无关的随机效应向量 \\(b_i\\) 构成了纵向过程和生存过程的基础。这意味着这些随机效应既解释了纵向结果与事件结果之间的关联，也解释了纵向过程中重复测量之间的相关性（条件独立性）。正式地，我们有\\[\\begin{align}\np(T_i,\\delta_i,y_i\\mid b_i;\\theta)\\quad&=\\quad p(T_i,\\delta_i\\mid b_i;\\theta)~p(y_i\\mid b_i;\\theta),\\quad\\text{以及}\n\\tag{4.7}\n\\\\\\\\p(y_i\\mid b_i;\\theta)\\quad&=\\quad\\prod_jp\\{y_i(t_{ij})\\mid b_i;\\theta\\}\n\\tag{4.8}\n\\end{align}\\]其中 \\(\\theta=(\\theta_t^\\top,\\theta_y^\\top,\\theta_b^\\top)^\\top\\) 表示全参数向量，其中 \\(\\theta_t\\) 表示事件时间结果的参数，\\(\\theta_y\\) 表示纵向结果的参数，\\(\\theta_b\\) 表示随机效应协方差阵的唯一参数，\\(y_i\\) 是第 \\(\\) 个受试者纵向响应的 \\(n_i \\times 1\\) 向量。此外我们假定，给定观测历史，删失机制和就诊过程独立于真实事件时间和未来的纵向测量。如前所述，就诊过程是产生收集纵向测量的时间点的机制（随机的或确定的） (Lipsitz et al., 2002)，对于任何时间点 \\(t\\)，我们将 \\(t\\) 之前纵向过程的所有可用信息定义为观测史。实际上，这些假定意味着受试者是否退出研究或出现在诊所进行纵向测量的决定取决于观测史（纵向测量和基线协变量），但不存在额外的依赖于潜在的、与预后相关的潜在受试者特征。当两个过程中的任何一个取决于随机效应时，就会违反这些假设。这是因为这种依赖性隐含地对应于对未来纵向测量的依赖性。对于就诊过程和删失过程的非信息性进行评估通常需要来自主题专家的外部信息，因为观测数据没有足够的信息表明情况并非如此。在这些假设下，第 \\(\\) 个受试者对对数似然的贡献可表示为\\[\\begin{align}\n\\log p(T_i,\\delta_i,y_i;\\theta)&=\\log\\int p(T_i,\\delta_i,y_i,b_i;\\theta)~db_i\\tag{4.9}\\\\&=\\log\\int p(T_i,\\delta_i\\mid b_i;\\theta_t,\\beta)\\Big[\\prod_jp\\{y_i(t_{ij})\\mid b_i;\\theta_y\\}\\Big]p(b_i;\\theta_b)~db_i\n\\end{align}\\]其中生存部分的条件密度 \\(p(T_i,\\delta_i\\mid b_i;\\theta_t,\\beta)\\) 形如\\[\\begin{align}\np(T_i,\\delta_i\\mid b_i;\\theta_t,\\beta)\\quad=&\\quad h_i(T_i\\mid\\mathcal{M}_i(T_i);\\theta_t,\\beta)^{\\delta_i}\\mathcal{S}_i(T_i\\mid\\mathcal{M}_i(T_i);\\theta_t,\\beta)\\tag{4.10}\\\\\n=&\\quad\\left[h_0(T_i)\\exp\\{\\gamma^\\top w_i+\\alpha m_i(T_i)\\}\\right]^{\\delta_i} \\\\\n&\\quad\\times\\exp\\biggl(-\\int_0^{T_i}h_0(s)\\exp\\{\\gamma^\\top w_i+\\alpha m_i(s)\\}ds\\biggr)\n\\end{align}\\]其中，\\(h_0(\\cdot)\\) 可以是时间的任意正函数，例如分段常数模型 (4.3)、B 样条模型 (4.4) 或任何已知分布的风险函数，生存函数由 (4.2) 给出。纵向响应和随机效应的联合密度由下式给出\\[\\begin{align}\np(y_i\\mid b_i;\\theta)p(b_i;\\theta) =&\\quad\\prod_jp\\{y_i(t_{ij})\\mid b_i;\\theta_y\\}p(b_i;\\theta_b)  \\tag{4.11}\\\\\n=&\\quad(2\\pi\\sigma^2)^{-n_i/2}\\exp\\bigl\\{-\\parallel y_i-X_i\\beta-Z_ib_i\\parallel^2/2\\sigma^2\\bigr\\} \\\\\n&\\quad\\times(2\\pi)^{-q_b/2}\\mathrm{det}(D)^{-1/2}\\exp\\!\\left(-b_i^\\top D^{-1}b_i/2\\right)\n\\end{align}\\]其中，\\(q_b\\) 表示随机效应向量的维数，并且 \\(\\parallel x\\parallel={\\left\\{\\sum_ix_i^2\\right\\}^{1/2}}\\) 表示向量的欧式范数。对数似然函数 \\(\\ell(\\theta)=\\sum_i\\log p(T_i,\\delta_i,y_i;\\theta)\\) 关于 \\(\\theta\\) 的最大化可使用标准算法来实现，例如期望最大化 (EM, Dempster et al., 1977) 算法或 Newton-Raphson 算法或其任何变体 (Lange, 2004)。在联合建模文献中，EM 算法传统上是首选的（将随机效应视为“缺失数据”），主要是因为在 M 步中，一些参数具有闭合形式的更新。然而，EM 算法的一个严重缺点是其收敛速度是线性的，导致收敛缓慢，尤其是在接近最大值时。尽管如此，Rizopoulos et al. (2009) 指出，对应于 \\(\\ell(\\theta)\\) 的得分向量实际上是 EM 或 Newton 型算法中所需的关键函数。特别值得注意的是，该得分向量可重写为以下形式：\\[\\begin{align}\nS(\\theta)=&\\quad\\sum_i\\frac\\partial{\\partial\\theta^\\top}\\log\\int p(T_i,\\delta_i\\mid b_i;\\theta)p(y_i\\mid b_i;\\theta)p(b_i;\\theta)db_i\\\\=&\\quad\\sum_i\\frac1{p(T_i,\\delta_i,y_i;\\theta)}\\frac\\partial{\\partial\\theta^\\top}\\int p(T_i,\\delta_i\\mid b_i;\\theta)p(y_i\\mid b_i;\\theta)p(b_i;\\theta)db_i\\\\=&\\quad\\sum_i\\frac1{p(T_i,\\delta_i,y_i;\\theta)}\\int\\frac\\partial{\\partial\\theta^\\top}\\{p(T_i,\\delta_i\\mid b_i;\\theta)p(y_i\\mid b_i;\\theta)p(b_i;\\theta)\\}db_i\\\\=&\\quad\\sum_i\\int\\Big[\\frac\\partial{\\partial\\theta^\\top}\\log\\big\\{p(T_i,\\delta_i\\mid b_i;\\theta)p(y_i\\mid b_i;\\theta)p(b_i;\\theta)\\big\\}\\Big]\\\\&\\quad\\times\\frac{p(T_i,\\delta_i\\mid b_i;\\theta)p(y_i\\mid b_i;\\theta)p(b_i;\\theta)}{p(T_i,\\delta_i,y_i;\\theta)}db_i\\\\=&\\quad\\sum_i\\int (\\theta,b_i)p(b_i\\mid T_i,\\delta_i,y_i;\\theta)db_i \\tag{4.12}\n\\end{align}\\]其中，\\((\\cdot)\\) 表示完全数据得分向量，由 \\((\\theta,b_i)=\\partial\\{\\log p(T_i,\\delta_i\\mid b_i;\\theta)+\\log p(y_i\\mid b_i;\\theta)+\\log p(b_i;\\theta)\\}/\\partial\\theta^\\top\\) 给出。请注意，观测数据得分向量表示为完全数据得分向量关于随机效应后验分布的期望值。这意味着 (4.12) 可以发挥双重作用。具体来说，如果对应于 (4.12) 的得分方程是关于 \\(\\theta\\) 求解的，其中 \\(p(b_i\\mid T_i,\\delta_i,y_i;\\theta)\\) 固定为前一次迭代的 \\(\\theta\\) 值，则这对应于 EM 算法，而如果得分方程是考虑 \\(p(b_i\\mid T_i,\\delta_i,y_i;\\theta)\\)（也是 \\(\\theta\\) 的函数）关于 \\(\\theta\\) 求解的，则这相当于观测数据对数似然 \\(\\ell(\\theta)\\) 的直接最大化。附录 ?? 给出了关于联合模型 EM 算法步骤指定的更多细节。最后一个事实也有助于直接计算参数估计的标准误。具体来说，即使我们已经使用 EM 算法估计了联合模型，我们也可以容易地使用观测数据得分向量 (4.12) 来计算 Hessian 矩阵，并随后使用观测信息矩阵（即，Hessian 阵的拟的负数）来计算标准误。使用与上述得分向量推导类似的计算，我们可以将 Hessian 矩阵重写为以下形式\\[\\begin{aligned}\n\\frac{\\partial S_i(\\theta)}{\\partial\\theta}\\quad =&\\quad\\frac{\\partial}{\\partial\\theta}\\int (\\theta,b_i)p(b_i\\mid T_i,\\delta_i,y_i;\\theta)db_i  \\\\\n\\quad=&\\quad\\int\\frac{\\partial (\\theta,b_i)}{\\partial\\theta}p(b_i\\mid T_i,\\delta_i,y_i;\\theta)db_i \\\\\n&+\\underbrace{\\int (\\theta,b_i)\\frac{\\partial p(b_i\\mid T_i,\\delta_i,y_i;\\theta)}{\\partial\\theta}db_i}_{I_1}\n\\end{aligned}\\]其中\\[\\begin{aligned}\nI_{1}\\quad=&\\quad\\int (\\theta,b_i)\\Big\\{\\frac{\\partial\\log p(b_i\\mid T_i,\\delta_i,y_i;\\theta)}{\\partial\\theta}\\Big\\}^\\top p(b_i\\mid T_i,\\delta_i,y_i;\\theta)db_i \\\\\n\\quad=&\\quad\\int (\\theta,b_i)\\bigg\\{\\frac{\\partial\\{\\log p(T_i,\\delta_i\\mid b_i;\\theta)+\\log p(y_i\\mid b_i;\\theta)+\\log p(b_i;\\theta)\\}}{\\partial\\theta} \\\\\n&\\quad-\\frac{\\partial\\log p(T_i,\\delta_i,y_i;\\theta)}{\\partial\\theta}\\Bigg\\}^\\top p(b_i\\mid T_i,\\delta_i,y_i;\\theta)db_i \\\\\n\\quad=&\\quad\\int (\\theta,b_i)\\Big\\{(\\theta,b_i)-S_i(\\theta)\\Big\\}^\\top p(b_i\\mid T_i,\\delta_i,y_i;\\theta)db_i\n\\end{aligned}\\]然而，在实践中，通常更容易使用数值求导程序，如前向或中心差分近似 (Press et al., 2007)，并仅使用计算得分向量的函数来计算 Hessian. 在估计了 \\(\\mathcal{}(\\theta)\\) 之后，参数估计的标准误可以基于的观测信息矩阵估计，即\\[\\begin{aligned}\\operatorname{var}(\\hat{\\theta})=\\{\\mathcal{}(\\hat{\\theta})\\}^{-1},\\quad\\text{其中}\\quad\\mathcal{}(\\hat{\\theta})=-\\sum_{=1}^n\\left.\\frac{\\partial S_i(\\theta)}{\\partial\\theta}\\right|_{\\theta=\\hat{\\theta}}\\end{aligned}\\]需要注意的是，由于事件的发生导致的脱落，观测信息矩阵在计算标准误时优于期望信息矩阵；有关更多详细信息，请参阅 4.6 节以及 Kenward Molenberghs (1998).","code":""},{"path":"chap4.html","id":"sec4-3-3","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.3.3 具有未指定基线风险函数的标准误","text":"正如我们在第 3 章中所讨论的，Cox 模型在标准生存分析中的巨大优势在于，偏似然可用于估计相对风险模型的回归系数。这在实践中意味着（扩展的）Cox 模型的回归系数的标准误和推断具有类似于渐近最大似然理论的良好渐近性质，而不必指定适当的基线风险函数 (Andersen Gill, 1982).不幸的是，在联合建模框架下，这一好特性没有被继承 (Hsieh et al., 2006). 具体来说，由于使用了随机效应，正如我们在 4.3.2 节中所看到的，联合模型的估计不能再仅基于偏似然，而必须采用全似然方法。当我们为生存子模型定义一个具有未指定基线风险函数的联合模型时，似然的计算是基于非参数最大似然参数的，在该参数下，未指定的累积发生率函数 \\(H_0(t)=\\int_0^th_0(s)ds\\) 被在唯一事件时间具有跳跃的阶跃函数取代 (van der Vaart, 1998). 在这种设定下，很明显，参数向量 \\(\\theta\\) 通常具有非常高的维度，因为它还包含高维度子向量 \\(h_0(t)\\)。从实际的角度来看，参数向量的高维度可能导致产生标准误所需的 Hessian 矩阵的计算和求逆的数值复杂性。因此，标准误的估计通常基于轮廓似然方法。即 \\(\\ell_p(\\beta,\\sigma,\\gamma,\\alpha,\\hat{h}_0(\\beta,\\sigma,\\gamma,\\alpha))\\)，其中 \\(\\hat{h}_0(\\beta,\\sigma,\\gamma,\\alpha)\\) 表示作为剩余参数的函数的 \\(h_0(t)\\) 的非参数最大似然估计。为了使轮廓似然渐近性起作用，这种非参数最大似然估计不应依赖于 \\(h_0(t)\\) (Hsieh et al., 2006). 然而不幸的是，在联合模型下情况并非如此，因为由于使用了随机效应，该估计没有闭合形式的解。在实践中，通常使用来自 EM 算法的 M 步的如下估计：\\[\\begin{aligned}\\hat{h}_0(t)&=\\sum_{=1}^n\\frac{\\delta_iI(T_i=t)}{\\sum_{j=1}^nI(T_i\\geq t)\\int\\exp\\{\\hat{\\gamma}^\\top w_j+\\hat{\\alpha}m_j(t,b)\\}p(b_i\\mid T_i,\\delta_i,y_i;\\hat{\\theta})db_i}\\end{aligned}\\]可以看出，通过随机效应的后验分布 \\(p(b_i\\mid T_i,\\delta_i,y_i;\\hat{\\theta})\\)，它仍然是 \\(h_0(t)\\) 的函数。因此，基于轮廓得分向量\\[S(\\theta_{-h},\\hat{h}_0(\\theta_{-h}))=\\frac{\\partial}{\\partial\\theta_{-h}^\\top}\\ell_p(\\theta_{-h},\\hat{h}_0(\\theta_{-h}))\\]的其余参数估计 \\(\\hat{\\theta}_{-h}=(\\beta,\\sigma,\\gamma,\\alpha)\\) 的标准误普遍会被低估。为了克服这个问题，Hsieh et al. (2006) 提出在使用未指定的基线风险函数时使用 Bootstrapping (Efron Tibshirani, 1994) 来估计标准误。然而很明显，这种方法使得这种类型的联合模型的计算要求相当高。一个可行的替代方案是为 \\(h_0(t)\\) 假定一个灵活但参数化的模型。正如我们在 4.1.1 节中看到的，有两种选择是使用立方样条或分段常数模型。这些参数模型的优点是双重的：首先，它们可以通过增加内部结数来实现任意的灵活性，从而捕获 \\(h_0(t)\\) 的各种形状；其次，在这种模型下，标准误的估计直接服从渐近最大似然理论 (Cox Hinkley, 1974).在函数 jointModel() 中，具有未指定基线风险函数（即参数 method=\"Cox-PH-GH\"）的联合模型的标准误是根据上面介绍的轮廓得分向量计算的，因此用户应预期这些标准误会被低估。","code":""},{"path":"chap4.html","id":"sec4-3-4","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.3.4 JM 中的优化控制","text":"函数 jointModel() 实现了一个混合优化过程来定位最大似然估计。具体来说，该过程从 EM 算法开始进行固定次数的迭代，如果没有实现收敛，则切换到 quasi-Newton 算法，直到实现收敛。可用的 quasi-Newton 算法是 optim() 的 BFGS (Nash, 1990) 和 nlminb() 的 PORT 程序 (Gay, 1990). 参数的初始值取自线性混合模型和生存模型，这些模型作为 jointModel() 中的前两个参数提供。在 EM 迭代过程中，只要满足以下两个常用标准中的任何一个，就会宣布收敛。\\[\\max\\left\\{|\\theta^{()}-\\theta^{(-1)}|\\big/(|\\theta^{(-1)}|+\\epsilon_1)\\right\\}<\\epsilon_2,\\\\\\ell(\\theta^{()})-\\ell(\\theta^{(-1)})<\\epsilon_3\\big\\{|\\ell(\\theta^{(-1)})|+\\epsilon_3\\big\\}\\]其中 \\(\\theta^{()}\\) 表示第 \\(\\) 次迭代时的参数值，\\(\\ell(\\theta)=\\sum_i\\log p(T_i,\\delta_i,y_i;\\theta)\\)。\\(\\epsilon_1\\) 和 \\(\\epsilon_2\\) 的常用值约为 10−3 或 10−4，默认情况下，\\(\\epsilon_3\\) 设置为 sqrt(.Machine$double.eps)，约为 10–8。在 quasi-Newton 迭代过程中，通常只使用后一个标准。jointModel() 的 control 参数提供了对优化过程的更精细控制。其他指定了 EM 的次数（参数 iter.EM）和 quasi-Newton 迭代次数（参数 iter.qN）、quasi-Newton 算法的类型（参数 optimizer）、收敛标准的容限（参数 tol1, tol2 和 tol3 分别对应于 \\(\\epsilon_1,\\epsilon_2\\) 和 \\(\\epsilon_3\\)），以及基于得分向量计算 Hessian 矩阵的数值导数的类型（即，前向或中心差分近似——参数 numeriDeriv 和 eps.Hes）。通过在 jointModel() 的调用中直接包含感兴趣的 control 参数，可以很容易地更改这些参数的默认值。例如，为了将联合模型拟合到 4.2 节中介绍的艾滋病数据集，使用 80 次 EM 迭代，具有更严格的收敛容限，并使用中心差分近似来计算标准误，可使用以下语法最后一个参数 eps.Hes 控制中心差分近似中的步长长度。","code":"> jointFit.aids <- jointModel(lmeFit.aids, coxFit.aids,\n                              timeVar = \"obstime\", method = \"piecewise-PH-aGH\", iter.EM = 80,\n                              tol3 = 1e-09, numeriDeriv = \"cd\", eps.Hes = 1e-04)"},{"path":"chap4.html","id":"sec4-3-5","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.3.5 数值积分","text":"拟合纵向数据和生存数据的联合模型的一个关键计算困难是，生存函数定义 (4.2) 中关于时间的积分 ，以及得分向量 (4.12) 指定中关于随机效应的积分，没有解析解，除非在非常特殊的情况下。这意味着在对数似然和得分向量的计算中，通常采用数值方法来近似每个受试者的这些积分。这一特征与数值优化的要求相结合，使得联合模型的拟合成为一项计算密集型任务。从联合模型指定中涉及的两个积分来看，关于随机效应的积分是主要的计算瓶颈。具体来说，生存函数定义中的积分总是一维的，并且可以使用 7 点或 15 点 Gauss-Kronrod 规则 (Press et al., 2007) 相对有效地近似它。 然而，随着维数的增加，关于随机效应的积分在计算上变得需要近似。计算这种多维积分的标准数值积分技术包括 Gaussian 求积规则 和 Monte Carlo 采样，并已在文献中常规用于拟合联合模型 (Wulfsohn Tsiatis, 1997; Henderson et al., 2000; Song et al., 2002). 此外，Rizopoulos et al. (2009) 和 Ye et al. (2008a) 讨论了在假设高维随机效应向量的情况下（例如，如 4.1 节所述，用于捕捉非线性），将 Laplace 近似用于与 Gaussian 求积 和 Monte Carlo 相比计算效率更高的联合模型。尽管如此，所有这些方法在计算上仍然要求相对较高，这也是联合模型尚未在现代应用统计学家的工具箱中占据应有位置的主要原因。Rizopoulos (2012a) 提出了一种在一定程度上减小计算负担的替代方法。这种方法背后的想法是首先拟合纵向结果的混合效应模型，并在给定每个受试者的纵向响应的情况下提取关于随机效应后验分布的位置和尺度的信息。然后，该信息用于在联合模型的对数似然和得分向量的定义中适当地重新缩放特定于受试者的被积函数。为了激励这种方法，我们首先引入了用于计算联合模型的得分向量的标准和自适应 Gaussian-Hermite 规则. 在标准 Gaussian-Hermite 规则 下，对于随机效应任何形式的 \\((\\cdot)\\) 函数，得分向量定义中的积分近似为预先指定的被积函数求值的加权和：\\[E\\{(\\theta,b_i)\\mid T_i,\\delta_i,y_i;\\theta\\}=\\int (\\theta,b_i)p(b_i\\mid T_i,\\delta_i,y_i;\\theta)db_i\\\\\\quad\\quad\\approx\\quad2^{q_b/2}\\sum_{t_1\\cdots t_q}\\pi_tA(\\theta,b_t\\sqrt{2})\\,\\,p(b_t\\sqrt{2}\\mid T_i,\\delta_i,y_i;\\theta)\\,\\,\\exp(\\|b_t\\|^2)\\]\n其中 \\(\\sum_{t_1\\cdots t_q}\\) 是 \\(\\sum_{\\large t_1=1}^K\\cdots\\sum_{\\large t_q=1}^K\\) 的简写，其中 \\(K\\) 表示求积点的数量，\\(b_t^\\top=(b_{t_1},\\ldots,b_{t_q})\\) 是具有相应权重 \\(\\pi_t\\) 的横坐标。如果被积函数可用 \\(\\exp(-b^\\top b)l(b)\\) 的形式表示，其中 \\(l\\left(b\\right)\\) 表示对横坐标进行插值的任何小于等于 \\(2K − 1\\) 次的多项式。因此，随着求积点 \\(K\\) 的数量增加，近似的质量得到改善。然而，由于 Gaussian-Hermite 规则需要对每个随机效应的横坐标的笛卡尔乘积上的被积函数进行计算，计算负担随着 \\(q_b\\) 呈指数增加。另一个对 Gaussian-Hermite 近似质量有很大影响的关键方面是求积点相对于被积函数主质量位置的位置。也就是说，如果 \\(g(b)=(\\theta,b)p(b\\mid T_i,\\delta_i,y_i;\\theta)\\) 集中在远离零的点附近，或者如果 \\(g(b)\\) 中的散布与权函数 \\(\\exp(−b^2)\\) 非常不同，那么将标准 Gaussian-Hermite 规则直接应用于 \\(g(b)\\) 可能会给出非常差的近似，即使对于大 \\(K\\) 也是如此，因为求积规则中的横坐标不会位于大多数 \\(g(b)\\) 的质量定位 (Pinheiro Bates, 1995). 为了解决这个问题，已经提出了自适应 Gaussian-Hermite 规则，该规则在每次迭代中适当地对被积函数进行中心化和缩放。更具体地说\\[\\begin{align}\n&E\\{(\\theta,b_i)\\mid T_i,\\delta_i,y_i;\\theta\\}\\\\&\\approx\\quad2^{q_b/2}|\\widehat{B}_i|^{-1}\\sum_{t_1\\cdots t_q}\\pi_tA(\\theta,\\hat{r}_t)p(\\hat{r}_t\\mid T_i,\\delta_i,y_i;\\theta)\\exp(\\|b_t\\|^2)\n\\tag{4.13}\n\\end{align}\\]其中 \\(\\hat{r}_t=\\hat{b}_i+\\sqrt{2}\\widehat{B}_i^{-1}b_t,\\hat{b}_i=\\arg\\max_b\\{\\log p(T_i,\\delta_i,y_i,b;\\theta)\\}\\)，\\(\\widehat{B}_i\\) 表示 \\(\\widehat{H}_i\\) 的 Choleski 因子，其中 \\(\\widehat{H}_i=-\\partial^2\\log p(T_i,\\delta_i,y_i,b;\\theta)/\\partial b\\partial b^\\top\\Big|_{b\\boldsymbol{=}\\hat{b}_i}\\)。使用这种变换，被积函数的行为近似于 \\(\\mathcal{N}(0,2^{-1}\\text{})\\) 分布的密度，并且由于 Gaussian-Hermite 权重函数与该密度成正比，因此我们实现了最佳近似。因此，与标准 Gaussian-Hermite 规则相比，自适应 Gaussian-Hermite 规则通常需要少得多的求积来获得相同大小的近似误差。然而，在每次迭代中，对每个受试者的众数 \\(b_i\\) 的位置和二阶导数矩阵 \\(\\widehat{H}_{}\\) 的计算的要求大大增加了计算负担。然而幸运的是，通过利用随机效应 \\(p(b_i|T_i,\\delta_i,y_i;\\theta)\\) 后验分布的性质，可以大大减少自适应 Gaussian-Hermite 规则背后的计算负担，而我们需要确定的就是该后验分布的众数 \\(b_i\\) 及其二阶导数矩阵 \\(\\widehat{H}_{}\\) (Rizopoulos, 2012a). 更具体地说，如果我们把这个密度写在对数尺度上，那么\\[\\begin{aligned}&\\log p(b_i\\mid T_i,\\delta_i,y_i;\\theta)\\\\&\\propto\\sum_{j=1}^{n_i}\\log p\\{y_i(t_{ij})\\mid b_i;\\theta_y\\}+\\log p(b_i;\\theta_b)+\\log p(T_i,\\delta_i\\mid b_i;\\theta_t,\\beta)\\end{aligned}\\]因此，我们观察到，随着 \\(n_i\\) 的增加，对数后验密度中的首项是线性混合模型密度的对数，即 \\(\\log p(y_i\\mid b_i;\\theta_y)=\\sum_j\\log p\\{y_i(t_{ij})\\mid b_i;\\theta_y\\}\\)，它对于 \\(b_i\\) 是二次的，类似于多元正态分布的形状。特别地，使用贝叶斯中心极限定理的变体 (Cox Hinkley, 1974, pp. 399-400). 并且在一般的正则性条件下，当 \\(n_i\\rightarrow \\infty\\)，我们得到\\[\\begin{align}\np(b_i\\mid T_i,\\delta_i,y_i;\\theta)\\stackrel{P}{\\}\\mathcal{N}(\\tilde{b}_i,\\widetilde{H}_i^{-1})\n\\tag{4.14}\n\\end{align}\\]其中 \\(\\tilde{b}_i\\) 表示 \\(\\log p(y_i\\mid b;\\theta_y)\\) 关于 \\(b\\) 的众数，并且 \\(\\widetilde{H}_i=-\\partial^2\\log p(y_i\\mid b;\\theta_y)/\\partial b\\partial b^\\top\\Big|_{b=\\tilde{b}_i}\\)。在实践中，这表明，随着 \\(n_i\\) 的增加，只利用来自纵向结果的混合效应模型的信息，就足以对每个受试者的被积函数进行重新中心化和重新缩放。因此，我们不必采用自适应 Gaussian-Hermite 规则 (4.13) 中的标准变换方法，而是首先拟合线性混合效应模型，从中提取经验贝叶斯估计 \\(\\tilde{b}_i=\\arg\\max_b\\{\\log p(y_i,b;\\tilde{\\theta}_y)\\}\\) 及其协方差阵 \\(\\widetilde{H}_i^{-1}\\)，其中 \\(\\widetilde{H}_i=-\\partial^2\\log p(y_i,b;\\tilde{\\theta}_y)/\\partial b\\partial b^\\top\\Big|_{b=\\tilde{b}_i}\\)，然后利用变换\\[\\begin{align}\n&E\\{(\\theta,b_i)\\mid T_i,\\delta_i,y_i;\\theta\\}\\\\&\\approx\\quad2^{q/2}|\\widetilde{B}_i|^{-1}\\sum_{t_1\\cdots t_q}\\pi_tA(\\theta,\\tilde{r}_t)p(\\tilde{r}_t\\mid T_i,\\delta_i,y_i;\\theta)\\exp(\\|b_t\\|^2)\n\\tag{4.15}\n\\end{align}\\]其中 \\(\\tilde{r}_t=\\tilde{b}_i+\\sqrt2\\widetilde{B}^{-1}b_t\\)，\\(\\tilde{B}_{}\\) 表示 \\(\\widetilde{H}_{}\\) 的 Choleski 因子，\\(\\tilde{\\theta}_{y}\\) 是线性混合模型拟合的最大似然估计。该过程与自适应 Gaussian-Hermite 规则非常相似，但我们只在优化开始时实现一次，并且之后我们不再进一步更新求积点。计算优势是双重的：首先，我们可以使用比标准 Gaussian-Hermite 规则更少的求积点；其次，我们可以避免在自适应 Gaussian-Hermite 规则的每次迭代中重新定位求积点，从而节省计算资源。为了说明伪自适应规则与标准 Gaussian-Hermite 规则相比的有效性，我们重新拟合了适用于艾滋病数据集（4.2 节）的联合模型，并选择了不同的求积点数量进行比较，比较了参数估计及其标准误。结果如表 4.1 和表 4.2 所示。我们观察到，标准 Gaussian-Hermite 规则需要大约 13 到 15 个求积点才能提供更稳定的参数估计。相反，即使使用三个点的伪自适应规则的结果也非常接近使用 15 个点的结果。表 4.1 的最后一行包含在不同 Gaussian 求积设置下拟合联合模型所需的时间（以秒为单位），从中我们可以清楚地观察到，使用三个点的伪自适应规则比其他选项快得多。额外的数值研究 (Rizopoulos, 2012a) 表明，伪自适应规则在实践中对纵向和事件时间子模型的参数均表现出色，而且，其性能似乎并未因平均 \\(n_i\\) 很小的事实而受到影响。然而，由于所有类型的混合模型都需要数值积分，因此建议（特别是在困难的数据集中）检查 Gaussian-Hermite 求积点数量增加时最大似然估计的稳定性。","code":""},{"path":"chap4.html","id":"sec4-3-6","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.3.6 JM 中的数值积分控制","text":"函数 jointModel() 提供了三个控制参数，允许对数值积分算法进行精细控制。具体来说，对于生存函数 (4.2) 定义中的积分，参数 GKk 控制 Gauss-Kronrod 求积点的数量，而对于关于随机效应的积分，参数 method 和 GHk 控制数值积分的类型和 Gaussian-Hermite 求积点的数量。对于后一种情况，正如我们在 4.2 节中已经看到的，参数 method 中提供的字符串的前两部分指定了基线风险函数和生存模型的类型。然而，最后一部分指定了数值积分的类型，其中 GH 代表标准 Gaussian-Hermite 规则，aGH 代表伪自适应规则。例如，4.2 节中拟合的联合模型基于具有默认求积点数量（5 个）的伪自适应规则。要重新拟合具有 15 个点的相同模型，我们应该使用以下语法而要使用标准 Gauss-Hermite 规则和 21 个求积点的随机效应以及 15 点 Gauss-Kronrod 规则拟合联合模型，我们可以使用","code":"> jointFit.aids <- jointModel(lmeFit.aids, coxFit.aids,\n                              timeVar = \"obstime\", method = \"piecewise-PH-aGH\", GHk = 15)> jointModel(..., method = \"piecewise-PH-GH\", GHk = 21, GKk = 15)"},{"path":"chap4.html","id":"sec4-3-7","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.3.7 收敛问题","text":"我们在前两节中已经看到，拟合纵向数据和生存数据的联合模型需要双重数值积分和优化的结合。与每个结果进行单独分析相比，这些要求使得联合模型在计算和数值上的要求更高。这意味着在某些情况下我们可能会遇到收敛问题。函数 jointModel() 尝试对默认控制参数（例如，求积点数、迭代次数、收敛容差等）做出合理选择，但不能保证这些选择适用于所有数据集。因此，联合建模者还应该对如何通过适当更改控制参数的默认值来微调优化过程形成一般直觉，以便成功地对“困难”数据集拟合感兴趣的联合模型。为了提供这方面的帮助，jointModel() 具有控制参数 verbose，如果将其设置为 TRUE，则会在屏幕上打印达到最大值的优化路径。该参数可用于尽早发现算法可能存在的分歧，从而停止算法并使用不同的默认值重新启动。在大多数情况下，最有用的更改是更改起始值（使用 jointModel() 的参数 init）、增加 EM 迭代次数以及为分段常数或基于样条曲线的基线风险函数选择其他位置的结。作为 verbose 参数的一个例子，我们将一个复杂的联合模型拟合到主动脉瓣数据。特别是，从图 4.2 中可以看出，该数据集中的一些患者的主动脉梯度值表现出非线性演变。遵循 4.1.2 节的建议，为了捕获特定于非线性的受试者演变，我们假定了一个灵活的线性混合效应模型，将时间效应扩展为 B 样条基矩阵。该模型指定如下\\[\\begin{aligned}\ny_i(t) =&\\quad m_i(t)+\\varepsilon_i(t)  \\\\\n=&\\quad(\\beta_0+b_{i0})+(\\beta_1+b_{i1})B_n(t,\\lambda_1)+(\\beta_2+b_{i2})B_n(t,\\lambda_2)\\\\\\\n&+(\\beta_3+b_{i3})B_n(t,\\lambda_3)+\\beta_4\\{B_n(t,\\lambda_1)\\times\\mathtt{TypeOpRR}_i\\} \\\\\n&+\\beta_5\\{B_n(t,\\lambda_2)\\times\\mathtt{TypeOpRR}_i\\}+\\beta_6\\{B_n(t,\\lambda_3)\\times\\mathtt{TypeOpRR}_i\\} \\\\\n&+\\beta_7\\mathtt{Age}_i+\\beta_8\\mathtt{TypeOpRR}_i+\\varepsilon_i(t),\n\\end{aligned}\\]其中 \\(\\{B_n(t,\\lambda_k);k=1,2,3\\}\\) 表示时间的自然立方样条曲线的 B 样条基矩阵，两个内部结位于随访时间的 33.3% 和 66.7% 的百分位数，\\(\\mathtt{TypeOpRR}\\) 表示根置换手术类型的虚拟变量，我们还控制了基线时患者的年龄。为了在 R 中拟合该模型，我们使用包 splines 的函数 ns()，该函数生成自然立方样条函数的基矩阵。相应的语法为10调用 lme() 时 `random`` 参数中的公式指定了随机效应 \\(b_i^\\top=(b_{i0},\\ldots,b_{i3})\\) 的对角协方差阵。对于生存部分，我们拟合一个简单的 Cox 模型，其中我们仅包含操作类型作为协变量，即\\[h_i(t\\mid\\mathcal{M}_i(t),w_i)=h_0(t)\\exp\\{\\gamma\\mathtt{TypeOpRR}_i+\\alpha m_i(t)\\}\\]我们用 R 来拟合它基于拟合的线性混合模型和 Cox 模型，我们拟合相应的联合模型，并将 verbose 参数设置为 TRUE打印的输出是不言自明的。迭代 1 对应于从两个单独拟合的子模型中获得的初始值，并且似乎为联合模型的对数似然产生了一个相当合理的值。然而，通过迭代 4，我们观察到该算法出现了偏差，产生了零的对数似然值，以及纵向子模型的参数的巨大值。在大多数情况下，早期出现的分歧归因于数值积分规则的失败或参数缩放问题。对于这个例子，事实证明是后者。特别是，对于优化算法来说，优化问题（即找到最大值）的良好缩放通常很重要，这意味着任何参数的一个单位变化都会导致对数似然值发生相似量级的变化。然而，从纵向子模型的输出中，我们观察到与其他参数相比，年龄的系数要小几个数量级：这表明，如果我们想在优化过程中避免对数似然的“超调” (overshooting)，我们应该缩放 Age 的系数，使其比其他参数的系数以更小的步长变化。在 jointModel() 中，这可以通过设置 parscale 控制参数来实现，这实际上是 optim() 的控制参数。它控制优化中所有参数的缩放值的向量，这意味着我们应该为联合模型的所有参数指定缩放向量，此问题更简单的解决方案是重新拟合线性混合模型，但年龄由其样本标准差缩放：我们观察到，经过此转换后，联合模型顺利收敛并且没有任何问题，产生合理的参数估计。","code":"> lmeFit.av <- lme(sqrt(AoGradient) ~ ns(time, 3) * TypeOp + Age,\n                   data = AoValv, random = list(id = pdDiag(form = ~ ns(time, 3))))> coxFit.av <- coxph(Surv(Time, death) ~ TypeOp, data = AoValv.id,\n                     x = TRUE)> jointFit.av <- jointModel(lmeFit.av, coxFit.av, timeVar = \"time\",\n                            method = \"piecewise-PH-aGH\", verbose = TRUE)iter: 1\nlog-likelihood: -2107.672\nbetas: 4.275 1.4198 2.4489 2.4651 -0.4827\n      -0.0201 -0.1128 -0.5105 -1.1762\nsigma: 0.6148\ngammas: -0.0336\nalpha: -0.3875\nxi: 0.2721 0.3413 0.431 0.3953 0.9664 0.838 0\nD: 0.453 4.4725 1.973 1.2492\n    .\n    .\n    .\niter: 4\nlog-likelihood: 0\nbetas: 1377.697 427.4287 -3691.91 -2033.504\n      -1791.215 1.443 -1806.379 5975.356 5294.583\nsigma: 8.516\ngammas: 0.1557\nalpha: -0.6494\nxi: 0.1113 0.143 0.2657 0.3479 0.9492 0.7238 0\nD: 0.7401 7.0717 2.7674 2.039> summary(lmeFit.av)\n\n. . .                     Value Std.Error  DF   t-value p-value\n(Intercept)            4.274976 0.2444552 980 17.487764  0.0000\nns(time, 3)1           1.419787 0.3136259 980  4.527007  0.0000\nns(time, 3)2           2.448946 0.3903572 980  6.273602  0.0000\nns(time, 3)3           2.465096 0.2942019 980  8.378925  0.0000\nTypeOpRR              -0.482702 0.1881059 286 -2.566121  0.0108\nAge                   -0.020102 0.0038463 286 -5.226250  0.0000\nns(time, 3)1:TypeOpRR -0.112810 0.4052867 980 -0.278345  0.7808\nns(time, 3)2:TypeOpRR -0.510547 0.5304223 980 -0.962529  0.3360\nns(time, 3)3:TypeOpRR -1.176218 0.6369125 980 -1.846749  0.0651\n. . .> lmeFit2.av <- lme(sqrt(AoGradient) ~ ns(time, 3) * TypeOp + I(Age/15),\n                    data = AoValv, random = list(id = pdDiag(form = ~ ns(time, 3))))\n> jointFit2.av <- jointModel(lmeFit2.av, coxFit.av, timeVar = \"time\",\n                             method = \"piecewise-PH-aGH\", verbose = TRUE)\n> summary(jointFit2.av)\n\n. . .\n\nVariance Components:\n             StdDev\n(Intercept)  0.6584\nns(time, 3)1 2.1192\nns(time, 3)2 1.3661\nns(time, 3)3 0.3175\nResidual     0.6289\n\nCoefficients:\nLongitudinal Process\n                        Value Std.Err z-value p-value\n(Intercept)            4.3392  0.2422 17.9142 <0.0001\nns(time, 3)1           1.4735  0.3112  4.7342 <0.0001\nns(time, 3)2           2.2797  0.3831  5.9507 <0.0001\nns(time, 3)3           2.2362  0.2277  9.8193 <0.0001\nTypeOpRR              -0.4845  0.1886 -2.5683  0.0102\nI(Age/15)             -0.3174  0.0566 -5.6086 <0.0001\nns(time, 3)1:TypeOpRR -0.0965  0.4015 -0.2405  0.8100\nns(time, 3)2:TypeOpRR -0.5994  0.5066 -1.1831  0.2368\nns(time, 3)3:TypeOpRR -1.3934  0.5537 -2.5164  0.0119\n\nEvent Process\n             Value  Std.Err z-value p-value\nTypeOpRR    0.0964   0.3041  0.3170  0.7512\nAssoct     -0.3580   0.1521 -2.3533  0.0186\nlog(xi.1)  -3.1443   0.6225 -5.0509\nlog(xi.2)  -2.7835   0.7187 -3.8731\nlog(xi.3)  -2.5458   0.7633 -3.3352\nlog(xi.4)  -2.6127   0.8070 -3.2373\nlog(xi.5)  -1.7131   0.7661 -2.2361\nlog(xi.6)  -1.8092   0.8593 -2.1054\nlog(xi.7) -14.8215 516.6937 -0.0287\n. . ."},{"path":"chap4.html","id":"sec4-4","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.4 联合模型的渐近推断","text":"","code":""},{"path":"chap4.html","id":"sec4-4-1","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.4.1 假设检验","text":"在最大似然框架下拟合联合模型后，可以直接使用标准的渐近似然推断检验。一般来说，如果我们有兴趣检验零假设\\[\\begin{align}\nH_0:\\theta=\\theta_0\\quad\\text{ versus }\\quad H_a:\\theta\\neq\\theta_0\n\\tag{4.16}\n\\end{align}\\]我们可使用：似然比检验 (Likelihood Ratio Test)，其检验统计量定义为\n\\[LRT=-2\\{\\ell(\\hat{\\theta}_0)-\\ell(\\hat{\\theta})\\}\\]\n其中 \\(\\hat{\\theta}_0\\) 和 \\(\\hat{\\theta}\\) 分别表示原假设和备择假设下的最大似然估计。似然比检验 (Likelihood Ratio Test)，其检验统计量定义为\n\\[LRT=-2\\{\\ell(\\hat{\\theta}_0)-\\ell(\\hat{\\theta})\\}\\]\n其中 \\(\\hat{\\theta}_0\\) 和 \\(\\hat{\\theta}\\) 分别表示原假设和备择假设下的最大似然估计。得分检验 (Score Test)，其检验统计量定义为\n\\[U=S^\\top(\\hat{\\theta}_0)\\left\\{\\mathcal{}(\\hat{\\theta}_0)\\right\\}^{-1}S(\\hat{\\theta}_0)\\]\n其中 \\(S(\\cdot)\\) 和 \\(\\mathcal (\\cdot)\\) 表示备择假设下模型的得分函数和观测信息矩阵。得分检验 (Score Test)，其检验统计量定义为\n\\[U=S^\\top(\\hat{\\theta}_0)\\left\\{\\mathcal{}(\\hat{\\theta}_0)\\right\\}^{-1}S(\\hat{\\theta}_0)\\]\n其中 \\(S(\\cdot)\\) 和 \\(\\mathcal (\\cdot)\\) 表示备择假设下模型的得分函数和观测信息矩阵。Wald 检验 (Wald Test)，其检验统计量定义为\n\\[W=(\\hat{\\theta}-\\theta_0)^\\top\\mathcal{}(\\hat{\\theta})(\\hat{\\theta}-\\theta_0)\\]Wald 检验 (Wald Test)，其检验统计量定义为\n\\[W=(\\hat{\\theta}-\\theta_0)^\\top\\mathcal{}(\\hat{\\theta})(\\hat{\\theta}-\\theta_0)\\]在零假设下，每个检验的渐近分布都是自由度为 \\(p\\) 的卡方分布，其中 \\(p\\) 表示被检验的参数数量。对于单个参数 \\(\\theta_j\\)，Wald 检验等价于 \\((\\hat{\\theta}_j-\\theta_{0j})/\\widehat{s.e.}(\\hat{\\theta}_j)\\)，在零假设下服从渐近标准正态分布。这些检验统计量近似为彼此的低阶泰勒级数展开，且渐近等价。然而在实践中，当我们处理有限样本时，它们通常是不同的。在这种情况下，似然比检验通常认为是最可靠的，Wald 检验则是最不可靠的。得分和 Wald 检验仅需要分别在原假设和备择假设下拟合模型，而似然比检验需要在两个假设下拟合联合模型，因此计算成本较高。如果我们有兴趣检验的变量中存在缺失数据，则得分检验将更加有效，因为它只需要在零假设下拟合模型，因此可以避免逐例删除缺失值（即排除在感兴趣的变量中有缺失值的受试者）。在 4.2 节中介绍的艾滋病联合建模分析中，summary() 函数的输出还包含单变量 Wald 检验，用于检验纵向子模型中的每个固定效应 \\(\\beta\\) 以及生存子模型中回归系数 \\(\\gamma\\) 和关联参数 \\(\\alpha\\) 是否在统计上不为零。如果对一般假设感兴趣，那么可以使用上面定义的多元 Wald 检验。例如，对于拟合到艾滋病数据集的联合模型，我们想检验纵向过程中的总体时间效应是否不等于零。这与以下一组假设相对应\\[\\begin{aligned}H_0&:\\beta_1=\\beta_2=0\\\\H_a&:\\beta_1\\neq0\\quad\\mathrm{}\\quad\\beta_2\\neq0\\end{aligned}\\]其中 \\(\\beta_1\\) 是时间效应系数，\\(\\beta_2\\) 是时间和治疗之间的交互效应系数。联合模型的 Wald 检验是使用函数 anova() 进行的。在对该函数的调用中，我们指定只需要对纵向子模型的参数进行 Wald 检验输出表中的每一行都对应于涉及该特定项的所有参数的 Wald 检验。因此，包含时间变量的结果的第一行对应于检验是否所有涉及时间的项都与零显著不同，这反过来对应于上面给出的一组假设。结果表明，总体时间效应相当强。为了检验更一般的假设集，我们可以将 (4.16) 重写为\\[\\begin{aligned}H_0:L\\theta=0\\quad\\text{ versus }\\quad H_a:L\\theta\\neq0\\end{aligned}\\]其中 \\(L\\) 指定我们要检验的系数的线性组合。例如，为了检验生存子模型中的协变量是否有助于解释晚期艾滋病患者死亡风险的变异性，即检验全局零假设\\[\\begin{aligned}H_0&:\\gamma=\\alpha=0\\\\H_a&:\\gamma\\neq0\\quad\\mathrm{}\\quad\\alpha\\neq0\\end{aligned}\\]我们指定我们只对生存子模型的参数感兴趣，并且 \\(L\\) 是适当维度的单位矩阵：用于检验经典线性混合模型中固定效应的 Wald 检验的一个问题是，它基于的标准误差低估了 \\(\\hat\\beta\\) 的真实变异性，因为它们没有考虑到估计方差分量（即随机效应的协方差阵）所引入的变异性 (Dempster et al., 1981). 因此，通常使用具有适当自由度的近似 \\(F\\) 分布，而不是 Wald 检验所假设的标准卡方分布。在联合模型中，这个问题可能会变得更为严重，因为我们不仅忽略了估计方差分量的事实，还需要估计生存过程。从渐近的角度来看，我们期望 Wald 统计量会服从假设的卡方分布，但在有限样本中，联合建模文献中还没有太多工作来调查其性质。因此，尽管似然比检验在计算上更为昂贵，但通常还是建议使用似然比检验。似然比检验也由函数 anova() 通过提供两个拟合的联合模型作为参数来实现，第一个模型始终是零假设下的模型。作为一个例子，我们检验死亡风险的治疗效应。summary() 函数输出中包含的 Wald 检验表明，两种治疗之间存在不可忽略的差异（\\(W=0.3,\\text{d.f.}=1,p=0.0324\\)）。如上所述，为了实现似然比检验，我们首先需要在零假设下拟合联合模型，即在生存子模型中没有治疗的联合模型（我们还包括线性混合模型以确保完整性）：我们得出了与 Wald 检验相同的结论。与 Wald 和似然比检验相反，得分检验的实现需要一些额外的步骤。这主要是由于得分检验统计量的计算需要在备择假设下计算联合模型的得分向量和 Hessian 矩阵，但是参数取零假设下的相应值。作为如何在 R 中执行此检验的说明，对于艾滋病数据集中的晚期艾滋病毒感染者，我们检验了 CD4 细胞计数的平方根与死亡风险之间无关联的零假设，即\\[H_{0}:\\alpha=0\\quad\\mathrm{versus}\\quad H_{}:\\alpha\\neq0\\]为了执行此检验，我们利用 jointModel() 参数提供的灵活性，并使用此函数来计算得分检验统计量所需的组件。作为第一步，我们需要提取零假设下纵向和生存子模型的最大似然估计。对于前者，可以从作为 joinModel() 第一个参数提供的拟合线性混合效应模型中轻松获得这些模型。更具体地说，我们使用函数 fixef() 提取的固定效应系数 \\(\\beta\\) 的估计，并使用函数 getVarCov() 提取随机效应协方差阵 \\(D\\) 的估计。残差标准误估计为返回的 lme 对象的 sigma 组件。在从对象 lmeFit.aids 中提取这些估计之前，我们应该注意，默认情况下，函数 lme() 计算混合模型参数的 REML 估计（有关限制性最大似然估计的更多信息，请参见 2.2.1 节）。因此，在提取估计参数之前，我们应首先使用最大似然重新拟合；在 R 中，使用以下语法生成更新后的模型拟合结果：对于生存子模型，我们不能重复相同的过程来提取零假设下的参数估计，因为生存子模型 coxFit.aids 是具有未指定基线风险函数的 Cox 模型，而在拟合艾滋病数据集的联合模型中，我们假定了分段常数基线风险函数。为了获得分段常数模型下的系数，我们使用函数 piecewiseExp.ph()。该函数接受一个已拟合的 Cox 模型，并使用泊松回归等价性 (Hougaard, 2000, Secion 2.2.4) 拟合相应的相对风险模型，该模型具有分段常数基线风险。其确定内部结的算法与 jointModel() 中使用的算法完全相同。该函数的输出是一个 glm 对象，其中系数向量的第一部分对应于 Cox 模型中输入的协变量，其余部分对应基线风险函数 (4.3) 参数 \\(\\xi_q,q=1,\\ldots,Q\\) 的对数。为了执行得分检验，我们将所有参数估计收集到一个命名的列表中，并以这些估计作为初始值调用 jointModel() 函数。参数 init 接受一个命名的列表，其中包含联合模型参数的初始值，而控制参数仅用于设置一些控制选项。EM = TRUE指定我们只想使用 EM 算法（即，如果未收敛，则不进行 quasi-Newton\n算法），而控制参数中的 iter.EM 设置 EM 迭代的次数；这里我们将其设置为零，这对应于仅对初始值执行所有剩余的计算（即，计算 Hessian 矩阵和得分向量），而不进行对数似然值的最大化。然后，我们从返回的联合模型拟合中提取得分向量，使用函数 vcov() 获取 Hessian 矩阵，并计算得分检验统计量和相应的 \\(p\\) 值：与 4.2节 summary() 方法提供的 Wald 检验结果类似，得分检验也表明 CD4 细胞计数与死亡风险之间存在强烈关联。到目前为止，我们看到的三个标准检验只适用于两个嵌套模型的比较，因为零假设下的模型是替代假设下模型的特例。当兴关注点在于比较非嵌套模型时，通常使用信息准则。这些准则背后的主要思想是根据两个模型的最大对数似然值对其进行比较，但对使用过多参数进行惩罚。两个最常用的信息准则是 Akaike’s Information Criterion (AIC; Akaike, 1974) 和 Bayesian Information Criterion (BIC; Schwarz, 1978). 它们包含在 anova() 和 summary() 函数的输出中，定义为\\[\\begin{array}{rcl}AIC&=&-2\\ell(\\hat\\theta)+2n_{par}\\\\BIC&=&-2\\ell(\\hat\\theta)+n_{par}\\log(n)\\end{array}\\]其中 \\(n_{par}\\) 表示模型中参数的数量。根据这些定义，值“越小越好”。也就是说，如果我们使用 AIC 或 BIC 来比较相同数据的两个模型，我们优选相同准则值较低的模型。在这两个准则之间的选择可能是一个问题，因为它们在实践中并不总是一致的。AIC 倾向于选择比 BIC 更精细的模型，因为后者对模型的复杂性的惩罚要大得多。请注意，这也是上述艾滋病数据集中生存过程中治疗效应检验的情况。具体来说，AIC 和似然比检验都表明，两种治疗之间的死亡风险存在微小但显著的差异，而 BIC 选择了生存子模型中没有治疗效应的更简约的联合模型。因此，这些准则应视为区分两个（非嵌套）统计模型的经验法则。当我们有兴趣检验联合模型中是否应包括额外的随机效应时，就会出现另一个重要问题。这实际上相当于增加随机效应设计矩阵 \\(D\\) 的维度，增加方差分量。在这种情况下，通过在完整模型中设置 \\(D\\) 的某些元素为零，可以获得零假设下的模型。这些元素中至少有一个始终是 \\(D\\) 的对角元（即方差参数），这意味着在零假设下，某些参数被设置为参数空间边界上的值。在这种设置下的问题是，经典的最大似然渐近论证并不适用于边界情况。特别是，Stram Lee (1994) 根据 Self Liang (1987) 的结果，以及后来 Verbeke Molenberghs (2003) 以及 Molenbergh Verbeke (2007) 在线性混合模型框架中对这一主题的一些工作表明，我们在上面看到的所有三个检验统计量都不服从零假设下声称的 \\(\\chi^2_p\\) 分布。作为替代方案，有人建议使用具有适当选择的自由度的卡方分布的混合。然而，Greven et al. (2008) 已经证明，即使这种选择在某些情况下也可能相当保守，并且他们提出了一种基于模拟的方法来近似零假设下似然比检验统计量的分布。在联合建模框架内，关于该问题的研究并不多。作为实际指导，我们建议采用较高的第 类错误率，例如 10% 至 15%，以确保我们不会过度简化假定的联合模型的随机效应结构。","code":"> anova(jointFit.aids, process = \"Longitudinal\")\nMarginal Wald Tests Table\n\nLongitudinal Process\n              Chisq df Pr(>|Chi|)\nobstime    126.3887  2     <1e-04\ndrug         0.1470  1     0.7014\nobstime:drug 0.1470  1     0.7014> anova(jointFit.aids, process = \"Event\", L = diag(2))\nMarginal Wald Tests Table\n\nUser-defined Contrasts Matrix\n    Chisq df Pr(>|Chi|)\nL 67.3251  2    < 1e-04> lmeFit.aids <- lme(CD4 ~ obstime + obstime:drug,\n                     random = ~ obstime | patient, data = aids)\n> coxFit2.aids <- coxph(Surv(Time, death) ~ 1, data = aids.id, x = TRUE)\n> jointFit2.aids <- jointModel(lmeFit.aids, coxFit2.aids,\n                               timeVar = \"obstime\", method = \"piecewise-PH-aGH\")\n> anova(jointFit2.aids, jointFit.aids)\n\n                   AIC     BIC  log.Lik  LRT df p.value\njointFit2.aids 8691.10 8753.30 -4330.55\njointFit.aids  8688.52 8754.86 -4328.26 4.58  1  0.0323> lmeFitML.aids <- update(lmeFit.aids, method = \"ML\")> pwc <- piecewiseExp.ph(coxFit.aids)\n> coef(pwc)\n        X        xi1        xi2        xi3        xi4        xi5\n0.2059221 -3.8393612 -3.4105302 -3.0497646 -3.5896874 -3.4312411\n       xi6        xi7\n-3.3413437 -3.1331363> init <- list(\n  betas = fixef(lmeFitML.aids),\n               sigma = lmeFitML.aids$sigma,\n               D = getVarCov(lmeFitML.aids),\n               gammas = coef(pwc)[1],\n               alpha = 0,\n               xi = exp(coef(pwc)[-1]) # piecewiseExp.ph() returns log(xi)\n)\n> JMScoreTest <- jointModel(lmeFitML.aids, coxFit.aids,\n                            timeVar = \"obstime\", method = \"piecewise-PH-aGH\", init = init,\n                            only.EM = TRUE, iter.EM = 0)> score.vector <- JMScoreTest$Score\n> inv.Hessian <- vcov(JMScoreTest)\n> ScoreStat <- c(t(score.vector) %*% inv.Hessian %*% score.vector)\n> c(\"Statistic\" = ScoreStat, \"df\" = 1,\n    \"p-value\" = pchisq(ScoreStat, df = 1, lower.tail = FALSE))\n\n   Statistic           df      p-value\n8.845084e+01 1.000000e+00 5.211407e-21"},{"path":"chap4.html","id":"sec4-4-2","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.4.2 置信区间","text":"感兴趣参数的渐近 95% 置信区间可以基于 Wald 统计，即 \\(\\hat{\\theta}\\pm1.96\\widehat{s.e.}(\\hat{\\theta})\\)。在 R 中，这些是由 confint() 函数生成的。例如，在 4.3.7 节中，拟合到主动脉瓣数据集的联合模型中，纵向过程中参数的 95% 置信区间通过如下代码获得而对于生存过程，风险比的 95% 置信区间通过如下代码获得类似地，拟合值的渐近置信区间可以基于最大似然估计的渐近正态分布。例如，对于纵向过程中的平均纵向演变 \\(\\mu = X\\beta\\)，我们可以构建以下形式的 95% 逐点置信区间\\[\\begin{aligned}\\hat{\\mu}\\quad&\\pm\\quad1.96\\widehat{s.e.}(\\hat{\\mu})\\Rightarrow\\\\X\\hat{\\beta}\\quad&\\pm\\quad1.96\\big[\\operatorname{diag}\\{X\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\beta})X^\\top\\}\\big]^{1/2}\\end{aligned}\\]其中 \\(X\\) 表示感兴趣的设计矩阵，并且 \\(\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\beta})\\) 是对应于 \\(\\hat\\beta\\) 的观测 Hessian 矩阵的块。为了计算拟合值 \\(\\hat{\\mu}=X\\hat{\\beta}\\)、它们的标准误和 R 中相应的 95% 逐点置信区间，我们使用 predict() 函数。作为初始步骤，在调用此函数之前，我们需要构建包含感兴趣的协变值的数据框，基于该数据框导出设计矩阵 \\(X\\)。作为说明，我们基于拟合到主动脉瓣数据集的联合模型，为一位年龄中位数（即 47.3 岁）的患者，展示了两种手术类型的拟合平均纵向演变情况，以及相应的 95% 逐点置信区间。以下 R 代码为每个手术类型构建了一个数据框，该数据框包含从最小到最大观测随访时间的 30 个时间点的规则序列，并将年龄设置为当前样本中的中位数年龄。接下来，我们将拟合的联合模型 jointFit2.av 和上面的数据框作为主参数提供给 predict() 函数。此外，我们指定要计算 \\(\\mu\\) 的置信区间（即参数 interval），并将结果返回在输入的数据框中（即参数 return）对象 Ps 实际上是输入的数据框 DF，但增加了四个额外的列，其中包含拟合值 \\(\\hat \\mi\\)、它们的标准误和渐近 95% 逐点置信区间的限。使用 lattice 包 (Sarkar, 2008) 中的函数 xyplot() 生成所得估计的图形，如图 4.3 所示。","code":"> confint(jointFit2.av, parm = \"Longitudinal\")\n\n                           2.5 %        est.     97.5 %\n(Intercept)            3.8644755  4.33922289  4.8139703\nns(time, 3)1           0.8634598  1.47347658  2.0834934\nns(time, 3)2           1.5288204  2.27966532  3.0305103\nns(time, 3)3           1.7898180  2.23616498  2.6825120\nTypeOpRR              -0.8542210 -0.48448673 -0.1147525\nI(Age/15)             -0.4283111 -0.31739557 -0.2064800\nns(time, 3)1:TypeOpRR -0.8834019 -0.09654611  0.6903097\nns(time, 3)2:TypeOpRR -1.5924389 -0.59943345  0.3935720\nns(time, 3)3:TypeOpRR -2.4787575 -1.39343219 -0.3081069> exp(confint(jointFit2.av, parm = \"Event\"))\n\n             2.5 %      est.    97.5 %\nTypeOpRR 0.6067633 1.1012094 1.9985752\nAssoct   0.5188071 0.6990497 0.9419118> DF <- with(AoValv, expand.grid(\n  time = seq(min(time), max(time), length = 30),\n  TypeOp = levels(TypeOp),\n  Age = median(AoValv.id$Age)))> Ps <- predict(jointFit2.av, newdata = DF, interval = \"confidence\",\n                return = TRUE)\n> xyplot(pred + low + upp ~ time | TypeOp, data = Ps,\n         type = \"l\", col = 1, lty = c(1,2,2), lwd = 2,\n         ylab = expression(sqrt(\"Aortic Gradient\")), xlab = \"Time (years)\")"},{"path":"chap4.html","id":"sec4-4-3","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.4.3 设计考虑","text":"当分别考虑纵向和生存结果时，已有文献中有几个关于设计考虑的建议。对于线性混合模型，我们参考 Verbeke Molenberghs (2000, Chapter 23) 以及 Fitzmaurice et al. (2004, Chapter 15)，而对于生存模型，我们则参考了 Therneau Grambsch (2000, Section 3.6). 不幸的是，在联合建模框架中，关于功效和样本量计算以及一般设计的考虑的工作还不多。由于联合模型是相当复杂的模型，很难轻易推导出功效公式，除非做出限制性假设。在这方面，唯一可行的解决方案是采用基于模拟的方法，在这种方法下，从具有所需效应大小的联合模型中模拟数据。在设计使用联合模型的研究时，通常会忽略的另一个重要问题是随访时间的选择。具体来说，习惯上要求所有患者在一组预先指定的时间点 \\(t_1,\\ldots,t_q\\) 回到研究中心。假设所有患者按要求执行，很明显，我们只记录了这些特定时间点的纵向标志物信息，而没有记录这些时间点之间的信息。然而，我们已经看到，生存函数是联合模型的似然的一部分，它需要估计每个受试者的真实标志物水平的完整路径 \\(\\mathcal{M}_i(t)=\\{m_i(s),0\\leq s<t\\}\\)。因此，由于我们只有 \\(t_1,\\ldots,t_q\\) 时的信息，我们必须在没有记录信息的这些时间点之间进行插值来估计 \\(\\mathcal{M}_i(t)\\)。为了避免这种插值，在设计一项对每个受试者进行 \\(Q\\) 次计划随访测量的研究时，通常建议将随访期跨越 \\(Q^{\\prime}>Q\\) 个时间点，创建几个随机的患者组，并要求每组在不同的 \\(Q\\) 个时间点进行就诊。","code":""},{"path":"chap4.html","id":"sec4-5","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.5 随机效应的估计","text":"到目前为止，我们主要关注联合模型参数 \\(\\theta\\) 的估计和推断。而随机效应 \\(b_i\\) 用于描述患者纵向演变的异质性，并建立纵向和事件时间过程之间的关联。尽管如此，在许多情况下，人们的兴趣可能在于对两结果之一进行针对特定患者的预测。为了得出这样的预测，需要对随机效应向量 \\(b_i\\) 进行估计。由于随机效应假定为随机变量，因此很自然地使用贝叶斯范式来估计它们。具体来说，假定 \\(p(b_i;\\theta)\\) 是先验分布，\\(p(T_i,\\delta_i\\mid b_i;\\theta)p(y_i\\mid b_i;\\theta)\\) 是条件似然部分，我们可以推导出相应的后验分布\\[\\begin{align}\np(b_i\\mid T_i,\\delta_i,y_i;\\theta)&=\\quad\\frac{p(T_i,\\delta_i\\mid b_i;\\theta)p(y_i\\mid b_i;\\theta)p(b_i;\\theta)}{p(T_i,\\delta_i,y_i;\\theta)}\\\\&\\propto\\quad p(T_i,\\delta_i\\mid b_i;\\theta)p(y_i\\mid b_i;\\theta)p(b_i;\\theta)\n\\tag{4.17}\n\\end{align}\\]与线性混合模型（后验分布是多元正态分布）框架相反，在联合模型中没有闭合形式的解，必须进行数值计算。然而，正如 4.3.5 节所述，随着纵向测量次数 \\(n_i\\) 的增加，该分布将收敛为正态分布。为刻画该后验分布，通常使用标准的总结度量。对于其位置，通常使用均值或众数，分别定义为\\[\\begin{align}\n\\left\\{\\begin{array}{l}\\bar b_i=\\int b_ip(b_i\\mid T_i,\\delta_i,y_i;\\theta)db_i,\\quad\\text{以及}\\\\\\hat b_i=\\arg\\max_b\\{\\log p(b\\mid T_i,\\delta_i,y_i;\\theta)\\}\\end{array}\\right.\n\\tag{4.18}\n\\end{align}\\]作为离散的度量，我们可以使用随机效应的后验方差或逆 Hessian 矩阵，即\\[\\begin{align}\n\\left\\{\\begin{array}{l}\\operatorname{var}(b_i)=\\int(b_i-\\bar{b}_i)^2p(b_i\\mid T_i,\\delta_i,y_i;\\theta)~db_i\\\\\\\\H_i=\\left\\{-\\frac{\\partial^2\\log p(b|T_i,\\delta_i,y_i;\\theta)}{\\partial b^\\top\\partial b}|_{b=\\hat{b}_i}\\right\\}^{-1}\\end{array}\\right.\n\\tag{4.19}\n\\end{align}\\]对于 (4.18) 和 (4.19) 的估计，采用了经验贝叶斯方法，其中我们用 \\(\\hat\\theta\\) 替换 \\(\\theta\\)。在 R 中，这些经验贝叶斯估计是由函数 ranef() 产生的。计算随机效应后验分布的均值 \\(\\bar b_i\\) 或众数 \\(\\hat b_i\\) 的选择由 type 参数控制，默认值为均值。以下代码使用 4.3.7 节中拟合的联合模型比较了主动脉瓣数据集中前六名患者的两个估计。后验分布的相应离散度估计是通过使用额外的可选参数 postVar 来计算的。同样，type 参数指定计算两个估计中的哪一个。具体来说，当 type = \"mean\" 且 postVar = TRUE 时，ranef() 返回后验方差，而对于选项 type = \"mode\"，它返回逆 Hessian 矩阵。我们显示主动脉瓣数据集中的第一个患者一般来说，我们观察到两种类型的估计（即均值与众数、方差与逆 Hessian 矩阵）之间的差异会非常小。正如 4.3.5 节中所解释的，这是可以预期的，因为联合模型下随机效应的后验分布的主导项是纵向模型的密度，后验分布将很好地近似于正态分布，而对于正态分布这两种类型的估计是重合的。","code":"> head(ranef(jointFit2.av))\n\n   (Intercept) ns(time, 3)1 ns(time, 3)2 ns(time, 3)3\n1   -1.1623809   -0.8068030  -1.02519836   -0.3556301\n12  -0.1321869   -2.8733450   0.12983730   -0.1927253\n17   0.6676618    6.3404689  -0.05272436   -0.4205397\n22  -1.0028832   -0.2602472  -0.80103372   -0.4455364\n30   0.3022234    1.1862843   0.58932015   -0.1061563\n32  -0.2307416   -1.1798982  -0.20725047   -0.4421050\n\n> head(ranef(jointFit2.av, type = \"mode\"))\n\n  (Intercept) ns(time, 3)1 ns(time, 3)2 ns(time, 3)3\n1  -1.1843751   -0.7924597  -1.00020579  -0.31466724\n12 -0.1233876   -2.9351389   0.19557269  -0.01697451\n17  0.7093392    6.1951976   0.11981311   0.12332890\n22 -1.0470046   -0.2106992  -0.74552794  -0.31381140\n30  0.3084187    1.1835448   0.60205282  -0.01085677\n32 -0.2491193   -1.3722186  -0.05329907  -0.07602029> attr(ranef(jointFit2.av, postVar = TRUE),\n       \"postVar\")[[1]]\n\n              (Intercept) ns(time, 3)1 ns(time, 3)2 ns(time, 3)3\n(Intercept)   0.191306871 -0.132015303 -0.322848727 -0.001335748\nns(time, 3)1 -0.132015303  0.765628082 -0.042482949  0.001492416\nns(time, 3)2 -0.322848727 -0.042482949  0.804884199  0.001927672\nns(time, 3)3 -0.001335748  0.001492416  0.001927672  0.003195026\n\n> attr(ranef(jointFit2.av, type = \"mode\", postVar = TRUE),\n       \"postVar\")[[1]]\n\n             (Intercept) ns(time, 3)1 ns(time, 3)2 ns(time, 3)3\n(Intercept)   0.20482469  -0.14697481  -0.34151558  -0.03213124\nns(time, 3)1 -0.14697481   0.78573758  -0.02209749   0.03603327\nns(time, 3)2 -0.34151558  -0.02209749   0.83216730   0.04631669\nns(time, 3)3 -0.03213124   0.03603327   0.04631669   0.07689786"},{"path":"chap4.html","id":"sec4-6","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.6 与缺失数据框架的连接","text":"到目前为止，我们主要是从生存分析的角度来阐述联合模型的动机，即作为一种处理易出错的时依协变量的建模框架。现在我们将注意力转向以纵向结果为主要研究兴趣的情形。在这种情况下，患者发生某个事件通常对应于其纵向过程的中断。这要么是因为该事件发生后无法再收集随访测量数据，要么事件发生后数据的分布发生变化从而认为是无关紧要的。因此，在这样的设定下，显然我们可以直接建立联合模型与 2.3 节中引入的缺失数据框架之间的联系。我们应该在这里提到，在一些终点事件为死亡的临床研究中，考虑事件时间之后的纵向结果值在概念上可能不合理 (Kurland Heagerty, 2005; Kurland et al., 2009). 然而，我们也应该注意到，尽管我们已经为观测纵向结果定义了一个混合模型 (4.5)，但联合模型隐含地对完全纵向响应向量进行了假设，包括在事件或删失之后收集的观测数据。为了更清楚地说明这一点，我们为每个受试者定义了纵向响应向量的观测和缺失的部分。观测部分 \\(y_i^o=\\{y_i(t_{ij}):t_{ij}<T_i^*,j=1,\\ldots,n_i\\}\\) 由事件时间之前第 \\(\\) 个受试者的所有观测纵向测量组成，而缺失部分 \\(y_i^m=\\{y_i(t_{ij}):t_{ij}\\geq T_i^*,j=1,\\ldots,n_i'\\}\\) 包含在事件没有发生的情况下直到研究结束为止进行的纵向测量。根据这些定义，我们可以导出脱落机制，它是给定纵向响应完全向量 \\((y_i^o,y_i^m)\\) 的情况下脱落时间的条件分布。具体来说，我们有\\[\\begin{align}\np(T_i^*\\mid y_i^o,y_i^m;\\theta)& =\\quad\\int p(T_i^*,b_i\\mid y_i^o,y_i^m;\\theta)db_i  \\\\\n&=\\quad\\int p(T_i^*\\mid b_i,y_i^o,y_i^m;\\theta)p(b_i\\mid y_i^o,y_i^m;\\theta)db_i \\\\\n&=\\quad\\int p(T_i^*\\mid b_i;\\theta)p(b_i\\mid y_i^o,y_i^m;\\theta)db_i\n\\tag{4.20}\n\\end{align}\\]其中最后一行中的简化是由于条件独立性假设 (4.7)。我们观察到，通过随机效应的后验分布 \\(p(b_i\\mid y_i^o,y_i^m;\\theta)\\)，脱落时间取决于 \\(y^m_i\\)，这意味着联合模型对应于 MNAR 缺失数据机制。对 (4.20) 的进一步检查表明，联合模型中脱落机制背后的关键组成部分是随机效应 \\(b_i\\)。更具体地说，正如我们已经看到的，在联合模型中\\[\\left\\{\\begin{array}{rcl}y_i(t)&=&x_i^\\top(t)\\beta+z_i^\\top(t)b_i+\\varepsilon_i(t)\\\\h_i(t)&=&h_0(t)\\exp\\bigl[\\gamma^\\top w_i+\\alpha\\{x_i^\\top(t)\\beta+z_i^\\top(t)b_i\\}\\bigr]\\end{array}\\right.\\]生存子模型和纵向子模型具有相同的随机效应。由于这一特点，联合模型属于 2.3.2 节中介绍的共享参数模型类别 (Wu Carroll, 1988; Wu Bailey, 1989; Follmann Wu, 1995; Vonesh et al., 2006). 在简单的随机效应结构（即随机截距和随机斜率）下，这种缺失数据机制意味着，纵向曲线陡增的受试者可能更多（或更少）地退出。这里的一个相关问题是关联参数 \\(\\alpha\\) 与缺失数据机制类型的联系。具体来说，\\(\\alpha\\) 的零值对应于 MCAR 缺失数据机制，因为一旦以可用的协变量为条件，脱落过程就不取决于缺失或观测纵向响应。此外，由于在 \\(\\alpha=0\\) 下，两个子模型中的参数是不同的，因此脱落和纵向过程的联合概率可分解为\\[\\begin{array}{rcl}p(T_i,\\delta_i,y_i;\\theta)&=&p(T_i,\\delta_i;\\theta_t)p(y_i;\\theta_y,\\theta_b)\\\\&=&p(T_i,\\delta_i;\\theta_t)\\int p(y_i\\mid b_i;\\theta_y)p(b_i;\\theta_b)db_i\\end{array}\\]这意味着可以分别估计两个子模型中的参数。尽管如此，由于我们采用了全似然法，因此通过最大化纵向过程的对数似然 \\(\\ell(\\theta_y)=\\sum_i\\log p(y_i;\\theta_y)\\) 得出的参数估计，在 MAR 缺失数据机制下也将有效，即在脱落仅取决于观测响应的假设下。此外，我们还应该提到，在实践中，当受试者由于删失而离开研究时，也会发生纵向过程数据收集的中断。然而，在联合模型似然函数的制定中，我们假定删失机制可能取决于观测纵向响应和协变量的历史，但独立于未来的纵向结果。因此，在此假设下，删失对应于 MAR 缺失数据机制。共享参数模型框架的另一个不错的特性是，这些模型可以非常轻松地处理间歇性缺失和流失。为了了解这是如何实现的，我们根据完全数据 \\(\\{y_i^o,y_i^m\\}\\) 写出纵向结果观测数据的对数似然函数\\[\\begin{aligned}\\ell(\\theta)&=\\quad\\sum_{=1}^n\\log\\int p(T_i,\\delta_i,y_i^o,y_i^m;\\theta)dy_i^m\\\\&=\\quad\\sum_{=1}^n\\log\\int\\int p(T_i,\\delta_i,y_i^o,y_i^m\\mid b_i;\\theta)p(b_i;\\theta)dy_i^mdb_i\\\\&=\\quad\\sum_{=1}^n\\log\\int p(T_i,\\delta_i\\mid b_i;\\theta)\\left\\{\\int p(y_i^o,y_i^m\\mid b_i;\\theta)dy_i^m\\right\\}p(b_i;\\theta)db_i\\\\&=\\quad\\sum_{=1}^n\\log\\int p(T_i,\\delta_i\\mid b_i;\\theta)p(y_i^o\\mid b_i;\\theta)p(b_i;\\theta)db_i.\\end{aligned}\\]在第一个条件独立性假设 (4.7) 下，我们得到脱落的纵向响应 \\(y^m_i\\) 只涉及纵向子模型的密度。此外，在第二个条件独立性假设 (4.8) 下，在随机效应的条件纵向响应是相互独立的，因此，关于 \\(y^m_i\\) 的积分可以很容易地忽略。因此，即使某些受试者有间歇性缺失的响应，也可以很容易地获得联合模型的似然，而不需要对缺失的响应进行积分。具体来说，在间歇性缺失数据的情况下，在选择和模式混合模型框架下，需要繁琐的计算来评估似然 (Jansen Molenberghs, 2008; Troxel et al., 1998, Troxel et al., 1998).","code":""},{"path":"chap4.html","id":"sec4-7","chapter":"第 4 章 纵向与事件时间数据的联合模型","heading":"4.7 联合模型的敏感性分析","text":"处理纵向结果缺失数据的一个实际问题是，仅根据观测数据无法区分 MAR 和 MNAR 脱落机制。事实上，Molenberghs et al. (2008) 已经表明，每个 MNAR 模型都有一个 MAR 的对应模型，它们对数据的拟合完全相同（即，相同的似然值），尽管这两个模型的推断可能显著不同。这在实践中意味着，任何 MNAR 模型中的不可忽略参数的识别主要是通过建模假设隐式提供的。因此，调查违反任何这些假设的影响的唯一实用方法只能通过敏感性分析 (Diggle et al., 2007; Jansen et al., 2006; Little Rubin, 2002; Kenward, 1998; Copas Li, 1997; Diggle Kenward, 1994).传统上，在缺失数据背景中进行敏感性分析的第一步是将假设的 MNAR 模型的结果与相应 MAR 模型的结果进行比较。在我们的设置中，这意味着将联合模型的结果与（在 MAR 下有效的）纵向子模型的结果进行比较。我们首先说明 4.2 节中使用的艾滋病数据集敏感性分析的第一步。我们用于拟合联合模型的线性混合模型的结果是从联合模型得到的相应结果是我们应该注意到，缺失数据机制的潜在错误指定（例如，假定 MAR，但真实的是 MNAR）可能会影响参数估计和标准误估计。考虑到这一点，我们观察到固定效应估计有一些小的敏感性，通过比较参数估计除以它们相应的标准误的值（即联合模型拟合结果中的 z-value 列和线性混合模型拟合结果中的 t-value 列），很容易注意到这一点。为了继续我们的敏感性分析，我们应该决定是留在共享参数/联合模型框架内，还是选择另一种类型的 MNAR 模型，例如选择模型或模式混合模型。在缺失数据的情况下，大多数统计文献侧重于选择和模式混合模型的敏感性分析 (Ibrahim Molenberghs, 2009; Molenberghs Kenward, 2007; Little Rubin, 2002; Little, 1995; Digger Kenward, 1994; Little, 1993, 1994)，而在共享参数模型框架方面的工作很少 (Creemers et al., 2010; Tsonaka et al., 2010, 2009). 因为本书的重点是联合模型，所以我们将选择留在这个建模框架中。同样，我们现在可以在全局敏感性和局部敏感性分析之间进行选择。前者需要拟合几个联合模型，并在生存子模型 (4.1) 中进行了几次替换。这些可能包括校正额外的基线协变量或使用纵向标志物的其他参数化。我们将在 5.1 节中进一步阐述这一主题。在局部敏感性的情况下，我们将重点放在 MNAR 模型上，并评估在该特定模型下，非随机脱落如何影响推断。研究这种敏感性问题的一个很好的工具是 Troxel et al. (2004) 和 Ma et al. (2004) 为选择模型提出的局部不可忽略敏感性指数 (local sensitivity non-ignorability, ISNI)，Viviani et al. (2012) 提出了将工具用于共享参数模型的方法。该指数的目的是研究纵向过程的最大似然估计在多大程度上受到关于脱落机制不可忽略性假设的影响。为了引入这一指数，对于关联参数 \\(\\alpha\\) 的固定值，令 \\(\\hat{\\beta}(\\alpha)\\) 和 \\(\\hat{\\theta}_{-\\beta}(\\alpha)\\) 分别表示纵向子模型中固定效应的最大似然估计，以及联合模型除 \\(\\beta\\) 之外所有参数的最大似然估计。ISNI 是在 \\(\\alpha=0\\) 时的局部行为的度量，即\\[\\begin{align}\n\\text{ISNI}&=\\left.\\frac{\\partial}{\\partial\\alpha}\\hat{\\beta}(\\alpha)\\right|_{\\alpha=0}\n\\tag{4.21}\n\\end{align}\\]它量化了当 \\(|\\alpha|\\) 远离零时，预期的 \\(\\hat{\\beta}(\\alpha)\\) 变化的速度。由于 (4.21) 无法解析地推导，Troxel et al.(2004) 提出使用 MNAR 模型的对数似然的二阶泰勒级数展开来近似它。具体来说，令 \\(\\beta^{(0)}=\\hat{\\beta}(0)\\) 和 \\(\\hat{\\theta}_{-\\beta}^{(0)}=\\hat{\\theta}_{-\\beta}(0)\\)，表示 \\(\\alpha=0\\) 下的最大似然估计。对联合模型的对数似然在 \\(\\theta^{(0)}=\\{\\beta^{(0)},\\hat{\\theta}_{-\\beta}^{(0)},\\alpha=0\\}\\) 处的二阶近似为\\[\\begin{aligned}\\ell(\\theta)\\quad\\approx&\\quad\\ell(\\theta^{(0)})+\\left(\\theta-\\theta^{(0)}\\right)^\\top\\left\\{\\frac{\\partial}{\\partial\\theta^\\top}\\ell(\\theta)\\Big|_{\\theta=\\theta^{(0)}}\\right\\}\\\\&+\\frac12\\big(\\theta-\\theta^{(0)}\\big)^\\top\\bigg\\{\\frac{\\partial^2}{\\partial\\theta^\\top\\partial\\theta}\\ell(\\theta)\\bigg|_{\\theta=\\theta^{(0)}}\\bigg\\}\\big(\\theta-\\theta^{(0)}\\big)\\end{aligned}\\]这得到 (4.21) 的如下近似\\[\\begin{align}\n\\text{ISNI}\\approx-\\Big\\{\\left.\\frac{\\partial^2}{\\partial\\beta^\\top\\partial\\beta}\\ell(\\theta)\\right|_{\\theta=\\theta^{(0)}}\\Big\\}^{-1}\\left\\{\\left.\\frac{\\partial^2}{\\partial\\beta^\\top\\partial\\alpha}\\ell(\\theta)\\right|_{\\theta=\\theta^{(0)}}\\right\\}\n\\tag{4.22}\n\\end{align}\\]我们观察到，(4.22) 的近似的计算仅需在 \\(\\alpha=0\\) 下计算联合模型的 Hessian 矩阵。此计算可通过函数 jointModel() 使用适当的控制参数以及对于结果的后期操作来执行。继续对艾滋病数据集的敏感性分析，我们将计算线性混合模型的固定效应参数 \\(\\beta\\) 的 ISNI。简便起见，我们为联合模型假定一个具有 Weibull 相对风险的事件时间结果子模型。作为初始步骤，我们需要计算 \\(\\alpha=0\\) 下的纵向和生存子模型的最大似然估计。对于前者，这些可从 4.2 节中使用的拟合模型对象 lmeFit.aids 中获得。对于生存子模型，我们使用 survival 包中的 survreg() 函数，如下所示我们应该注意到，survreg() 拟合 Weibull 模型（默认情况下），但在加速失效时间参数化下。这对应于以下真实事件时间的对数线性模型\\[\\log T_i^*=\\tilde{\\gamma}_0+\\tilde{\\gamma}\\mathtt{ddI}_i+\\sigma_t\\epsilon_i\\]其中 \\(\\mathtt{ddI}\\) 是 ddI 组的虚拟变量，\\(\\epsilon_i\\) 是服从极值分布的误差项，\\(\\sigma_t\\) 是尺度参数。因为我们想要相对风险参数化下 Weibull 模型的最大似然估计，所以我们需要使用变换 \\(\\gamma=-\\tilde{\\gamma}/\\sigma_{t}\\)，其中 \\(\\gamma\\) 表示 (4.1) 下的参数，其中 \\(h_0(t)=\\sigma_tt^{\\sigma_t-1}\\)。正如我们在 4.4.1 节中看到的，要在 \\(\\alpha = 0\\) 下两个子模型最大似然估计处计算联合模型的 Hessian 矩阵，我们将提供这些矩阵，并指定我们不希望 jointModel() 继续执行对数似然的优化；我们用如下语法来实现这一点11在参数 init 中，我们为命名的列表提供联合模型参数的初始值，我们将控制参数 .EM 设为 TRUE，以便指定我们只想使用 EM 算法（即，如果未达到收敛，则不要继续使用 quasi-Newton 算法），并且我们还设置了控制参数 iter.EM 为 0. 为了提取 Hessian 矩阵的相应块并计算 ISNI，我们使用以下命令12前两行从联合模型中提取 Hessian 矩阵并计算其逆矩阵，第三行和第四行计算分别对应于 \\(\\beta\\) 和 \\(\\alpha\\) 的 Hessian 矩阵各行的位置索引向量，第五行根据定义计算 ISNI. 输出中的第二列是相对 ISNI，它是 ISNI 除以线性混合模型（即 MAR）下 \\(\\hat\\beta(0)\\) 的标准误估计。Troxel et al. (2004) 提出了该相对指数，以便比较每个参数的预期敏感性的大小。这些作者认为，在非随机脱落的情况下，大于 1 的值表示相应参数估计的敏感性增加。因此，对于艾滋病数据集，随着 \\(|\\alpha|\\) 远离零，我们预计两个治疗组的斜率估计会更敏感。我们应该以一句警示来结束这次敏感性分析。具体来说，请注意，我们只研究了报告结果对联合模型 (4.20) 所隐含的 MNAR 机制的敏感性。然而，正如我们之前提到的，观测数据无法区分不同的缺失数据机制，因此，如果真实的脱落机制是另一种类型，那么结果的敏感性可能会更大。","code":"> summary(lmeFit.aids)\n\n. . .\nRandom effects:\n Formula: ~obstime | patient\n Structure: General positive-definite, Log-Cholesky parametrization\n            StdDev    Corr  \n(Intercept) 4.5901582 (Intr)\nobstime     0.1738082 -0.155\nResidual    1.7497905       \n\nFixed effects:  CD4 ~ obstime + obstime:drug \n                    Value  Std.Error  DF  t-value p-value\n(Intercept)      7.188833 0.22215874 936 32.35899  0.0000\nobstime         -0.163451 0.02080804 936 -7.85519  0.0000\nobstime:drugddI  0.028272 0.02970929 936  0.95163  0.3415\n Correlation: \n                (Intr) obstim\nobstime         -0.160       \nobstime:drugddI  0.000 -0.682\n. . .> summary(jointFit.aids)\n\n. . .\nVariance Components:\n             StdDev    Corr\n(Intercept)  4.5839  (Intr)\nobstime      0.1822 -0.0468\nResidual     1.7377        \n\nCoefficients:\nLongitudinal Process\n                  Value Std.Err z-value\n(Intercept)      7.2203  0.2218 32.5537\nobstime         -0.1917  0.0217 -8.8374\nobstime:drugddI  0.0116  0.0302  0.3834\n                p-value\n(Intercept)     <0.0001\nobstime         <0.0001\nobstime:drugddI  0.7014\n. . .> WeibFit.aids <- survreg(Surv(Time, death) ~ drug, data = aids.id,\n                          x = TRUE)\n> WeibFit.aids\n\nCall:\nsurvreg(formula = Surv(Time, death) ~ drug, data = aids.id, x = TRUE)\n\nCoefficients:\n(Intercept)     drugddI \n  3.3107850  -0.1535739 \n\nScale= 0.7323405 \n\nLoglik(model)= -825.4   Loglik(intercept only)= -826.5\n    Chisq= 2.06 on 1 degrees of freedom, p= 0.151 \nn= 467 > init.list <- list(betas = fixef(lmeFit.aids), sigma = lmeFit.aids$sigma,\n  D = getVarCov(lmeFit.aids), gammas = -coef(WeibFit.aids)/WeibFit.aids$scale,\n  sigma.t = WeibFit.aids$scale, alpha = 0)\n\n> ISNI.aids <- jointModel(lmeFit.aids, WeibFit.aids, timeVar = \"obstime\",\n  method = \"weibull-PH-aGH\", iter.EM = 0, only.EM = TRUE,\n  init = init.list)> H <- ISNI.aids$Hessian\n> H.inv <- solve(H)\n> pBetas <- head(grep(\"Y.\", colnames(H), fixed = TRUE), -1)\n> pAlpha <- which(colnames(H) == \"T.alpha\")\n> isni <- - c(H.inv[pBetas, pBetas] %*% H[pBetas, pAlpha])\n> se.betas <- sqrt(diag(vcov(lmeFit.aids)))\n> round(cbind(ISNI = isni, rISNI = isni/se.betas), 3)\n\n                  ISNI  rISNI\n(Intercept)      0.096  0.433\nobstime         -0.207 -9.965\nobstime:drugddI -0.064 -2.168"},{"path":"chap5.html","id":"chap5","chapter":"第 5 章 标准联合模型的扩展","heading":"第 5 章 标准联合模型的扩展","text":"本章介绍了第 5 章中介绍的标准联合模型的几个扩展。其中包括纵向和事件结果之间关联结构参数化的几个族，包括外源时依协变量和分层因素（观测的或潜在的），用加速失效时间模型代替相对风险模型，以及多个失效时间与多个纵向响应的联合模型。尽管我们试图全面介绍文献中提出的联合模型的大多数扩展，但我们只详细介绍 R 中目前可用的方法。","code":""},{"path":"chap5.html","id":"sec5-1","chapter":"第 5 章 标准联合模型的扩展","heading":"5.1 参数化","text":"在上一章介绍的标准联合模型中，假定特定时间点 \\(t\\) 的事件风险取决于同一时间点纵向标志物的真实水平。标志物的当前水平与风险之间的关联强度由参数 \\(\\alpha\\) 捕获。尽管这是一个非常直观且有吸引力的参数化，并且对 \\(\\alpha\\) 有清晰的解释，但期望该参数化始终最适合表达两个过程之间的正确关系是不现实的。这是因为，通常情况下，时依协变量比基线协变量更难处理。具体来说，时依协变量函数形式的选择通常需要仔细考虑，它可能会对导出的结果产生重大影响。例如，仅考虑与事件风险相关的时变协变量的当前值，可能会错过纵向标志物与生存结果之间更复杂的关联形式，或导致病因学上错误的结论 (Vacek, 1997). 关于这些问题的更详细的讨论，可参考 Fisher Lin (1999) 以及 Wolkewitz et al. (2010).在本节中，我们提出几种替代的参数化，它们以不同方式扩展标准参数化 (4.1)。这些不同的参数化可视为以下纵向标志物与事件风险之间的关联结构的一般表述的特殊情况\\[\\begin{align}\nh_i(t)=h_0(t)\\exp\\bigl[\\gamma^\\top w_{i1}+f\\{m_i(t-c),b_i,w_{i2};\\alpha\\}\\bigr]\n\\tag{5.1}\n\\end{align}\\]其中 \\(f(\\cdot)\\) 是标志物的真实水平 \\(m_i(\\cdot)\\)、随机效应 \\(b_i\\) 和额外协变量 \\(w_{i2}\\) 的函数。在该一般公式下，\\(\\alpha\\) 可以潜在地表示关联参数的向量，而不是 (4.1) 中单纯的标量。","code":""},{"path":"chap5.html","id":"sec5-1-1","chapter":"第 5 章 标准联合模型的扩展","heading":"5.1.1 交互效应","text":"标准参数化 (4.1) 假定标记物真实水平的效应在目标人群的所有亚组中是相同的。这显然是一个很强的假设，当标志物对于不同的受试者亚组表现不同时，该假设可能不正确。处理这种情况的一个直接扩展是在相对风险模型的线性预测器中包含标志物与感兴趣的基线协变量的交互项，即\\[\\begin{align}\nh_i(t)=h_0(t)\\exp\\bigl[\\gamma^\\top w_{i1}+\\alpha^\\top\\{w_{i2}\\times m_i(t)\\}\\bigr]\n\\tag{5.2}\n\\end{align}\\]其中，如前所述，\\(w_{i1}\\) 用于适应基线协变量对事件风险的直接效应，\\(w_{i2}\\) 包含交互项，这些交互项扩展了 \\(m_i(t)\\) 在不同亚组中的关联。当 \\(w_{i2}\\) 仅包含常数项，即 \\(w_{i2}=1\\) 时，(5.2) 简化为标准参数化 (4.1)。为了说明如何在 R 中拟合这样的联合模型，我们针对 PBC 数据集研究了血清胆红素的真实水平与死亡风险之间的关联强度对于患有和不患有肝肿大的患者是否不同。具体来说，对于纵向结果，我们假定每个患者的血清胆红素水平随时间呈二次演变，并且不同治疗组的患者具有不同的平均效应，从而采用线性混合模型\\[\\begin{array}{rcl}y_i(t)&=&\\beta_0+\\beta_1\\mathtt{D}\\text{-}\\mathtt{pnc}_i+\\beta_2t+\\beta_3t^2+\\beta_4\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t\\}+\\beta_5\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t^2\\}\\\\&&+b_{i0}+b_{i1}t+b_{i2}t^2+\\varepsilon_i(t),\\end{array}\\]其中 \\(y_i(t)\\) 表示观测血清胆红素水平的对数，并且 \\(\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\) 是 D-青霉胺组的虚拟变量。对于生存部分，我们包括了治疗效应、肝肿大和血清胆红素真实水平的对数，此外，我们允许胆红素与肝肿大和非肝肿大患者的死亡风险之间存在不同的关联强度\\[h_i(t)=h_0(t)\\exp\\bigl[\\gamma_1\\mathtt{D}\\text{-}\\mathtt{pnc}_i+\\gamma_2\\mathtt{HepMeg}_i+\\alpha_1m_i(t)+\\alpha_2\\bigl\\{\\mathtt{HepMeg}_i\\times m_i(t)\\bigr\\}\\bigr]\\]其中 \\(\\mathtt{HepMeg}_i\\) 是肝肿大患者的虚拟变量。假定基线风险函数 \\(h_0(\\cdot)\\) 是分段常数的。PBC 数据集中患者的纵向信息可在 JM 包中作为数据框 pbc2 获得，生存信息作为数据框 pbc2.id 提供。为了拟合联合模型，正如我们之前所看到的，我们首先需要分别拟合线性混合模型和 Cox 模型以及相应的协变量结构。对于后者，我们只需要包含线性预测器 \\(\\gamma^\\top w_{i1}\\)，即如 3.3 节所示，status2 是复合事件（移植或死亡）的指示符。为了将交互部分 \\(\\alpha^\\top\\{w_{i2}\\times m_i(t)\\}\\) 包含在相应联合模型的线性预测器中，我们利用了 jointModel() 的 interFact 参数。该参数接受一个命名的列表：包含一个名为 value 的组件，该组件提供指定 \\(W_2\\) 设计矩阵形式的 R 公式，以及一个名为 data 的组件，指定要应用该公式的数据框。对于我们的特定示例，我们使用语法13我们观察到，血清胆红素确实与死亡风险密切相关。血清胆红素对数的当前值每增加一个单位，无肝肿大患者的风险就会增加为原来的 \\(\\exp(1.1562)=3.2\\) 倍 (95%CI: 2.5, 4.1)，有肝肿大患者风险就会增加为原来的 \\(\\exp(1.1563+0.2353)=4\\) 倍 (95%CI: 3.1, 5.2).","code":"> lmeFit.pbc <- lme(log(serBilir) ~ drug * (year + I(year^2)),\n                    random = ~ year + I(year^2) | id, data = pbc2)\n> coxFit.pbc <- coxph(Surv(years, status2) ~ drug + hepatomegaly,\n                      data = pbc2.id, x = TRUE)> jointFit.pbc <- jointModel(lmeFit.pbc, coxFit.pbc, timeVar = \"year\",\n                             method = \"piecewise-PH-aGH\",\n                             interFact = list(value = ~ hepatomegaly,\n                                              data = pbc2.id))\n> summary(jointFit.pbc)\n\n. . .\n\nEvent Process\n                        Value Std.Err  z-value p-value\ndrugD-penicil          0.0882  0.1677   0.5263  0.5987\nhepatomegalyYes        0.2288  0.4112   0.5566  0.5778\nAssoct                 1.1562  0.1286   8.9900 <0.0001\nAssoct:hepatomegalyYes 0.2353  0.1850   1.2722  0.2033\nlog(xi.1)             -4.7939  0.3297 -14.5386\nlog(xi.2)             -4.4271  0.3326 -13.3117\nlog(xi.3)             -4.3962  0.3543 -12.4092\nlog(xi.4)             -4.2151  0.3794 -11.1102\nlog(xi.5)             -4.2400  0.3824 -11.0890\nlog(xi.6)             -4.0540  0.4018 -10.0905\nlog(xi.7)             -4.6011  0.5146  -8.9419\n. . ."},{"path":"chap5.html","id":"sec5-1-2","chapter":"第 5 章 标准联合模型的扩展","heading":"5.1.2 滞后效应","text":"在某些情况下，时依协变量的当前值影响事件当前风险的典型假设可能会得到医学上不合逻辑的结论。例如，Cavender et al. (1992) 观察到了这一点，他在一项关于冠状动脉疾病患者的研究中指出，目前的吸烟状态降低了死亡风险（尽管没有统计学意义）。这一令人惊讶的结果背后的原因是，大多数死亡者都是吸烟者，但许多人在去世前的最后一次随访中已经戒烟。因此，许多死亡的患者刚刚戒烟，而一些还活着的患者仍在吸烟，这得到了令人惊讶的结果。解决这种情况的一种方法是使用时滞 (time-lagged) 协变量。具体来说，我们使用以下相对风险模型的公式\\[\\begin{align}\nh_i(t)=h_0(t)\\exp\\bigl[\\gamma^\\top w_i+\\alpha m_i\\{\\max(t-c,0)\\}\\bigr]\n\\tag{5.3}\n\\end{align}\\]它假设时间 \\(t\\) 的风险取决于纵向标志物在时间 \\(t−c\\) 的真实值，其中 \\(c\\) 指定了感兴趣的时间滞后。使用函数 jointModel() 的 lag 参数，可以轻松地将这种滞后效应纳入 R 的联合模型的指定中。例如，我们将联合模型拟合到肝硬化数据集中。对于纵向部分，为了灵活指定特定于受试者的纵向轨迹，我们假定了一个具有自然立方样条曲线效应的线性混合模型，每个治疗组具有不同的平均曲线。此外，为了捕捉每个治疗组随访早期凝血酶原指数的突然变化，我们还包括了一个单独的基线测量指示变量。模型采用以下形式\\[\\begin{aligned}\ny_i(t) =&\\quad m_i(t)+\\varepsilon_i(t)  \\\\\n=&\\quad (\\beta_0+b_{i0})+(\\beta_1+b_{i1})B_n(t,\\lambda_1)+(\\beta_2+b_{i2})B_n(t,\\lambda_2)  \\\\\n&+(\\beta_3+b_{i3})B_n(t,\\lambda_3)+\\beta_4\\{B_n(t,\\lambda_1)\\times\\mathtt{Predns}_i\\}\\\\\n&+\\beta_5\\{B_n(t,\\lambda_2)\\times\\mathtt{Predns}_i\\}+\\beta_6\\{B_n(t,\\lambda_3)\\times\\mathtt{Predns}_i\\} \\\\\n&+\\beta_7\\mathtt{Predns}_i+\\beta_8\\mathtt{T0}_i+\\beta_9\\{\\mathtt{Predns}_i\\times\\mathtt{T0}_i\\}+\\varepsilon_i(t),\n\\end{aligned}\\]其中 \\(y_i(t)\\) 表示凝血酶原指数，\\(\\{B_n(t,\\lambda_k);k=1,2,3\\}\\) 为时间自然立方样条的 B 样条基矩阵，其中两个内部结分别位于随访时间的 33.3% 和 66.7% 百分位处，\\(\\mathtt{Predns}\\) 是泼尼松的指示变量，\\(\\mathtt{T0}\\) 是基线时间的指示变量。假定随机效应具有对角协方差阵。凝血酶原指数的纵向响应可在数据框 prothro 中获得；我们使用如下语法来拟合模型在生存子模型中，我们校正治疗并比较时依凝血酶原指数的两种公式。在第一个公式中，我们假定死亡风险取决于凝血酶原的当前值，而在第二个公式中，我们假定这取决于两年前的凝血酶原值，两个公式分别为\\[\\begin{array}{rcl}h_i(t)&=&h_0(t)\\exp\\{\\gamma\\mathtt{Predns}_i+\\alpha m_i(t)\\}\\\\h_i(t)&=&h_0(t)\\exp\\bigl[\\gamma\\mathtt{Predns}_i+\\alpha m_i\\{\\max(t-2,0)\\}\\bigr]\\end{array}\\]和之前一样，在拟合联合模型之前，我们首先需要拟合仅包含基线协变量部分的 Cox 模型，在本例中为治疗；相应的语法为其中 prothros 是存储了生存信息的数据框。第一个联合模型是通过对 jointModel() 的标准调用来拟合的，正如我们到目前为止所使用的那样14为了拟合第二个联合模型，我们使用参数 lag 来指定感兴趣的滞后。此外，由于与之前调用 jointModel() 的唯一区别是 lag 参数的额外指定，因此我们可以通过使用 update() 函数更新之前的拟合来轻松拟合新的联合模型我们关注主要感兴趣的参数，即生存子模型 \\(\\gamma\\) 和 \\(\\alpha\\) 的参数，并比较两种参数化下的渐近 95% 置信区间。对于关联参数，我们观察到两种制剂在时依凝血酶原指数方面的差异相对较小。然而，无滞后效应（\\(c=0\\)）的治疗效应大约是滞后两年（\\(c=2\\)）的两倍，尽管在两个参数化下都不显著。为了对这两个模型进行统计上的比较，我们需要使用 4.4 节介绍的信息准则，因为这两个模型没有嵌套。我们使用 anova() 函数执行此比较，在该函数中，我们使用 test 参数明确指定不希望执行似然比检验。AIC 和 BIC 的结果是一致的，具有滞后时依凝血酶原指数的联合模型比假定该指数的当前值与死亡风险相关的模型具有更好的预测能力。","code":"> prothro$t0 <- as.numeric(prothro$time == 0)\n> lmeFit.pro <- lme(pro ~ treat * (ns(time, 3) + t0),\n                    random = list(id = pdDiag(form = ~ ns(time, 3))),\n                    data = prothro)> coxFit.pro <- coxph(Surv(Time, death) ~ treat, data = prothros,\n                      x = TRUE)> jointFit.pro <- jointModel(lmeFit.pro, coxFit.pro, timeVar = \"time\",\n                             method = \"piecewise-PH-aGH\")> jointFit2.pro <- update(jointFit.pro, lag = 2)> confint(jointFit.pro, parm = \"Event\")\n                      2.5 %        est.      97.5 %\ntreatprednisone  0.10149968  0.42367775  0.74585581\nAssoct          -0.04775799 -0.04059136 -0.03342473\n\n> confint(jointFit2.pro, parm = \"Event\")\n                      2.5 %        est.      97.5 %\ntreatprednisone -0.04759691  0.22698288  0.50156268\nAssoct(lag=2)   -0.04638202 -0.03859134 -0.03080066> anova(jointFit.pro, jointFit2.pro, test = FALSE)\n                   AIC      BIC   log.Lik df\njointFit.pro  27918.33 28018.90 -13935.17   \njointFit2.pro 27407.45 27508.01 -13679.72  0"},{"path":"chap5.html","id":"sec5-1-3","chapter":"第 5 章 标准联合模型的扩展","heading":"5.1.3 时依斜率参数化","text":"在前面的参数化中，我们假定事件的风险取决于纵向标志物的当前值或先前值。然而，由于对于每个患者，标志物都遵循关于时间的轨迹，因此考虑允许事件风险也取决于该轨迹的其他特征的参数化也是合理的。Ye et al. (2008b) 考虑了这种类型的参数化，他们假定了一个联合模型，其中风险取决于轨迹的当前真实值和时间 \\(t\\) 时真实轨迹的斜率。图 5.1 给出了该参数化的图形表示。更具体地说，相对风险生存子模型采用以下形式\\[\\begin{align}\nh_i(t)=h_0(t)\\exp\\bigl\\{\\gamma^\\top w_i+\\alpha_1m_i(t)+\\alpha_2m_i'(t)\\bigr\\}\n\\tag{5.4}\n\\end{align}\\]其中\\[\\begin{aligned}m_i'(t)=\\frac{d}{dt}m_i(t)=\\frac{d}{dt}\\{x_i^\\top(t)\\beta+z_i^\\top(t)b_i\\}\\end{aligned}\\]\n参数 \\(\\alpha_1\\) 的解释与标准参数化 (4.1) 中的解释相同。参数 \\(\\alpha_2\\) 度量时间 \\(t\\) 时真实纵向轨迹的斜率值与同一时间点事件风险的关联强度，前提是 \\(m_i(t)\\) 保持不变。这种参数化可以捕捉这样的情况，例如，在特定时间点，两名患者显示相似的真实标志物水平，但他们的标志物变化率可能不同。为了研究 5.1.1 节中介绍的 PBC 数据集参数化的额外值，我们用更新的生存子模型重新拟合了联合模型，该子模型形如\\[h_i(t)=h_0(t)\\exp\\bigl\\{\\gamma_1\\mathtt{D}\\text{-}\\mathtt{pnc}_i+\\gamma_2\\mathtt{HepMeg}_i+\\alpha_1m_i(t)+\\alpha_2m_i'(t)\\bigr\\}\\]其中我们排除了血清胆红素与肝肿大的交互作用项，并包括了时依斜率。我们首先重新拟合第 5.1.1 节中提出的联合模型，排除交互项，即为了包含时依斜率项，我们使用 jointModel() 的 parameterization 和 derivForm 参数。具体来说，parameterization 参数指定了我们感兴趣的参数化类型，默认为标志物的当前值。这里我们需要当前值和斜率，因此我们指定为选项 \"\"。在 derivForm 参数中，我们必须使用 R 的公式接口指定轨迹导数的函数形式。在拟合 PBC 数据的线性混合效应子模型下，\\(m_i(t)\\) 具有以下形式\\[\\begin{array}{rcl}m_i(t)&=&\\beta_0+\\beta_1\\mathtt{D}\\text{-}\\mathtt{pnc}_i+\\beta_2t+\\beta_3t^2+\\beta_4\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t\\}+\\beta_5\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t^2\\}\\\\&&+b_{i0}+b_{i1}t+b_{i2}t^2,\\end{array}\\]对 \\(t\\) 求导并化简\\[\\begin{aligned}m_i'(t)=\\beta_2+2\\beta_3t+\\beta_4\\mathtt{D}\\text{-}\\mathtt{pnc}_i+2\\beta_5\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t\\}+b_{i1}+2b_{i2}t\\end{aligned}\\]为了解释如何调用参数 derivForm，我们首先在混合效应模型结构下重写 \\(m'_i (t)\\)，即\\[\\begin{aligned}m'_i(t)=[x_i^{sl}(t)]^\\top\\beta^{sl}+[z_i^{sl}(t)]^\\top b_i^{sl}\\end{aligned}\\]其中 \\(x_i^{sl}(t)=[1,2t,\\mathtt{D}\\text{-}\\mathtt{pnc}_i,2(t\\times\\mathtt{D}\\text{-}\\mathtt{pnc}_i)]\\)，\\(z_i^{sl}(t)=[1,\\,2t]\\)，\\(\\beta^{sl}=(\\beta_2,\\beta_3,\\beta_3,\\beta_4)^\\top\\) 以及 \\(b_i^{sl}=(b_{i1},b_{i2})^\\top\\)。使用该公式，参数 derivForm 被指定为具有四个组件的命名列表，即两个 R 公式，分别命名为 fixed 和 random，分别用于构造 \\(m'_i (t)\\) 定义中的固定效应和随机效应设计矩阵，两个数值向量，分别命名为 indFixed 和 indRandom，指定原始的 \\(m_i(t)\\) 的固定效应参数 \\(\\beta\\) 和随机效应 \\(b_i\\) 中的哪些参与 \\(m'_i (t)\\) 的指定。因此，对于我们的示例，derivForm 列表采用以下形式其中 indFixed = 3:6，因为在上述 \\(m'_i(t)\\) 的定义中，使用了 \\(m_i(t)\\) 的第 3 至第 6 个固定效应参数，对于组件 indRandom 也类似。注意，默认情况下，用于构建设计矩阵的 R 公式包括截距项。相应联合模型的拟合为:我们观察到，输出中标记为 Assect.s 的轨迹斜率与死亡风险高度相关。具体来说，对于具有相同对数血清胆红素水平的患者，胆红素轨迹的当前斜率的单位增加的对数风险比为 2.5 (95%CI: 1.4, 3.7). 为了在统计上检验标志物的总体效应，我们可以使用 anova() 函数进行多元 Wald 检验。正如我们在 4.4 节中所看到的，默认情况下，该函数将为模型中的所有参数提供边际 Wald 检验。在这里，我们重点关注事件过程与条目 Assoct() 相关的 \\(p\\) 值对应于在模型 (5.4) 下检验如下的一组假设\\[\\begin{aligned}H_0&:\\alpha_1=\\alpha_2=0\\\\H_a&:\\alpha_1\\neq0\\quad\\text{}\\quad\\alpha_2\\neq0\\end{aligned}\\]结果验证了以下假设：对于 PBC 患者，血清胆红素对数的当前值和胆红素轨迹的斜率与复合事件（死亡或移植）的风险高度相关。","code":"> jointFit2.pbc <- update(jointFit.pbc, interFact = NULL)> dform <- list(fixed = ~ I(2*year) + drug + I(2*year):drug,\n                indFixed = 3:6, random = ~ I(2*year), indRandom = 2:3)> jointFit3.pbc <- update(jointFit2.pbc, parameterization = \"both\",\n                          derivForm = dform)\n> summary(jointFit3.pbc)\n\n. . .\nEvent Process\n                  Value Std.Err  z-value p-value\ndrugD-penicil    0.1751  0.1972   0.8878  0.3746\nhepatomegalyYes  0.6011  0.2103   2.8576  0.0043\nAssoct           1.2181  0.1166  10.4507 <0.0001\nAssoct.s         2.8505  0.6417   4.4422 <0.0001\nlog(xi.1)       -6.0564  0.4565 -13.2661        \nlog(xi.2)       -5.5892  0.4106 -13.6121        \nlog(xi.3)       -5.6825  0.4242 -13.3956        \nlog(xi.4)       -5.5677  0.4593 -12.1214        \nlog(xi.5)       -5.2350  0.4189 -12.4968        \nlog(xi.6)       -5.0048  0.4557 -10.9823        \nlog(xi.7)       -5.0677  0.5328  -9.5108     \n. . .> anova(jointFit3.pbc, process = \"Event\")\n\nMarginal Wald Tests Table\n\nEvent Process\n                Chisq df Pr(>|Chi|)\ndrug           0.7882  1     0.3746\nhepatomegaly   8.1660  1     0.0043\nAssoct(all)  141.9891  2     <1e-04\nAssoct       109.2181  1     <1e-04\nAssoct.s      19.7330  1     <1e-04"},{"path":"chap5.html","id":"sec5-1-4","chapter":"第 5 章 标准联合模型的扩展","heading":"5.1.4 累积效应参数化","text":"到目前为止，我们看到的所有参数化的一个共同特征是，它们假定特定时间事件的风险仅取决于单个时间点的纵向轨迹的特征。也就是说，根据真实标志物水平 \\(\\mathcal{M}_i(t)=\\{m_i(s),0\\leq s<t\\}\\) 的整个历史，如果像 5.1.2 节那样考虑滞后效应，则时间 \\(t\\) 的风险通常假定取决于同一时间点的标志物水平 \\(m_i(t)\\) 或前一个时间点的标志物水平 \\(m_i(t − c)\\)。然而，一些作者认为，这种假定并不总是现实的，在许多情况下，允许风险依赖于纵向标志物历史的更详细的函数可能会使我们受益 (Sylvestre Abrahamowicz, 2009; Hauptmann et al., 2000; Vacek, 1997).允许标志物的整个历史与事件的风险相关联的一种方法是在相对风险子模型的线性预测器中包括纵向轨迹的积分，该积分表示直到时间点 \\(t\\) 的纵向结果的累积效应。图 5.2 给出了该参数的图形表示。更具体地说，生存子模型采用以下形式\\[\\begin{align}\nh_i(t)=h_0(t)\\exp\\Bigl\\{\\gamma^\\top w_i+\\alpha\\int_0^tm_i(s)ds\\Bigr\\}\n\\tag{5.5}\n\\end{align}\\]\n其中，对于任何特定的时间点 \\(t\\)，\\(\\alpha\\) 度量在时间点 \\(t\\) 的事件风险与直到相同时间纵向轨迹下面积之间的关联强度，并且将纵向轨迹下面积视为整个轨迹的适当总结。为了在这种参数化下拟合联合模型，我们可以利用 jointModel() 的 derivForm 参数提供的灵活性来指定要添加到生存子模型线性预测器中的额外标志物项。具体来说，我们没有像 5.1.3 节那样指定 R 公式来定义时依斜率项 \\(m'_i(t)\\)，而是为计算 \\(m'(t)\\) 积分所需的固定和随机效应部分指定相应的 R 公式。我们继续使用上一节中的 PBC 数据集的同一示例来说明如何实现这一点，现在我们将联合模型与以下形式的生存子模型进行拟合\\[\\begin{aligned}h_i(t)=h_0(t)\\exp\\Bigl\\{\\gamma_1\\mathtt{D}\\text{-}\\mathtt{pnc}_i+\\gamma_2\\mathtt{HepMeg}_i+\\alpha\\int_0^tm_i(s)ds\\Bigr\\}\\end{aligned}\\]在 5.1.3 节给出的 \\(m_i(t)\\) 公式下，可以容易地看出其积分具有以下闭式解\\[\\begin{aligned}\\int_0^tm_i(s)~ds&=\\beta_0t+\\beta_1\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t\\}+\\beta_2t^2/2+\\beta_3t^3/3\\\\&\\quad+\\beta_4\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t^2/2\\}+\\beta_5\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t^3/3\\}+b_{i0}t+b_{i1}t^2/2+b_{i2}t^3/3\\end{aligned}\\]我们将该式转化为固定和随机效应部分的一对 R 公式。此外，我们还在 indFixed 和 indRandom 组件中指定原始线性混合模型的哪些固定和随机效应参数对应于用于计算 \\(m_i(t)\\) 积分的设计矩阵的列。在固定和随机效应部分的公式定义中添加的 -1 用于排除截距项，默认情况下，截距项包含在 R 的设计矩阵的构造中。通过在 derivForm 参数中提供 iform 列表，可以简单地拟合相应的联合模型。此外，parameterization 参数中的选项 \"slope\" 指定我们只想在生存子模型的线性预测器中包括 derivForm 参数创建的项，而不是当前值的项 \\(m_i(t)\\)。与之前的分析相似，我们观察到血清胆红素仍然与死亡风险密切相关。具体来说，对数血清胆红素纵向分布下面积的单位增加对应于死亡风险增加为原来的 1.2 倍。参数化 (5.5) 的一个限制是它为标志物的所有过去值设置相同的权重，这在某些情况下可能是不合理的。解决此问题的一个简单扩展是调整被积函数并将 \\(m_i(t)\\) 与适当选择的权重函数相乘，该权重函数在不同的时间点设置不同的权重：\\[\\begin{align}\nh_i(t)=h_0(t)\\exp\\Bigl\\{\\gamma^\\top w_i+\\alpha\\int_0^t\\varpi(t-s)m_i(s)ds\\Bigr\\}\n\\tag{5.6}\n\\end{align}\\]其中 \\(\\varpi(\\cdot)\\) 表示权重函数。\\(\\varpi(\\cdot)\\) 的一个理想性质是在过去更远的点上放置更小的权重。具有这种性质的一个可能的函数族是已知参数分布的概率密度函数，如正态、学生 t 和 logistic. 这些密度中的尺度参数以及学生 t 密度中的自由度参数可用于调整较新标志物值与较旧标志物值相比的相对权重。参数化 (5.6) 与 Breslow et al. (1983) 和 Thomas (1988) 讨论的加权累积暴露的概念有直接联系。作为说明，我们更新了 PBC 数据集的累积效应分析，并使用标准正态密度作为权重函数，即 \\(\\varpi(x) = \\exp(-x^2/2)/\\sqrt{2\\pi}\\)。通过将正态密度的方差设置为 1，我们实际上假定最近三年15的血清胆红素历史记录与死亡风险相关。纵向子模型中 \\(m_i(t)\\) 的指定假定固定效应和随机效应部分的时间效应均采用二阶多项式。因此，为了构建加权累积效应，我们需要计算以下形式的积分\\[\\begin{aligned}\\int_0^ts^j\\varpi(t-s)ds=(1/\\sqrt{2\\pi})\\int_0^ts^j\\exp\\{-(t-s)^2/2\\}ds\\end{aligned}\\]其中 \\(j=0,1,2\\)。由于这些积分对于 \\(j>0\\) 没有闭合形式的解，我们将使用 R 中的内置函数 integrate() 对它们进行数值近似。该函数基于我们之前在生存函数 (4.2) 的定义中看到的积分近似的 Gauss-Kronrod 规则。与未加权的分析类似，我们需要为固定效应和随机效应部分定义适当的公式，这些公式将在 jointModel() 的 derivForm 参数中提供。作为初始步骤，我们定义函数 g()，该函数使用 integrate() 计算所需的积分最后一行中的 sapply() 语句用于将 g() 关于其第一个参数向量化，即当 \\(u\\) 是向量时使 g() 起作用。接下来，使用 g() 我们定义权重累积效应的固定部分和随机部分，并拟合相应的联合模型我们观察到，加权累积效应也与死亡风险密切相关，对数血清胆红素轨迹下加权面积的单位增加对应于风险增加为原来的 11.4 倍。表 5.1 说明了在加权累积效应、未加权累积效应和当前值参数化下使用 PBC 数据集拟合的三个联合模型的信息准则的比较。我们观察到，权重函数的包含明显提高了累积效应参数化下的拟合度。然而，对于这个特定的数据集，似乎仅使用风险模型中标志物 \\(m_i(t)\\) 的最新值比使用累积效应提供更好的预测能力。图 5.3 给出了这三个参数化之间的额外比较，它描述了 PBC 数据集中两名患者的风险函数。显然，参数化的选择会对特定受试者的风险函数的形状产生相当大的影响，这表明选择数据不支持的参数化可能会极大地影响模型的拟合。因此，我们不应该总是仅依赖标准公式 (4.1) ，而应该仔细考虑问题并研究不同的参数化及其可能的组合。","code":"> iform <- list(fixed = ~ -1 + year + I(year * (drug == \"D-penicil\")) +\n                  I(year^2/2) + I(year^3/3) + I(year^2/2 * (drug == \"D-penicil\")) +\n                  I(year^3/3 * (drug == \"D-penicil\")),\n                indFixed = 1:6,\n                random = ~ -1 + year + I(year^2/2) + I(year^3/3),\n                indRandom = 1:3)> jointFit4.pbc <- update(jointFit3.pbc, parameterization = \"slope\",\n                          derivForm = iform)\n> summary(jointFit4.pbc)\n\n. . .\nEvent Process\n                  Value Std.Err  z-value p-value\ndrugD-penicil    0.0471  0.1747   0.2695  0.7876\nhepatomegalyYes  0.9624  0.1899   5.0690 <0.0001\nAssoct.s         0.1873  0.0208   9.0231 <0.0001\nlog(xi.1)       -3.5552  0.2360 -15.0635        \nlog(xi.2)       -3.5649  0.2546 -14.0011        \nlog(xi.3)       -4.0452  0.3122 -12.9570        \nlog(xi.4)       -4.1554  0.3712 -11.1931        \nlog(xi.5)       -4.0360  0.3507 -11.5092        \nlog(xi.6)       -3.9714  0.4092  -9.7047        \nlog(xi.7)       -5.5984  0.6323  -8.8534   \n. . .> g <- function (u, pow = 0) {\n  f <- function (t)\n    integrate(function (s) s^pow * dnorm(t - s), 0, t)$value\n  sapply(u, f)\n}> iformW <- list(fixed = ~ -1 + I(g(year)) +\n                   I(g(year) * (drug == \"D-penicil\")) +\n                   I(g(year, 1)) + I(g(year, 2)) +\n                   I(g(year, 1) * (drug == \"D-penicil\")) +\n                   I(g(year, 2) * (drug == \"D-penicil\")),\n                 indFixed = 1:6,\n                 random = ~ -1 + I(g(year)) + I(g(year, 1)) + I(g(year, 2)),\n                 indRandom = 1:3)\n> jointFit5.pbc <- update(jointFit3.pbc, parameterization = \"slope\",\n                          derivForm = iformW)\n> summary(jointFit5.pbc)\n\n. . .\nEvent Process\n                  Value Std.Err  z-value p-value\ndrugD-penicil    0.0963  0.1776   0.5422  0.5877\nhepatomegalyYes  0.7804  0.1942   4.0184  0.0001\nAssoct.s         2.4086  0.1898  12.6880 <0.0001\nlog(xi.1)       -4.2907  0.2729 -15.7249        \nlog(xi.2)       -4.4941  0.3026 -14.8518        \nlog(xi.3)       -4.7226  0.3362 -14.0456        \nlog(xi.4)       -4.6588  0.3812 -12.2221        \nlog(xi.5)       -4.3633  0.3471 -12.5697        \nlog(xi.6)       -4.0054  0.3610 -11.0952        \nlog(xi.7)       -4.6692  0.4899  -9.5311    \n. . ."},{"path":"chap5.html","id":"sec5-1-5","chapter":"第 5 章 标准联合模型的扩展","heading":"5.1.5 随机效应参数化","text":"在联合模型中经常使用的另一种类型的参数化在风险模型的线性预测器中仅包括纵向子模型的随机效应，即\\[\\begin{align}\nh_i(t)=h_0(t)\\exp(\\gamma^\\top w_i+\\alpha^\\top b_i)\n\\tag{5.7}\n\\end{align}\\]其中 \\(\\alpha\\) 表示关联参数向量，每个参数度量相应随机效应与事件风险之间的关联。当为纵向子模型假定简单的随机截距和随机斜率结构时，这种参数化更有意义，在这种情况下，随机效应表示特定受试者与平均截距和平均斜率的偏差。在此设置下，该参数化假设基线纵向结果（即截距）具有较低/较高水平的患者或纵向轨迹（即斜率）显示出更陡峭的增加/减少的患者更有可能经历该事件（即脱落）。这种解释也促进了在缺失数据框架中使用的联合模型（即共享参数模型）中使用这种参数化 (Pulkstenis et al., 1998; Follmann Wu, 1995; Wu Bailey, 1989). 该参数化也与 5.1.3 节中介绍的时依斜率参数化有相似之处。具体来说，在具有随机截距和随机斜率结构的纵向子模型下，即\\[\\begin{aligned}y_i(t)=\\beta_0+\\beta_1t+b_{i0}+b_{i1}t+\\varepsilon_i(t)\\end{aligned}\\]\\(\\alpha_1=0\\) 的时变斜率参数化 (5.4) 下事件过程的相对风险子模型采用以下形式\\[\\begin{aligned}h_i(t)=h_0(t)\\exp\\{\\gamma^\\top w_i+\\alpha_2(\\beta_1+b_{i1})\\}\\end{aligned}\\]而相对风险子模型在相同的纵向子模型下，但参数化 (5.7) 变成\\[\\begin{aligned}h_i(t)=h_0(t)\\exp(\\gamma^\\top w_i+\\alpha_1b_{i0}+\\alpha_2b_{i1})\\end{aligned}\\]如果我们在相对风险子模型的后一个公式中设 \\(\\alpha_1 = 0\\)，我们观察到该模型还假定风险仅取决于线性混合模型的随机斜率部分。值得注意的是，\\(\\alpha_2\\) 在两个参数化中的解释是不同的，因为项 \\((\\beta_1 + b_{i1})\\) 表示第 \\(\\) 个受试者的纵向轨迹的潜在斜率，而项 \\(b_{i1}\\) 表示受试者 \\(\\) 的斜率与总体均值 \\(\\beta_1\\) 的偏差。参数化 (5.7) 的一个计算优势是它与时间无关，因此在生存函数 (4.2) 的定义中可得到积分的闭合形式解（在某些基线风险函数下）。这便于计算，因为我们不必在数值上近似这个积分。然而，当假设纵向子模型的特定主题平均结构的复杂公式时，(5.7) 的一个重要缺点出现了。具体来说，当多项式或样条曲线用于捕捉非线性的特定于受试者的演变时，随机效应没有直接的解释。例如，在拟合到 PBC 数据集的联合模型中，我们假定了时间效应的二次多项式（见 5.1.1 节），关于特定于受试者的线性斜率 \\(b_{i1}\\) 的解释，不能独立于特定于受试者的二次斜率 \\(b_{i2}\\)。这显然也影响了关联参数 \\(\\alpha\\) 的可解释性。由于这一限制，JM 包不显式地将该参数化作为选项包括在内。然而，如上所述，我们可以在简单的随机截距和随机斜率设置下，使用 5.1.3 节的时依斜率参数化来模拟该参数化的一部分。为了说明这一点，我们在假定血清胆红素遵循更简单的线性混合模型（即排除二次时间趋势）的情况下，重新拟合了针对 PBC 数据集的联合模型。\\[y_i(t)=\\beta_0+\\beta_1\\mathtt{D}\\text{-}\\mathtt{pnc}_i+\\beta_2t+\\beta_3\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t\\}+b_{i0}+b_{i1}t+\\varepsilon_i(t)\\]以及死亡的相对风险模型，包括特定于患者的斜率作为额外协变量\\[h_i(t)=h_0(t)\\exp\\{\\gamma_1\\mathtt{D}\\text{-}\\mathtt{pnc}_i+\\gamma_2\\mathtt{HepMeg}_i+\\alpha(\\beta_2+b_{i1})\\}\\]在下面相应的 R 语法中，我们首先拟合更简单的线性混合模型，接下来我们定义 derivForm 参数的公式列表，最后通过指定参数化方式（仅在风险模型中包含真实轨迹的斜率）来更新先前拟合的联合模型16我们观察到，特定于受试者的斜率与瞬时死亡风险密切相关。如图 5.4 所示，斜率系数的较大值是由其较小的变异性来解释的。因此，计算斜率单位增加的风险比是没有意义的，因为这种幅度的增加是不现实的。通过将其与模型 jointFit6.pbc 的标准差估计除以 0.18，可以获得对特定于受试者的斜率更有用的估计。更新后的联合模型拟合使用以下语法生成17\n结果表明，对于接受相同治疗且具有相同肝肿大状态的患者，血清胆红素对数斜率每增加一个标准差，死亡或移植的风险就会增加为原来的 5.82 倍 (95% CI：3.91, 8.67).","code":"> lmeFit2.pbc <- lme(log(serBilir) ~ year * drug,\n                     random = ~ year | id, data = pbc2)\n> dform2 <- list(fixed = ~ 1, indFixed = 3,\n                 random = ~ 1, indRandom = 2)\n> jointFit6.pbc <- update(jointFit3.pbc, lmeObject = lmeFit2.pbc,\n                          parameterization = \"slope\", derivForm = dform2)\n> summary(jointFit6.pbc)\n\n. . .\ndrugD-penicil   -0.0680 0.2203  -0.3087  0.7575\nhepatomegalyYes  0.8409 0.2022   4.1586 <0.0001\nAssoct.s         9.7530 1.1201   8.7070 <0.0001\nlog(xi.1)       -6.7693 0.5227 -12.9517\nlog(xi.2)       -5.3977 0.4295 -12.5686\nlog(xi.3)       -4.9452 0.3959 -12.4926\nlog(xi.4)       -4.4833 0.3943 -11.3707\nlog(xi.5)       -4.1852 0.3698 -11.3168\nlog(xi.6)       -3.5718 0.3652 -9.7797\n. . .> dform3 <- list(fixed = ~ -1 + I(rep(1/0.18, length(drug))),\n                 random = ~ -1 + I(rep(1/0.18, length(drug))),\n                 indFixed = 3, indRandom = 2)\n> jointFit7.pbc <- update(jointFit6.pbc, derivForm = dform3)\n> summary(jointFit7.pbc)\n\n. . .\n                  Value Std.Err  z-value p-value\ndrugD-penicil   -0.0668  0.2207  -0.3028  0.7621\nhepatomegalyYes  0.8443  0.2027   4.1655 <0.0001\nAssoct.s         1.7617  0.2032   8.6689 <0.0001\nlog(xi.1)       -6.7889  0.5261 -12.9051\nlog(xi.2)       -5.4148  0.4326 -12.5158\nlog(xi.3)       -4.9596  0.3984 -12.4486\nlog(xi.4)       -4.4970  0.3966 -11.3394\nlog(xi.5)       -4.1969  0.3718 -11.2891\nlog(xi.6)       -3.5821  0.3668  -9.7653\nlog(xi.7)       -3.8953  0.4711  -8.2684\n. . ."},{"path":"chap5.html","id":"sec5-2","chapter":"第 5 章 标准联合模型的扩展","heading":"5.2 处理外源时依协变量","text":"在上一节中，我们看到了内生时依协变量与事件风险之间的关联结构的几种可能的公式化。然而，在某些情况下，在相对风险模型的线性预测中加入额外的外源时依协变量也可能是有意义的。例如，在移植研究中，我们可能想检查患者水平上记录的生物标志物与死亡风险之间的关联，同时考虑移植的时依效应。利用内生协变量的标准当前值参数化 (4.1)，相对风险模型可以很容易地扩展到处理外源协变量，如\\[\\begin{align}\nh_i(t)=h_0(t)\\exp\\{\\gamma^\\top w_i(t)+\\alpha m_i(t)\\}\n\\tag{5.8}\n\\end{align}\\]其中协变量向量 \\(w_i(t)\\) 现在包含基线和外源时依协变量。此外，5.1 节的替代参数化可以考虑用于内生协变量，也可以考虑用于外源协变量，例如与基线协变量的交互效应、滞后效应和累积效应，其中对于后者，(5.5) 或 (5.6) 中的积分被求和代替。具有外源和内生时依协变量的联合模型的估计与仅具有内生协变量的联合模型的估计相同。唯一实际的区别在于生存函数定义中积分的计算，由于计算原因，该函扩展为\\[\\begin{aligned}\\mathcal{S}_i(t\\mid\\mathcal{M}_i(t),w_i)&=\\exp\\biggl(-\\int_0^th_i(s)ds\\biggr)\\\\&=\\exp\\biggl(-\\sum_{q=1}^{Q_i}\\int_{\\Omega_{iq}}h_0(s)\\exp\\{\\gamma^\\top w_{iq}(s)+\\alpha m_i(s)\\}ds\\biggr)\\end{aligned}\\]其中 \\(\\{\\Omega_{iq},q=1,\\ldots,Q_i\\}\\) 表示时间区间，在此期间外源时依协变量 \\(w_i(t)\\) 假定为常数。作为说明，我们将联合模型与 PBC 数据集拟合，其中包含复合事件（死亡或移植）更新的相对风险子模型，除了治疗和记录血清胆红素的效应外，还包括的随访期间蜘蛛痣（皮肤血管畸形）的主效应及其与治疗的交互作用。然而，我们应该注意到，事实上，蜘蛛痣的存在是一个内生二元时依协变量，因为它的存在要求患者还活着。这意味着，对于结合血清胆红素和蜘蛛痣的效应的正确分析的联合模型，应该为两种纵向结果分别假定一个适当的混合效应子模型。有关分类内生时变协变量处理的更多信息，请参阅 5.7.2 节。然而，为了便于说明，我们在这里忽略了这一事实，并将蜘蛛痣视为外源协变量。第一步，我们需要构建一个长格式的数据集，如 3.5 节所示。例如，我们观察到，患者 3 有四次随访测量，在此期间，只有第二次和第四次有蜘蛛痣。start 和 stop 变量表示记录蜘蛛痣存在的时间区间的限，如果在相应时间区间结束时发生事件，则 event 变量等于 1，使用以下代码构造：特别是，请记住，在计数过程公式中，我们构建了区间 \\((\\mathtt{start},\\mathtt{stop}]\\)，附有一个重要的数学约束，即在 \\(t = \\mathtt{stop}\\) 时进行的计算利用在该 stop 时间之前已知的协变量数据。这正式刻画了这样一个事实：外源协变量假定为可预测过程（见 3.4 节）。例如，对于患者 3，我们得到结果为了拟合以蜘蛛痣作为外源时依协变量的联合模型，我们首先需要使用计数过程符号和上面构建的长格式数据来拟合相应的扩展 Cox 模型。此外，由于 jointModel() 需要区分长格式生存数据中患者的测量，因此患者 id 变量应作为 cluster() 组件包含在 coxph() 的 formula 参数的右侧，此外，参数 model 应设置为 TRUE。然后，调用 jointModel() 的方式与之前我们看到的示例相同，将拟合的扩展 Cox 模型作为 survObject 参数提供。我们应该提到，同时具有外源和内生时变协变量的联合模型仅在样条近似的基线风险函数下可用，也就是说，对于 jointModel() 的 method 参数，仅 \"spline-PH-aGH\" 这一选项可用，例如18分析表明，血清胆红素仍然是最重要的预测因素，而没有足够的证据支持蜘蛛的存在与复合事件的风险有关。联合模型与将血清胆红素和蜘蛛视为外源协变量的扩展的 Cox 模型的比较表明，Cox 模型低估了血清胆红素对数与事件风险之间的关联强度。特别是，两个模型下血清胆红素对数的风险比的 95% 置信区间表明，Cox 模型的上限仅略大于联合模型的点估计。","code":"> pbc <- pbc2[c(\"id\", \"serBilir\", \"drug\", \"year\", \"years\",\n                \"status2\", \"spiders\")]\n> pbc[pbc$id == \"3\", ]\n\n   id serBilir      drug      year    years status2 spiders\n12  3      1.4 D-penicil 0.0000000 2.770781       1      No\n13  3      1.1 D-penicil 0.4818749 2.770781       1     Yes\n14  3      1.5 D-penicil 0.9966050 2.770781       1      No\n15  3      1.8 D-penicil 2.0342788 2.770781       1     Yes> pbc$start <- pbc$year\n> splitID <- split(pbc[c(\"start\", \"years\")], pbc$id)\n> pbc$stop <- unlist(lapply(splitID, \n                            function (d) c(d$start[-1], d$years[1]) ))\n> pbc$event <- with(pbc, ave(status2, id,\n                             FUN = function (x) c(rep(0, length(x)-1), x[1]) ))> pbc[pbc$id == \"3\", ]\n\n   id serBilir      drug      year    years status2 spiders     start      stop event\n12  3      1.4 D-penicil 0.0000000 2.770781       1      No 0.0000000 0.4818749     0\n13  3      1.1 D-penicil 0.4818749 2.770781       1     Yes 0.4818749 0.9966050     0\n14  3      1.5 D-penicil 0.9966050 2.770781       1      No 0.9966050 2.0342788     0\n15  3      1.8 D-penicil 2.0342788 2.770781       1     Yes 2.0342788 2.7707809     1> tdCox.pbc <- coxph(Surv(start, stop, event) ~ drug * spiders + cluster(id),\n                     data = pbc, x = TRUE, model = TRUE)> jointFit8.pbc <- jointModel(lmeFit.pbc, tdCox.pbc, timeVar = \"year\",\n                              method = \"spline-PH-aGH\")\n> summary(jointFit8.pbc)\n\n. . .\nEvent Process\n                           Value Std.Err z-value p-value\ndrugD-penicil            -0.1382  0.3732 -0.3704  0.7111\nspidersYes                0.6112  0.3212  1.9030  0.0570\ndrugD-penicil:spidersYes  0.2494  0.4640  0.5374  0.5910\nAssoct                    1.2774  0.1297  9.8480 <0.0001\n. . .> tdCox2.pbc <- coxph(Surv(start, stop, event) ~ drug * spiders +\n                        log(serBilir), data = pbc)\n> tdCox2.pbc\n\nCall:\ncoxph(formula = Surv(start, stop, event) ~ drug * spiders + log(serBilir),\ndata = pbc)\n                           coef exp(coef) se(coef)      z    p\ndrugD-penicil            -0.310     0.734   0.3029 -1.023 0.31\nspidersYes                0.419     1.521   0.2681  1.563 0.12\nlog(serBilir)             1.073     2.924   0.0932 11.514 0.00\ndrugD-penicil:spidersYes  0.294     1.341   0.3890  0.755 0.45\n. . .> exp(confint(jointFit8.pbc, parm = \"Event\"))\n\n                             2.5 %      est.   97.5 %\ndrugD-penicil            0.4286782 0.7970458 1.481956\nspidersYes               0.9338199 1.6050347 2.758708\ndrugD-penicil:spidersYes 0.5839259 1.2896589 2.848341\nAssoct                   2.7297554 3.3950626 4.222521\n\n> exp(confint(tdCox2.pbc))\n\n                             2.5 %   97.5 %\ndrugD-penicil            0.4051017 1.328313\nspidersYes               0.8990105 2.571901\nlog(serBilir)            2.4362185 3.510596\ndrugD-penicil:spidersYes 0.6257112 2.874938"},{"path":"chap5.html","id":"sec5-3","chapter":"第 5 章 标准联合模型的扩展","heading":"5.3 分层相对风险模型","text":"在许多实际例子中，假定手头样本来自同质群体是不现实的。例如，在多中心临床试验中，由于患者群体和转诊模式不同，不同的中心预期具有不同的基线生存函数。处理此类相对风险模型的标准扩展是考虑多个层。具体来说，假设患者分成不同的层，每一层都有自己的基线风险函数，但回归系数 \\(\\gamma\\) 和 \\(\\alpha\\) 的值是相同的。在分层模型下，属于第 \\(k\\) 层的患者 \\(\\) 的风险由下式给出\\[\\begin{align}\nh_{ik}(t)=h_{0k}(t)\\exp\\{\\gamma^\\top w_i+\\alpha m_i(t)\\}\n\\tag{5.9}\n\\end{align}\\]其中 \\(h_{0k}(t)\\) 表示第 \\(k\\) 层的基线风险函数。在 B 样条近似的基线风险函数 (4.4) 下，包 JM 提供了具有分层相对风险子模型的联合模型。对于 PBC 数据集，根据肝肿大的存在与否，使用分层生存子模型拟合了一个联合模型：从 Event Process 的输出可以看出，对于患有和不患有肝肿大的患者，假定了不同的样条系数。如果我们想拟合一个具有多个分层因素的模型，这些因素应该作为 strata() 函数中的额外参数包括在内，例如，为了对是否存在肝肿大和性别进行分层，代码应该是 strata(hepatomegaly, sex)。分层 Cox 模型不会直接估计分层的重要性不同，与之相反，在具有样条近似的基线风险函数的分层相对风险模型中，可以利用正式的统计推断程序来检验分层是否提高了模型的拟合度。这是因为在样条方法中，我们使用灵活且参数化的模型来估计基线风险，而在 Cox 模型中，基线风险则完全未指定。要使这种统计检验有效，唯一的要求是对数基线风险函数的 B 样条近似的结在各层之间应该是相同的，这是 JM 包中的默认设置。可以通过拟合非分层联合模型并使用函数 anova() 将其与分层模型进行比较来执行似然比检验。要执行相应的 Wald 检验，可以使用函数 wald.strata() 直接构造适当的对比矩阵。对于拟合到 PBC 数据的分层联合模型，该检验表明，有强有力的证据表明，患有和不患有肝肿大的患者亚组的潜在生存曲线之间存在差异。分层相对风险模型的标准公式假定每个协变量的效应在各层之间是恒定的。然而，这并不总是合理的，因为在许多情况下，一些协变量可能对每个层产生不同的效应。例如，在一项多中心随机试验中，每个中心的患者群体相似，可以合理地假定年龄对各个中心的效应是相同的，但假定治疗效应在各个中心是一致的，则可能不那么可靠。为考虑这一点，我们对模型 (5.9) 进行了扩展以考虑层与协变量的交互作用，即\\[\\begin{align}\nh_i(t)=h_{0k}(t)\\exp\\{\\gamma_k^\\top w_i+\\alpha_km_i(t)\\}\n\\tag{5.10}\n\\end{align}\\]其中，不仅基线风险函数 \\(h_{0k}(t)\\)，而且回归系数 \\(\\gamma_k\\) 和 \\(\\alpha_k\\) 现在都取决于层 \\(k\\)。在下面的例子中，我们通过在线性预测因子中包含药物和血清胆红素与肝肿大的交互项，从而扩展了拟合到 PBC 数据的分层联合模型。如 5.1.1 节所示，可以使用 interFact 参数将这些项添加到生存子模型中我们观察到，在有肝肿大和无肝肿大的患者中，复合事件的风险与血清胆红素之间的关联强度在统计学上没有差异。根据如下的近似公式可计算出两个肝肿大组的边际生存函数\\[\\mathcal{S}(t)=\\int\\mathcal{S}_i(t\\mid b_i;\\hat{\\theta})p(b_i;\\hat{\\theta})db_i\\approx n^{-1}\\sum_i\\mathcal{S}_i(t\\mid\\hat{b}_i;\\hat{\\theta})\\]其中 \\(\\hat b_i\\) 表示随机效应的经验贝叶斯估计（见 4.5 节），并在图 5.5 中描绘了分层联合模型 jointFit9.pbc。生成图形的相应语法只需简单调用 plot() 方法，即函数 plot() 可用于生成拟合联合模型的诊断图。参数 指定我们希望得到的第三个图，它对应于边际生存函数。plot() 函数的其他选项在第 6 章进行说明。","code":"> lmeFit.pbc <- lme(log(serBilir) ~ drug * (year + I(year^2)),\n                    random = ~ year + I(year^2) | id, data = pbc2)\n> coxFit2.pbc <- coxph(Surv(years, status2) ~ drug + strata(hepatomegaly),\n                       data = pbc2.id, x = TRUE)\n> jointFit9.pbc <- jointModel(lmeFit.pbc, coxFit2.pbc, timeVar = \"year\",\n                              method = \"spline-PH-aGH\")\n> summary(jointFit9.pbc)\n\n. . .\nEvent Process\n                        Value Std.Err z-value p-value\ndrugD-penicil          0.0430  0.1676  0.2564  0.7977\nAssoct                 1.2944  0.0941 13.7569 <0.0001\nbs1(hepatomegaly=No)  -3.6329  0.7995 -4.5441 <0.0001\nbs2(hepatomegaly=No)  -5.7295  1.1899 -4.8152 <0.0001\nbs3(hepatomegaly=No)  -4.2104  1.0735 -3.9220  0.0001\nbs4(hepatomegaly=No)  -5.4117  0.8184 -6.6129 <0.0001\nbs5(hepatomegaly=No)  -4.4717  0.7222 -6.1917 <0.0001\nbs6(hepatomegaly=No)  -4.1540  0.7493 -5.5439 <0.0001\nbs7(hepatomegaly=No)  -3.5401  1.5440 -2.2929  0.0219\nbs8(hepatomegaly=No)  -9.5100  3.2027 -2.9694  0.0030\nbs9(hepatomegaly=No)  -0.7835  1.8491 -0.4237  0.6718\nbs1(hepatomegaly=Yes) -4.3688  0.5872 -7.4397 <0.0001\nbs2(hepatomegaly=Yes) -4.7974  0.6758 -7.0990 <0.0001\nbs3(hepatomegaly=Yes) -3.6573  0.6603 -5.5388 <0.0001\nbs4(hepatomegaly=Yes) -4.1759  0.5591 -7.4686 <0.0001\nbs5(hepatomegaly=Yes) -3.1475  0.6051 -5.2013 <0.0001\nbs6(hepatomegaly=Yes) -5.3199  0.9146 -5.8164 <0.0001\nbs7(hepatomegaly=Yes) -1.1899  1.6687 -0.7131  0.4758\nbs8(hepatomegaly=Yes) -6.0432  3.3647 -1.7961  0.0725\nbs9(hepatomegaly=Yes) -7.2148  6.9496 -1.0382  0.2992\n. . .> wald.strata(jointFit9.pbc)\n\n    Wald Test for Stratification Factors\n\nX^2 = 24.1423, df = 9, p-value = 0.0041\nalternative hypothesis: spline coefficients for the baseline risk\n    function are not equal among strata> coxFit3.pbc <- coxph(Surv(years, status2) ~ drug * hepatomegaly +\n                         strata(hepatomegaly), data = pbc2.id, x = TRUE)\n> jointFit10.pbc <- update(jointFit9.pbc, survObject = coxFit3.pbc,\n                           interFact = list(value = ~ hepatomegaly, data = pbc2.id))\n> summary(jointFit10.pbc)\n\n. . .\nEvent Process\n                                Value Std.Err z-value p-value\ndrugD-penicil                 -0.0896  0.2869 -0.3123  0.7548\ndrugD-penicil:hepatomegalyYes  0.2289  0.3529  0.6486  0.5166\nAssoct                         1.1974  0.1329  9.0099 <0.0001\nAssoct:hepatomegalyYes         0.1854  0.1871  0.9910  0.3217\n. . .> plot(jointFit9.pbc, which = 3)"},{"path":"chap5.html","id":"sec5-4","chapter":"第 5 章 标准联合模型的扩展","heading":"5.4 潜类别联合模型","text":"与 5.3 节中介绍的分层联合模型相关的另一类联合模型是潜类别联合模型 (latent class joint model) (Proust-Lima et al., 2009; Lin et al., 2004, 2002). 这种联合模型背后的动机也是为了解释人群中可能存在的异质性。然而，与分层联合模型相反，潜类别联合模型假定构成人群的亚群是潜在的，从某种意义上讲，即任何观测协变量都没有捕获异质性。为了定义潜类别联合模型，我们假定有 \\(G\\) 个亚群构成了我们的原始人群，并引入了未观测类别指示符 \\(c_i=1,\\ldots,G\\)，用于表示第 \\(\\) 个受试者所属亚群。这些模型在以下一组条件独立性假设下工作：\\[\\begin{aligned}p(T_i,\\delta_i,y_i\\mid c_i=g,b_i;\\theta)\\quad&=\\quad p(T_i,\\delta_i\\mid c_i=g;\\theta)p(y_i\\mid c_i=g,b_i;\\theta)\\\\p(y_i\\mid c_i=g,b_i;\\theta)\\quad&=\\quad\\prod_jp\\{y_i(t_{ij})\\mid c_i=g,b_i;\\theta\\}\\end{aligned}\\]具体来说，这些模型假设纵向结果中重复测量之间的相关性由随机效应 \\(b_i\\) 捕获，而事件时间和纵向过程之间的关联由共享潜类别指标 \\(c_i\\) 解释。与假定同一组随机效应 \\(b_i\\) 来解释两类关联（见 4.3.2）的经典联合模型相比，它允许更灵活的关联结构，从而更有优势。在上述条件独立性假设下，潜类别联合模型的一般定义涉及以下子模型\\[\\begin{align}\n\\left\\{\\begin{array}{ccc}h_i(t\\mid c_i=g)&=&h_{0g}(t)\\exp(\\gamma_g^\\top w_i),\\\\\\{y_i(t)\\mid c_i=g\\}&=&x_i^\\top(t)\\beta_g+z_i^\\top(t)b_{ig}+\\varepsilon_i(t),&\\varepsilon_i(t)\\sim\\mathcal{N}(0,\\sigma^2)\\tag{5.11}\\\\\\Pr(c_i=g)&=&\\exp(\\lambda_g^\\top u_i)\\Big/\\sum_{l=1}^G\\exp(\\lambda_l^\\top u_i),\\end{array}\\right.\n\\end{align}\\]其中我们假定不同潜在组的患者具有不同的纵向演变和不同的事件风险。最后一个等式指定了潜类别隶属概率的多项式子模型，其中 \\(u_i\\) 表示与这些概率相关的协变量向量，对应的回归系数向量 \\(\\lambda^\\top=(\\lambda_1^\\top,\\ldots,\\lambda_G^\\top)\\)，其中令 \\(\\lambda_G=0\\) 用于可识别性。随机效应 \\(b_{ig}\\sim\\mathcal{N}(\\mu_g,\\sigma_g^2D)\\) 也假定为特定于潜类别的，尽管为了计算稳定性，通常假定它们的协方差阵仅通过标量方差参数 \\(\\sigma^2_g\\) 取决于 \\(c_i\\)。潜类别联合模型的上述指定的一个有利副产品是，该模型下的对数似然采用以下形式\\[\\begin{aligned}\\ell(\\theta)&=\\quad\\sum_{=1}^n\\log\\biggl\\{\\sum_{g=1}^G\\Pr(c_i=g;\\theta)h_i(T_i\\mid c_i=g;\\theta)^{\\delta_i}\\mathcal{S}_i(T_i\\mid c_i=g;\\theta)\\\\&\\quad\\times\\int\\biggl[\\prod_jp\\{y_i(t_{ij})\\mid c_i=g,b_i;\\theta\\}\\biggr]p(b_i\\mid c_i=g;\\theta)db_i\\biggr\\}\\\\&=\\quad\\sum_{=1}^n\\log\\biggl\\{\\sum_{g=1}^G\\Pr(c_i=g;\\theta)h_i(T_i\\mid c_i=g;\\theta)^{\\delta_i}\\mathcal{S}_i(T_i\\mid c_i=g;\\theta)\\\\&\\quad\\times p(y_i\\mid c_i=g;\\theta)\\biggr\\}\\end{aligned}\\]与经典联合模型相比，它更容易计算，因为它既不需要数值积分 (4.2) 中生存函数的计算，也不需要 (4.9) 中似然的计算。具体来说，生存函数定义中的前一个积分具有封闭形式（然而，也取决于基线风险函数的模型），因为它不涉及纵向过程的任何时依分量，并且后一个关于随机效应的积分也有一个封闭的解，因为它只需要条件纵向模型 \\(p(y_i\\mid c_i=g,b_i)\\) 和随机效应密度 \\(p(b_i\\mid c_i=g)\\)，即我们在 2.2.1 节中看到，在两个分量的正态性假设下会得到多元高斯分布。然而，潜类别联合模型的一个问题是对数似然可能有多个局部极大值，因此建议使用不同的初值集合对模型进行多次修正并考察其收敛情况。显然，这个问题实际上几乎抵消了不必数值逼近积分的计算优势，即使重新拟合模型比拟合经典的联合模型更为简单，但仍然是一项计算密集型任务。此外，由于合适的潜类别数并非事先已知，这也加剧了该问题。因此，需要用越来越多的类来拟合几个模型，并在统计上选择对数据拟合最好的类别数。这种选择通常基于信息准则进行。潜类别联合模型的另一个问题是，关联结构的可解释性不是直接的。具体来说，在潜类别公式下，没有一组参数可以直接量化纵向结果与事件风险之间的关联强度，而在许多情况下，这是主要的研究兴趣。因此，当研究目标在于揭示目标人群中潜在异质性时，这类联合模型非常有用，但当直接感兴趣的是提供两个过程关联机制背后的简单解释时，这种联合模型就不那么有用了。在 R 中，潜类别联合模型使用来自 lcmm 包 (Proust-Lima et al., 2011) 的函数 Jointlcmm() 进行拟合。函数 jointModel() 需要首先分别拟合线性混合效应和生存模型，而函数 Jointlcmm() 则需要提供单独的公式参数来指定模型的不同部分。具体来说，参数 fixed 和 random 接受定义纵向子模型的固定和随机效应部分的公式，参数 survival 接受指定生存子模型的公式。基线风险函数的模型在参数 hazard 中指定，并且其对潜类别的依赖性通过参数 hazardtype 指定。最后两个公式参数 classmb 用于指定 (5.11) 中多项式模型的线性预测变量，以及 mixture 用于指定纵向模型中固定效应的哪些分量被假定取决于 \\(c_i\\)。最后，使用参数 ng 指定我们想要拟合具有两个潜类别的联合模型。作为说明，我们对艾滋病数据集进行潜类别联合模型分析。对于纵向部分，我们在固定部分中包括时间和处理的主效应，在随机部分中包括随机截距和随机斜率：\\[\\begin{aligned}\\{y_i(t)\\mid c_i=g\\}=\\beta_{0g}+\\beta_{1g}t+\\beta_{2g}\\mathtt{ddI}_i+b_{0i}+b_{1i}t+\\varepsilon_i(t)\\end{aligned}\\]我们假设固定部分中的两个协变量都是与类相关的。对于生存子模型，我们假定特定于潜类别的基线风险函数和治疗效应\\[\\begin{aligned}h_i(t\\mid c_i=g)=h_{0g}(t)\\exp(\\gamma_g\\mathtt d\\mathtt d\\mathtt I_i)\\end{aligned}\\]假定特定于潜类别的基线风险函数是分段常数，其中六个结置于事件时间分布的等距百分位处。最后，在潜类别所属的多项式模型中，我们假定每个患者属于某一类的先验概率取决于治疗，\\[\\Pr(c_i=g)=\\frac{\\exp(\\lambda_{0g}+\\lambda_{1g}\\mathtt{ddI}_i)}{\\sum_{l=1}^G\\exp(\\lambda_{0l}+\\lambda_{1l}\\mathtt{ddI}_i)}\\]我们拟合了四个联合模型，分别具有两个、三个、四个和五个潜在类。AIC 和 BIC 值如表 5.2 所示。我们观察到两个信息准则之间存在很大的分歧，即 AIC 随着类别数的增加而稳步下降，并倾向于五类模型，而根据 BIC 的最优模型是三类模型。文献中的实证研究表明，BIC 更常常指出具有正确潜在子群数量的模型 (Proust-Lima et al., 2009; Lin et al., 2004). 根据此建议，我们在这里选择具有三个潜类别的模型。拟合该模型的相应语法是19当前版本的包 (1.4-3) 不会自动排除缺失数据，也不会为因子创建哑变量；要求用户手动地进行这些操作。我们观察到，对于某些参数，如纵向部分的斜率，类别之间似乎存在显著差异。图 5.6 中给出了拟合的潜类别联合模型的更有用的总结，该总结说明了三个潜在类的 CD4 细胞计数平方根的平均纵向演变和相应的生存概率。很明显，该模型已经确定了三个不同的亚群。特别地，有一组人群的 CD4 细胞计数水平相对较高且稳定，同时该组人群的无事件生存率也很高；第二组人群在基线时的 CD4 细胞计数水平适中，但恶化速度较快，其生存率在 12 个月内保持较高水平，随后则开始恶化；第三组人群的 CD4 细胞计数水平一开始就很低，随着时间的推移也呈恶化趋势，但恶化速度较第二组慢，且生存率最低。使用拟合模型，我们还可以得出样本中患者的后验分类。这是通过取后验概率的最大值来实现的\\[\\begin{aligned}\\Pr(c_i&=g\\mid T_i,\\delta_i,y_i;\\hat{\\theta})=\\\\&\\frac{\\Pr(c_i=g;\\hat{\\theta})h_i(T_i\\mid c_i=g;\\hat{\\theta})^{\\delta_i}\\mathcal{S}_i(T_i\\mid c_i=g;\\hat{\\theta})p(y_i\\mid c_i=g;\\hat{\\theta})}{\\sum_{l=1}^G\\Pr(c_i=l;\\hat{\\theta})h_i(T_i\\mid c_i=l;\\hat{\\theta})^{\\delta_i}\\mathcal{S}_i(T_i\\mid c_i=l;\\hat{\\theta})p(y_i\\mid c_i=l;\\hat{\\theta})}\\end{aligned}\\]即利用下式，受试者 \\(\\) 被分到组 \\(g\\)\\[\\hat{c}_i=\\arg\\max\\{\\Pr(c_i=g\\mid T_i,\\delta_i,y_i;\\hat{\\theta})\\}\\]这在精神上类似于 4.5 节描述的随机效应的经验贝叶斯估计。函数 postrob() 提供了这些概率和后验分类的总结第一类的受试者最多，第二类和第三类旗鼓相当。此外，每类的后验概率的高均值表明，对于大多数患者来说，类别分配是明显的。","code":"> aidsLC <- aids[c(\"patient\", \"CD4\", \"obstime\", \"drug\", \"Time\",\n                   \"death\")]\n> aidsLC$drug <- c(aidsLC$drug) - 1\n> aidsLC <- aidsLC[complete.cases(aidsLC), ]\n> lcjmFit.aids <- Jointlcmm(fixed = CD4 ~ obstime + drug,\n                            mixture = ~ obstime + drug, random = ~ obstime,\n                            classmb = ~ drug, subject = \"patient\", ng = 3, data = aidsLC,\n                            survival = Surv(Time, death) ~ mixture(drug),\n                            hazard = \"6-quant-piecewise\", hazardtype = \"Specific\")\n> summary(lcjmFit.aids)\n\n. . .\nMaximum Likelihood Estimates:\n  \n *** Fixed effects in the class-membership model:\n  \n                 coef        Se     Wald      p-value\nintercept.1 1.8912850 0.2356334  8.026389 9.992007e-16\nintercept.2 0.3775695 0.3119579  1.210322 2.261554e-01\ndrug.1     -0.6168468 0.3035905 -2.031838 4.217002e-02\ndrug.2     -0.8335000 0.4339825 -1.920584 5.478412e-02\n\n *** Parameters in the proportional hazard model:\n  \n                     coef         Se          Wald      p-value\nSurvparm1.1  1.747639e-01 0.01646778 10.6124741143 0.0000000000\nSurvparm2.1  1.782748e-01 0.01677411 10.6279729057 0.0000000000\nSurvparm3.1  2.062439e-01 0.01959739 10.5240505260 0.0000000000\nSurvparm4.1  2.844710e-01 0.02605193 10.9193841945 0.0000000000\nSurvparm5.1  2.198851e-01 0.02175457 10.1075390872 0.0000000000\nSurvparm1.2  7.526344e-02 0.04256313  1.7682780280 0.0770144353\nSurvparm2.2  3.012569e-04 0.07864486  0.0038305980 0.9969436325\nSurvparm3.2  3.665944e-04 0.06464400  0.0056709724 0.9954752429\nSurvparm4.2  2.870907e-05 0.09353904  0.0003069207 0.9997551127\nSurvparm5.2  1.780141e-01 0.05341236  3.3328258143 0.0008596875\nSurvparm1.3  1.362064e-02 0.02924385  0.4657608996 0.6413866556\nSurvparm2.3 -1.206343e-02 0.02625369 -0.4594945788 0.6458790442\nSurvparm3.3  2.222956e-02 0.04658752  0.4771569046 0.6332503962\nSurvparm4.3 -2.229832e-06 0.01390939 -0.0001603113 0.9998720901\nSurvparm5.3  2.780617e-06 0.01333678  0.0002084923 0.9998336472\ndrug.1       2.812830e-01 0.15896172  1.7695017612 0.0768101771\ndrug.2      -3.926780e-01 0.95139505 -0.4127391266 0.6797977551\ndrug.3       3.603278e+00 4.20624352  0.8566498424 0.3916384310\n\n *** Fixed effects in the longitudinal model:\n\n                    coef         Se       Wald      p-value\nintercept.1  4.551630773 0.20975801 21.6994374 0.000000e+00\nintercept.2 11.972989698 0.61157635 19.5772609 0.000000e+00\nintercept.3 15.385329326 0.50439205 30.5027194 0.000000e+00\nobstime.1   -0.135112532 0.01743427 -7.7498246 9.214851e-15\nobstime.2   -0.333670590 0.04413843 -7.5596394 4.041212e-14\nobstime.3    0.007688527 0.03161613  0.2431837 8.078631e-01\ndrug.1       0.192050725 0.27237012  0.7051094 4.807422e-01\ndrug.2      -0.364419280 0.90278937 -0.4036592 6.864633e-01\ndrug.3      -1.034312273 0.56991841 -1.8148427 6.954808e-02\n\n *** Variance-covariance matrix of the random-effects:\n           intercept    obstime\nintercept  4.9981340\nobstime   -0.2400626 0.01740501\n\n                                 coef         se\n*** Residual standard error: 1.733895 0.04703051> postprob(lcjmFit.aids)\n\nPosterior classification based on longitudinal and time-to-event data:\n       class1     class2     class3\nN 335.0000000 62.0000000 70.0000000\n%   0.7173448  0.1327623  0.1498929\n\nPosterior classification table:\n     --> mean of posterior probabilities in each class\n         prob1  prob2   prob3\nclass1 0.96900 0.0300 0.00148\nclass2 0.09600 0.8310 0.07340\nclass3 0.00484 0.0641 0.93100\n\nPosterior classification based only on longitudinal data:\n       class1    class2     class3\nN 338.0000000 61.000000 68.0000000\n%   0.7237687  0.130621  0.1456103"},{"path":"chap5.html","id":"sec5-5","chapter":"第 5 章 标准联合模型的扩展","heading":"5.5 多个事件","text":"","code":""},{"path":"chap5.html","id":"sec5-5-1","chapter":"第 5 章 标准联合模型的扩展","heading":"5.5.1 竞争风险","text":"正如我们在 1.3 节中提到的，在纵向研究中，我们经常为研究中的患者收集丰富的随访信息。这可能包括几个生物标志物，但也可能包括多个失败时间。在这里，我们重点研究单一内生时依协变量与不同类型失效时间之间的关联（对多种生物标志物的考虑推迟到 5.8 节）。例如，在我们之前对 PBC 数据集的所有分析中，我们都考虑了血清胆红素与复合事件（死亡或移植之较先者）风险之间的关系。然而，区分这两个事件，并研究协变量如何影响移植风险，以及它们如何影响死亡风险，也可能是有意义的。在这种情况下，传统的分析类型之一是原因别风险回归 (cause-specific hazard regression)，它为每个竞争事件假定了单独的相对风险模型 (Putter et al., 2007). 当分析中只需要考虑基线和外源时依协变量时，我们可以为每种原因拟合单独的 Cox 模型，将另一种原因的失效视为删失观测。然而，当我们对内生时依协变量与任一原因的风险之间的关联感兴趣时，应改用联合建模方法。具体来说，Elashoff et al. (2008), Williamson et al. (2008), Hu et al. (2009) 和 Huang et al. (2011) 研究了这种类型的联合模型。为了处理不同的失效类型，我们需要扩展生存过程的符号。具体来说，假定 \\(K\\) 个不同的失效原因，我们令 \\(T_{i1}^*,\\ldots,T_{iK}^*\\) 分别表示它们的真实失效时间。第 \\(\\) 个受试者的观测数据由观测事件时间 \\(T_i = \\min(T_{i1}^*,\\ldots,T_{iK}^*, C_i)\\) 组成，其中 \\(C_i\\) 表示删失时间，事件指示符 \\(\\delta_i\\) 取值 \\(\\delta_i \\\\{0, 1,\\ldots, K\\}\\)，其中 \\(0\\) 对应于删失，\\(1,\\ldots,K\\) 为相应的竞争事件。对于 \\(K\\) 个原因中的每一个，如上所述，我们假定标准相对风险模型\\[\\begin{align}\nh_{ik}(t)=h_{0k}(t)\\exp\\{\\gamma_k^\\top w_i+\\alpha_km_i(t)\\}\n\\tag{5.12}\n\\end{align}\\]其中包括基线协变量 \\(w_i\\) 和纵向标志物当前值 \\(m_i(t)\\) 的效应。通过为观测纵向响应 \\(y_i(t)\\) 建立合适的混合效应模型来完成联合模型的指定。此类联合模型的估计基于与单一失效类型的联合模型完全相同的原理。唯一的区别在于事件过程的似然部分的构造。具体采用以下形式\\[\\begin{align}\np(T_i,\\delta_i&\\mid b_i;\\theta_t,\\beta)=\\prod_{k=1}^K\\Bigl[h_{0k}(T_i)\\exp\\{\\gamma_k^\\top w_i+\\alpha_km_i(T_i)\\}\\Bigr]^{(\\delta_i=k)}\\\\&\\times\\exp\\biggl(-\\sum_{k=1}^K\\int_0^{T_i}h_{0k}(s)\\exp\\bigl\\{\\gamma_k^\\top w_i+\\alpha_km_i(s)\\bigr\\}ds\\biggr)\n\\tag{5.13}\n\\end{align}\\]从计算的角度来看，通过将数据转换为竞争风险长格式（与 3.5 节的计数过程长格式不同），可以更容易地计算这部分似然。具体来说，如果有 \\(K\\) 个竞争事件，如果有 K 个竞争事件，则每个受试者都有 \\(K\\) 行，每行对应一个可能的原因。每个受试者的观测事件时间 \\(T_i\\) 重复 \\(K\\) 次，有两个指示变量，一个指示原因，另一个指示对应的事件类型是否是发生的事件类型。标准生存数据集，其中每个患者包含一行，例如可以使用函数 crLong() 轻松转换为竞争风险长格式。它接受标准格式的生存数据作为主要参数，每个患者只有一行、状态变量的名称以及该状态变量中与删失相对应的水平。对于上述 PBC 数据集中的前 5 名患者，操作如下请注意，每名患者现在由两行代表（对应于两种可能的研究中止原因：死亡和移植），每个患者的两行中的变量 years 是相同的，变量 CR 表示特定行的原因，如果相应事件发生，则变量 status2 等于 1。使用长格式数据，我们可以轻松计算 \\(p(T_i,\\delta_i\\mid b_i;\\theta_t,\\beta)\\) 的对数，如上所述，如上所述，只需将变量 CR 视为分层因子，并纳入该变量与其他所有我们希望包含在原因别相对风险模型线性预测器中的变量的交互项，使用 status2 作为事件变量，并计算对应于第 \\(\\) 个受试者的行之和。例如，我们将联合模型拟合到 PBC 数据集，将移植和死亡视为单独的竞争事件。对于纵向胆红素相应，我们假定 5.1.1 节的线性混合效应模型，每个治疗组的平均效应不同，每个患者呈时间上的二次演变。\\[\\begin{array}{rcl}y_i(t)&=&\\beta_0+\\beta_1\\mathtt{D}\\text{-}\\mathtt{pnc}_i+\\beta_2t+\\beta_3t^2+\\beta_4\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t\\}+\\beta_5\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t^2\\}\\\\&&+b_{i0}+b_{i1}t+b_{i2}t^2+\\varepsilon_i(t)\\end{array}\\]调用函数 lme() 以拟合该模型对于事件过程，我们假定原因别相对风险模型\\[\\left\\{\\begin{array}{rcl}h_{i1}(t)&=&h_{01}(t)\\exp\\bigl\\{\\gamma_{11}\\mathtt{D}\\text{-}\\mathtt{pnc}_i+\\gamma_{12}\\mathtt{Age}_i+\\alpha_1m_i(t)\\bigr\\},\\\\h_{i2}(t)&=&h_{02}(t)\\exp\\bigl\\{(\\gamma_{11}+\\gamma_{21})\\mathtt{D}\\text{-}\\mathtt{pnc}_i+(\\gamma_{12}+\\gamma_{22})\\mathtt{Age}_i\\\\&&+(\\alpha_1+\\alpha_2)m_i(t)\\bigr\\}.\\end{array}\\right.\\]在此参数化中，参数 \\(\\gamma_11},\\gamma_{12}\\) 和 \\(\\alpha_1\\) 分别表示治疗、年龄和血清胆红素对数对移植风险的效应，\\(\\gamma_21},\\gamma_{22}\\) 和 \\(\\alpha_2\\) 分别表示治疗、年龄和血清胆红素对数的对死亡风险的额外效应。例如，\\(\\gamma_{21} = 0\\) 意味着移植和死亡的治疗风险比相同。使用数据集 pbc2.idCR，我们通过包含年龄和治疗与变量 CR 的交互项来拟合相应的原因别 Cox 回归，并进一步使用 strata() 将 CR 包含为分层变量在拟合该模型时出现的关于设计矩阵奇异性的警告信息，是因为我们同时包含了 CR 的主效应，并将其视为一个分层因素。鉴于我们为两种原因分别设定了不同且完全未指定的基础风险函数，因此无法准确确定 CR 对风险的主效应。与之前一样，我们通过将混合效应模型和 Cox 模型作为 jointModel() 函数的主要参数来拟合联合模型。interFact 用于在生存子模型的线性预测因子中另外包含对数血清胆红素 \\(m_i(t)\\) 的主效应及其与失效类型指标 CR 的交互作用。结果表明，当前血清胆红素对数值每增加一个单位，患者的移植风险就会增加为原来的 2.8 倍 (95% CI: 1.9, 4)，并且死亡风险会增加为原来的 4.4 倍 (95% CI: 3.5, 5.4). 此外，我们观察到年轻患者接受移植的风险较高（年龄减少一年对应的风险比为 1.09），而老年患者的死亡风险较高（年龄增加一年对应的风险比为 1.07）。此外，我们在 5.1 节中介绍的不同参数化也可用于原因别风险回归模型 (5.12) 的指定中。例如，我们通过允许死亡和移植风险额外依赖于血清胆红素对数真实轨迹的斜率 \\(m'_i (t) = dm_i(t)/dt\\)，从而扩展了拟合到上述 PBC 数据集的竞争风险联合模型。具体来说，原因别风险模型采用以下形式：\\[\\left\\{\\begin{array}{rcl}h_{i1}(t)&=&h_{01}(t)\\exp\\bigl\\{\\gamma_{11}\\mathtt{D}\\text{-}\\mathtt{pnc}_i+\\gamma_{12}\\mathtt{Age}_i+\\alpha_{11}m_i(t)+\\alpha_{12}m_i'(t)\\bigr\\}\\\\h_{i2}(t)&=&h_{02}(t)\\exp\\bigl\\{(\\gamma_{11}+\\gamma_{21})\\mathtt{D}\\text{-}\\mathtt{pnc}_i+(\\gamma_{12}+\\gamma_{22})\\mathtt{Age}_i\\\\&&+(\\alpha_{11}+\\alpha_{21})m_i(t)+(\\alpha_{12}+\\alpha_{22})m_i'(t)\\bigr\\}.\\end{array}\\right.\\]其中，如 5.1.3 节所示，\\(m'_i(t)\\) 由下式给出\\[m_i'(t)=\\beta_2+2\\beta_3t+\\beta_4\\mathtt{D}\\text{-}\\mathtt{pnc}_i+2\\beta_5\\{\\mathtt{D}\\text{-}\\mathtt{pnc}_i\\times t\\}+b_{i1}+2b_{i2}t\\]为了将这些项纳入我们的分析中，我们利用了 jointModel() 的 derivForm 和 interFact 参数提供的功能。更具体地说，为了将术语 \\(m'_i (t)\\) 包含在原因别风险模型的线性预测器中，我们使用选项 \"\" 作为 parameterization 参数，并提供指定 derivForm 参数中 \\(m'_i (t)\\) 的固定效应和随机效应部分的列表。该列表采用以下形式为进一步指定真实轨迹斜率的效应对于两种失效类型是不同的，我们在 interFact 参数提供的列表中添加组件 slope。与 value 组件类似，slope 组件是一个公式，指定时依斜率 \\(m'_i (t)\\) 的交互因子。具体来说，对 jointModel() 的调用是summary() 方法提供了详细的输出我们观察到，对数血清胆红素真实轨迹斜率值的单位增加导致移植的对数风险比为 1.4 (95%CI: -1.7, 4.5)，而相应的死亡的对数风险比为 2.2 (95%CI: 1, 3.3). 为了在统计上检验包括时依斜率 \\(m'_i(t)\\) 的扩展是否提高了竞争风险联合模型的拟合度，我们使用函数 anova() 在模型 jointFit11pbc 和 jointFit12pbc 之间进行了似然比检验\\(p\\) 值的水平表明，有足够有力的证据来否定零假设，即 \\(\\alpha_{12}=\\alpha_{22}=0\\)。","code":"> head(pbc2.id[c(\"id\", \"years\", \"status\")], 5)\n\n  id     years       status\n1  1  1.095170         dead\n2  2 14.152338        alive\n3  3  2.770781         dead\n4  4  5.270507         dead\n5  5  4.120578 transplanted> pbc2.idCR <- crLong(pbc2.id, statusVar = \"status\",\n                      censLevel = \"alive\", nameStrata = \"CR\")\n> head(pbc2.idCR[c(\"id\", \"years\", \"status\", \"CR\", \"status2\")], 10)\n\n    id     years       status           CR status2\n1    1  1.095170         dead         dead       1\n1.1  1  1.095170         dead transplanted       0\n2    2 14.152338        alive         dead       0\n2.1  2 14.152338        alive transplanted       0\n3    3  2.770781         dead         dead       1\n3.1  3  2.770781         dead transplanted       0\n4    4  5.270507         dead         dead       1\n4.1  4  5.270507         dead transplanted       0\n5    5  4.120578 transplanted         dead       0\n5.1  5  4.120578 transplanted transplanted       1> lmeFit.pbc <- lme(log(serBilir) ~ drug * (year + I(year^2)),\n                    random = ~ year + I(year^2) | id, data = pbc2)> coxFit4.pbc <- coxph(Surv(years, status2) ~ (drug + age) * CR + strata(CR), \n                       data = pbc2.idCR, x = TRUE)> jointFit11.pbc <- jointModel(lmeFit.pbc, coxFit4.pbc,\n                               timeVar = \"year\", method = \"spline-PH-aGH\", CompRisk = TRUE,\n                               interFact = list(value = ~ CR, data = pbc2.idCR))\n> summary(jointFit11.pbc)\n\n. . .\nEvent Process\n                       Value Std.Err z-value p-value\ndrugD-penicil        -0.3968  0.3874 -1.0243  0.3057\nage                  -0.0860  0.0245 -3.5105  0.0004\ndrugD-penicil:CRdead  0.3756  0.4240  0.8860  0.3756\nage:CRdead            0.1523  0.0259  5.8795 <0.0001\nAssoct                1.0223  0.1920  5.3246 <0.0001\nAssoct:CRdead         0.4490  0.2185  2.0554  0.0398\n. . .> dform <- list(fixed = ~ I(2*year) * drug, indFixed = 3:6,\n                random = ~ I(2*year), indRandom = 2:3)> jointFit12.pbc <- update(jointFit11.pbc,\n                           parameterization = \"both\", derivForm = dform,\n                           interFact = list(value = ~ CR, slope = ~ CR, data = pbc2.idCR))> summary(jointFit12.pbc)\n\n. . .\nEvent Process\n                       Value Std.Err z-value p-value\ndrugD-penicil        -0.3208  0.3914 -0.8196  0.4125\nage                  -0.0808  0.0241 -3.3516  0.0008\ndrugD-penicil:CRdead  0.2569  0.4263  0.6026  0.5468\nage:CRdead            0.1307  0.0255  5.1252 <0.0001\nAssoct                0.9905  0.2109  4.6976 <0.0001\nAssoct:CRdead         0.2787  0.2346  1.1878  0.2349\nAssoct.s              1.4072  1.6032  0.8777  0.3801\nAssoct.s:CRdead       0.7498  1.7097  0.4386  0.6610\n. . .> anova(jointFit11.pbc, jointFit12.pbc)\n                   AIC     BIC  log.Lik   LRT df p.value\njointFit11.pbc 3866.90 4005.39 -1896.45\njointFit12.pbc 3858.07 4004.05 -1890.04 12.83  2  0.0016"},{"path":"chap5.html","id":"sec5-5-2","chapter":"第 5 章 标准联合模型的扩展","heading":"5.5.2 复发事件","text":"在上一节中，我们重点讨论了纵向标志物与不同失效类型之间的关联。然而，当受试者可能多次发生一种事件，也会出现类似的情况。例如，在 1.2.2 节介绍的艾滋病研究中，患者提供了 CD4 细胞计数的测量，但也检查了机会性疾病的发生情况。在这种情况下，我们可以推测，较高的 CD4 细胞计数与机会性疾病的较低风险相关，反过来，较高的 CD4 细胞计数和较低的机会性病风险与较低的死亡风险相关。为了在统计上验证这一假设，需要假定一个模型，该模型将三种结果联系起来，即机会性疾病的发生、死亡和 CD4 细胞计数。当就诊过程提供信息时，会遇到另一种情况，在我们的分析中可能需要考虑复发事件。具体来说，正如我们在 4.3.2 节中所指出的，我们进行的联合建模分析基于这样的假设：患者就诊之间经过的时间可能仅取决于观测纵向病史。然而，在实践中这一假设可能不成立，例如，当重症阶段的患者比轻症阶段的患者更频繁地去医院就诊时。在这种情况下，即使我们可能主要对终止事件感兴趣，也需要对就诊过程进行建模，以获得有效的结果。Hougaard (2000), Therneau Grambsch (2000) 对可用于分析复发事件时间的不同建模方法进行了详细描述，而 Liu et al. (2008) 以及 Liu Huang (2009) 提出了将复发和终止事件与纵向内生协变量相结合的联合模型。为了引入可以处理这类生存数据的联合模型，我们令 \\(U_{ik},k=1,\\ldots,K_i\\) 表示从研究开始的复发事件时间，\\(d_{ik}\\) 表示受试者 \\(\\) 的第 \\(k\\) 次复发事件的指示符。对于终止事件，我们使用与前几节相同的符号，\\(T_i\\) 表示观测终止事件时间，取真实终止事件时间 \\(T^*_i\\) 和删失时间 \\(C_i\\) 的最小值。终止事件指示符类似地定义为 \\(\\delta_i=(T^*_i\\leq C_i)\\)。我们假定纵向标志物 \\(m_i(t)\\) 的真实值与复发事件和终止事件的风险都有关。具体地，我们为这两个过程假定了两个独立的相对风险模型\\[\\begin{align}\n\\left\\{\\begin{array}{rcl}r_i(t)&=&r_0(t)\\exp\\bigl\\{\\gamma_r^\\top w_{ri}+\\alpha_rm_i(t)+\\mathrm v_i\\bigr\\}\\\\h_i(t)&=&h_0(t)\\exp\\bigl\\{\\gamma_h^\\top w_{hi}+\\alpha_hm_i(t)+\\zeta\\mathrm v_i\\bigr\\}\\end{array}\\right.\n\\tag{5.14}\n\\end{align}\\]其中 \\(w_{ri}\\) 表示影响复发事件风险的基线协变量，\\(w_{hi}\\) 表示影响终止事件风险的协变量，分别具有相应的回归系数 \\(\\gamma_r\\) 和 \\(\\gamma_h\\)。类似地，参数 \\(\\alpha_r\\) 和 \\(\\alpha_h\\) 分别度量纵向标志物的当前值与复发和终末事件风险之间的关联强度。项 \\(\\mathrm v_i\\) 是一种随机效应（在生存分析中也称为脆弱项），解释了复发事件的相关性。\\(\\mathrm v_i\\) 值较高的受试者发生复发事件的风险较高。终止事件相对风险模型中的参数 \\(\\zeta\\) 度量终止事件的风险与复发事件的风险的关联强度。这类联合模型的似然的定义是基于一组扩展的条件独立性假设。具体说，假定这三个过程，即复发事件过程、终止事件过程和纵向过程，在给定两组随机效应 \\(\\{b_i,\\mathrm v_i\\}\\) 的情况下是独立的。此外，假定受试者 \\(\\) 的复发事件时间在给定其脆弱项 \\(\\mathrm v_i\\) 的条件下是独立的，并且如前所述，假定纵向响应 \\(y_i(t_{ij})\\) 在给定 \\(b_i\\) 的情况下独立。正式地，这些陈述由以下方程组给出\\[\\begin{aligned}\np(T_i,\\delta_i,U_i,d_i,y_i\\mid b_i,\\text{v}_i;\\theta)\\quad =&\\quad p(T_i,\\delta_i\\mid b_i,\\text{v}_i;\\theta)  \\\\\n&\\times p(U_{ik},d_{ik}\\mid b_i,\\mathrm{v}_i;\\theta)p(y_i\\mid b_i;\\theta), \\\\\np(U_i,d_i\\mid b_i\\text{v}_i;\\theta)\\quad  =&\\quad\\prod_kp(U_{ik},d_{ik}\\mid b_i,\\text{v}_i;\\theta),\\quad  \\\\\np(y_i\\mid b_i;\\theta)\\quad  =&\\quad\\prod_jp\\{y_i(t_{ij})\\mid b_i;\\theta\\}\n\\end{aligned}\\]其中 \\(U_i^\\top=(U_{i1},\\ldots,U_{ik})\\)，类似地，\\(d_i^\\top=(d_{i1},\\ldots,d_{ik})\\)。在这些假设下，第 \\(\\) 个受试者对似然的贡献为\\[\\begin{aligned}p(T_i,\\delta_i,y_i;\\theta)=\\int p(T_i,\\delta_i\\mid b_i,\\text{v}_i;\\theta)p(U_{ik},d_{ik}\\mid;\\theta)p(y_i\\mid b_i;\\theta)p(b_i;\\theta)db_i\\end{aligned}\\]其中 \\(p(T_i,\\delta_i\\mid b_i,\\mathrm{v}_i;\\theta)\\) 和 \\(p(y_i\\mid b_i;\\theta)p(b_i;\\theta)\\) 的公式分别类似于 (4.10) 和 (4.11)，并且\\[\\begin{aligned}p(U_{ik},d_{ik}\\mid;\\theta)=\\int p(U_{ik},d_{ik}\\mid\\text{v}_i;\\theta)p(\\text{v}_i;\\theta)d\\text{v}_i\\end{aligned}\\]其中\\[\\begin{aligned}p(U_{ik},d_{ik}\\mid v_i;\\theta)&=\\prod_{k=1}^{K_i}\\bigl[r_0(U_{ik})\\exp\\{\\gamma_r^\\top w_{ri}+\\alpha_rm_i(U_{ik})+v_i\\}\\bigr]^{\\delta_{ik}}\\\\&\\times\\exp\\biggl(-\\int_0^{U_{ik}}r_0(s)\\exp\\{\\gamma_r^\\top w_{ri}+\\alpha_rm_i(s)+v_i\\}ds\\biggr)\\end{aligned}\\]通过假定脆弱项 \\(\\mathrm v_i\\) 的适当分布来完成模型的指定。脆弱模型语境中的标准选择是假定 \\(\\log(\\mathrm v_i)\\) 具有均值为 1、方差为 \\(\\sigma_\\mathrm v\\) 的 Gamma 分布，因为它可得到事件时间边际分布的闭合表达式 (Duchado Janssen, 2008). 然而，在上面提出的联合模型公式下，由于关于时间的积分\\[\\int_0^{U_{ik}}r_0(s)\\exp\\{\\gamma_r^\\top w_{ri}+\\alpha_rm_i(s)+v_i\\}ds\\]也涉及项 \\(m_i(s)\\)，从而 \\(p(U_{ik},d_{ik}\\mid\\upsilon_i;\\theta)\\) 定义中关于脆弱项 \\(\\mathrm v_i\\) 的积分不再有解析解，因此需要数值积分方法来计算它。然而，如果我们选择随机效应参数化，则可以减轻这一要求，类似于 5.1.5 节给出的参数化\\[\\begin{aligned}r_i(t)=r_0(t)\\exp(\\gamma_r^\\top w_{ri}+\\alpha_r^\\top b_i+\\mathrm{v}_i)\\end{aligned}\\]那么关于时间的积分有如下形式\\[\\begin{aligned}&p(U_{ik},d_{ik}\\mid v_i;\\theta)\\\\&=\\quad\\frac{\\Gamma(d_i+\\vartheta)\\prod_k\\left\\{r_0(U_{ik})\\exp(\\gamma_r^\\top w_{ri}+\\alpha_r^\\top b_i+\\mathrm{v}_i)\\right\\}^{d_{ik}}}{\\left\\{\\vartheta+\\sum_kR_0(U_{ik})\\exp(\\gamma_r^\\top w_{ri}+\\alpha_r^\\top b_i+\\mathrm{v}_i)\\right\\}^{d_i+\\vartheta}\\sigma_\\mathrm{v}^\\vartheta\\Gamma(\\vartheta)}\\end{aligned}\\]其中 \\(\\Gamma(\\cdot)\\) 表示 Gamma 函数，\\(d_i=\\sum_kd_{ik}\\) 且 \\(\\vartheta=1/\\sigma_\\mathrm{v}\\)。然而，当假定 \\(\\mathrm v_i\\) 服从另一种分布（例如正态分布）时，该性质便不复存在。","code":""},{"path":"chap5.html","id":"sec5-6","chapter":"第 5 章 标准联合模型的扩展","heading":"5.6 加速失效时间模型","text":"当 (4.1) 中的比例性假设失效时，事件时间数据的另一种建模框架是加速失效时间 (accelerated failure time, AFT) 模型。该模型指定预测变量对失效时间起乘性作用或对对数失效时间起加性作用。这个想法是，预测变量改变受试者沿时间轴前进的速率，即对失效时间进行加速或减速 (Kalbfleisch Prentice, 2002). AFT 模型通常定义为\\[\\begin{align}\n\\log T_i^*=\\gamma^\\top w_i+\\sigma_t\\varepsilon_{ti}\n\\tag{5.15}\n\\end{align}\\]其中参数 \\(\\sigma_t\\) 是尺度参数，并假定 \\(\\varepsilon_{ti}\\) 服从特定分布。参数 \\(\\gamma_j\\) 表示对应协变量 \\(w_{ij}\\) 单位变化的对数失效时间的预期变化。同样，\\(w_{ij}\\) 的单位变化会使失效时间变为原来的 \\(\\exp(\\gamma_j)\\) 倍。误差项 \\(\\varepsilon_{ti}\\) 分布的标准选项是正态分布、Student’s t 分布和极值分布。最后一个选项对应于 \\(T^*_i\\) 的 Weibull 分布，这是唯一同时接受相对风险和 AFT 模型公式的分布（当然还有其特例：指数）。为了将时依协变量纳入该框架，我们令 \\(\\mathcal S_0\\) 表示一个绝对连续的基线生存函数，并且我们遵循 Cox Oake (1984, Section 5.2) 的公式\\[\\left\\{\\int_0^{T^*}\\exp\\{\\gamma^\\top w+\\alpha m(s)\\}ds\\right\\}\\sim\\mathcal{S}_0\\]这可用受试者 \\(\\) 的风险函数重写为\\[\\begin{align}\n\\begin{array}{rcl}h_i(t\\mid\\mathcal{M}_i(t),w_i)&=&h_0\\big(V_i(t)\\big)\\exp\\bigl\\{\\gamma^\\top w_i+\\alpha m_i(t)\\bigr\\}\\end{array}\n\\tag{5.16}\n\\end{align}\\]其中\\[V_i(t)=\\int_0^t\\exp\\bigl\\{\\gamma^\\top w_i+\\alpha m_i(s)\\bigr\\}ds\\]与 (4.1) 类似，基线风险函数 \\(h_0(\\cdot)\\) 可采用特定的参数形式或灵活地建模。与 (4.1) 相比，(5.16) 的一个重要区别是，在前者中，假定整个协变量史 \\(\\mathcal M_i(t)\\) 会影响特定于受试者的风险 \\(h_i(t)\\)，因为 \\(h_0(\\cdot)\\) 是在 \\(V_i(t)\\) 处计算的。在 AFT 模型中引入时变协变量时的一个问题是，由于参数 \\(\\alpha\\) 涉及 (5.16) 右侧的两项，解释变得更加复杂。具体来说，具有协变量史 \\(\\mathcal M_i(t)\\) 的受试者的生存函数为 \\(\\mathcal{S}_i\\big(t\\big|\\mathcal{M}_i(t)\\big)=\\mathcal{S}_0\\big(V_i(t)\\big)\\)，这意味着相对于 \\(\\mathcal S_0\\)，该个体的生命进程在时间表上加速为 \\(V_i(t)\\)。更多信息请参阅 Cox Oakes (1984, Section 5.2). 在联合建模框架内，Tseng et al. (2005) 讨论了加速失效时间模型。目前，包 JM 中唯一可用的 AFT 模型是 Weibull 模型，即在模型 (5.16) 中 \\(h_0(t)=\\sigma_tt^{\\sigma_t-1}\\)，使用选项 \"weibull-AFT-aGH\" 作为 method 参数。我们应注意，当考虑时依协变量时，Weibull 模型在相对风险和 AFT 两种形式下均可表达的独特性质将不复存在。也就是说，拟合具有 Weibull 相对风险子模型的联合模型的参数 method 的默认选项 \"weibull-PH-aGH\" 不等于 \"weibull-AFT-aGH\"。我们比较了艾滋病数据集的两种公式。对于纵向结果，我们假定一个线性混合模型，具有固定的时间效应及其与治疗的交互作用，以及随机截距和随机时间效应。在生存子模型中，我们包括治疗、性别和 AZT （即患者是否有 AZT 不耐受或失效）的效应由于这些模型不是嵌套的，我们只能使用信息准则进行比较，因此我们在调用 anova() 时指定不希望执行似然比检验我们观察到，这两个模型实际上提供了相同的数据拟合，具有几乎无法区分的对数似然值。两种公式下事件过程的参数估计及其标准误如表 5.3 所示。正如预期的那样，在两种公式下，相同协变量的回归系数估计具有不同的值和相反的符号，因为它们实际上有不同的解释。","code":"> lmeFit.aids <- lme(CD4 ~ obstime + obstime:drug,\n                     random = ~ obstime | patient, data = aids)\n> coxFit.aids <- coxph(Surv(Time, death) ~ drug + gender + AZT,\n                       data = aids.id, x = TRUE)\n> jointFit3.aids <- jointModel(lmeFit.aids, coxFit.aids,\n                               timeVar = \"obstime\")\n> jointFit4.aids <- update(jointFit3.aids, method = \"weibull-AFT-aGH\")> anova(jointFit3.aids, jointFit4.aids, test = FALSE)\n                   AIC     BIC  log.Lik df\njointFit3.aids 8674.95 8728.86 -4324.48\njointFit4.aids 8675.79 8729.69 -4324.90  0"},{"path":"chap5.html","id":"sec5-7","chapter":"第 5 章 标准联合模型的扩展","heading":"5.7 分类纵向结果的联合模型","text":"","code":""},{"path":"chap5.html","id":"sec5-7-1","chapter":"第 5 章 标准联合模型的扩展","heading":"5.7.1 广义线性混合模型 (GLMM)","text":"到目前为止，我们主要关注连续的纵向反应。然而，在许多情况下，兴趣可能在于分类纵向结果与事件发生时间之间的关联。在这种情况下，很明显，不能再使用线性混合模型 (4.5) 了，因为它只适用于正态分布的生物标志物。目前常用于分析离散重复测量数据的另一种框架是广义线性混合模型 (Breslow Clayton, 1993). 其广泛适用的两个主要原因是，它是广义线性模型 (McCullagh Nelder, 1989) 对多元数据的直接扩展，并且目前可以在广泛的软件包中拟合这类模型。为定义 GLMMs，令 \\(y_i(t)\\) 表示受试者 \\(\\) 在时间 \\(t\\) 的结果测量，\\(=1,\\ldtos,n\\)。我们还用 \\(y_i=\\{y_{ij},j=1,\\ldots,n_i\\}\\) 表示第 \\(\\) 个受试者的观测纵向响应的 \\(n\\) 维向量。取条件于 \\(q_b\\) 维随机效应向量 \\(b_i\\) （假定其独立地从 \\(\\mathcal N (0, D)\\) 中抽取），结果 \\(y_{ij}\\) 与如下所示的指数分布族的密度独立\\[\\begin{align}\np(y_i\\mid b_i;\\beta,\\varphi)=\\exp\\left\\{\\sum_{j=1}^{n_i}\\Bigl[y_{ij}\\psi_{ij}(b_i)-c\\{\\psi_{ij}(b_i)\\}\\Bigr]\\Bigr/(\\varphi)-d(y_{ij},\\varphi)\\right\\}\n\\tag{5.17}\n\\end{align}\\]其中 \\(\\psi_{ij} (b_i)\\) 以及 \\(\\varphi\\) 分别表示指数族中的自然参数和散度参数，\\(c(\\cdot),d(\\cdot)\\) 和 \\((\\cdot)\\) 是指定指数族成员的已知函数。这些函数的不同选择包括二项分布、泊松分布、Gamma 分布和正态分布等。在随机效应条件下，通过定义 \\(y_i(t)\\) 的均值来完成模型的指定\\[\\begin{align}\nE(y_i(t)\\mid b_i)=\\frac{\\partial c\\{\\psi_i(t\\mid b_i)\\}}{\\partial\\psi_i(t\\mid b_i)}=g^{-1}\\{x_i^\\top(t)\\beta+z_i^\\top(t)b_i\\}\n\\tag{5.18}\n\\end{align}\\]其中 \\(g(\\cdot)\\) 表示已知的单调连接函数，\\(x_i(t)\\) 和 \\(z_i(t)\\) 分别表示固定效应 \\(\\beta\\) 和随机效应 \\(b_i\\) 的设计向量。由于正态分布是指数族分布的一员，4.1.2 节的线性混合模型是广义线性混合模型的特例，其中 \\(p(y_i\\mid b_i;\\beta,\\varphi)\\) 表示带有方差参数 \\(\\varphi\\) 的正态密度，\\(g(\\cdot)\\) 是单位连接函数。GLMM 参数的传统估计方法之一是边际最大似然法。这与 2.2.1 节介绍的线性混合模型的处理方式非常相似。具体来说，GLMM 的边际对数似然函数形如\\[\\begin{align}\n\\ell(\\beta,\\varphi,D)\\quad&=\\quad\\sum_{=1}^np(y_i;\\beta,\\varphi,D)\\\\&=\\quad\\sum_{=1}^n\\int\\prod_{j=1}^{n_i}p(y_{ij}\\mid b_i;\\beta,\\varphi)p(b_i;D)db_i\n\\tag{5.19}\n\\end{align}\\]其中我们利用这样的事实，即假定 \\(y_{ij}\\) 条件独立于随机效应 \\(b_i\\)。一般地，对于 (5.19) 中的定义中的 \\(n\\) 个积分，没有可用的解析表达式。众所周知，这些积分可以解析地求解的例外是线性混合模型，在该模型下，正如我们在 2.2.1 节所看到的，边际密度 \\(p(y_i;\\beta,\\varphi,D)\\) 是具有均值 \\(X_i\\beta\\) 和方差-协方差阵 \\(V_i=Z_iDZ_i^\\top+\\varphi\\mathrm{}_{n_i}\\) 的 \\(n\\) 维正态密度。另一个可以形成解析解的例子是 probit-normal 模型 (Molenberghs Verbeke, 2005, Chapter 13). 然而，在这种情况下，仍然需要积分近似，但用于计算多元正态累积分布函数。当无法解析地求解时，4.3.5 节中讨论的联合模型的数值积分技术也可直接应用于广义线性混合模型。事实上应注意，有关近似这些积分的方法文献浩如烟海，联合模型中使用的许多数值积分技术最初都是应用于广义线性混合模型的。（自适应）高斯正交积分规则的性能已经由 Pinheiro Chao (2006), Pinheiro Bates (1995) 以及 Lesaffre Spiessens (2001) 研究过，专为广义线性混合模型设计的 Monte Carlo 积分已由 Booth Hobert (1999) 以及 McCulloch (1997) 开发，Laplace 近似已由 Raudenbush et al. (2000) 讨论过。选定数值积分技术后，便可通过 EM 算法（将随机效应视为“缺失数据”）或 Newton 型算法来获取最大似然估计。关于 GLMMs 框架的更详细介绍，以及替代估计程序和推断的讨论，请参考 Molenberghs Verbeke (2005, Chapters 14 16)，Fitzmaurice et al. (2004, Chapters 12 13) 以及 Diggle et al. (2002, Chapter 9).","code":""},{"path":"chap5.html","id":"sec5-7-2","chapter":"第 5 章 标准联合模型的扩展","heading":"5.7.2 将离散重复测量与生存结合","text":"在 5.7.1 节中介绍的 GLMM 框架下为分类纵向结果定义联合模型相当简单。具体来说，利用与连续响应情况相同的条件独立性假设 (4.7) 和 (4.8)，以随机效应 \\(b_i\\) 为条件，我们可以为纵向和事件时间过程定义单独的子模型。原则上，我们到目前为止看到的所有扩展也都直接适用于分类标志物。遵循 5.1 节允许不同参数化的模型公式，纵向和生存结果的联合模型的一般定义是\\[\\left\\{\\begin{array}{rcl}p(y_i(t)\\mid b_i)&=&\\exp\\biggl\\{\\sum_{j=1}^{n_i}\\Bigl[y_{ij}\\psi_{ij}(b_i)-c\\{\\psi_{ij}(b_i)\\}\\Bigr]\\Bigr/(\\varphi)-d(y_{ij},\\varphi)\\biggr\\},\\\\m_i(t)&=&E(y_i(t)\\mid b_i)=g^{-1}\\{x_i^\\top(t)\\beta+z_i^\\top(t)b_i\\},\\\\b_i&\\sim&\\mathcal{N}(0,D),\\\\h_i(t)&=&h_0(t)\\exp\\bigl[\\gamma^\\top w_{i1}+f\\{m_i(t-c),b_i,w_{i2};\\alpha\\}\\bigr],\\end{array}\\right.\\]其中，如 4.1.1 节所述，\\(h_0(\\cdot)\\) 可以假定为已知分布（例如 Weibull）的风险函数，可以使用阶跃函数或样条法灵活地对其建模，也可以完全不指定。请注意，由于正态分布是指数族的成员，因此该定义还包括第 4 章中给出的连续纵向响应的标准联合模型。不同参数下的关联参数向量 \\(\\alpha\\) 的解释与 5.1.1 - 5.1.5 节中的解释相同。例如，对于标准的当前值的参数化，\\[f\\{m_i(t-c),b_i,w_{i2};\\alpha\\}=\\alpha m_i(t)\\]参数 \\(\\alpha\\) 度量事件在时间 \\(t\\) 的风险与同一时间点纵向结果期望值之间的关联强度。此外，前几节提出的其他扩展，即在相对风险模型中纳入分层因素或用加速失效时间模型替换相对风险模型，在条件独立性假设下也很容易纳入模型。最大似然估计以类似于对连续纵向响应的联合模型所述的方式进行。具体差事，对数似然函数形如\\[\\begin{aligned}\n\\ell(\\theta)\\quad= & \\quad\\sum_{=1}^n\\int p(T_i,\\delta_i\\mid b_i;\\theta)\\Big\\{\\prod_{j=1}^{n_i}p(y_{ij}\\mid b_i;\\theta)\\Big\\}p(b_i;\\theta)db_i  \\\\\n=&\\quad\\displaystyle\\sum_{=1}^n\\int\\left\\{h_0(T_i)\\exp\\bigl[\\gamma^\\top w_{i1}+f\\{m_i(T_i-c),b_i,w_{i2};\\alpha\\}\\bigr]\\right\\}^{\\delta_i}  \\\\\n&\\quad\\times\\exp\\biggl(-\\int_0^{T_i}h_0(s)\\exp\\bigl[\\gamma^\\top w_{i1}+f\\{m_i(s-c),b_i,w_{i2};\\alpha\\}\\bigr]ds\\biggr) \\\\\n&\\quad\\left.\\times\\exp\\left\\{\\sum_{j=1}^{n_i}\\left[y_{ij}\\psi_{ij}(b_i)-c\\{\\psi_{ij}(b_i)\\}\\right]\\right/(\\varphi)-d(y_{ij},\\varphi)\\right\\} \\\\\n&\\quad\\times(2\\pi)^{-q_b/2}\\mathrm{det}(D)^{-1/2}\\exp\\!\\left(-b_i^\\top D^{-1}b_i/2\\right)db_i.\n\\end{aligned}\\]\\(\\ell(\\theta)\\) 关于 \\(\\theta\\) 的最大化需要数值积分和优化程序的结合。具体来说，对数似然定义中关于随机效应的积分以及如下的生存函数中关于时间的积分都需要数值积分。\\[\\begin{aligned}\\mathcal{S}_i(t\\mid\\mathcal{M}_i(t),w_i)=\\exp\\!\\left(-\\int_0^th_0(s)\\exp\\!\\left[\\gamma^\\top w_{i1}+f\\{m_i(s-c),b_i,w_{i2};\\alpha\\}\\right]ds\\right)\\end{aligned}\\]在相关文献中，与用于连续结果的联合模型相比，用于分类纵向反应的联合模型受到的关注相对较少。研究的重点要么是处理离散纵向反应中的非随机脱落 (Pulktenis et al., 1998; Albert Follmann, 2000; Albert et al., 2002)，要么是研究分类纵向过程与删失事件时间数据之间的关联结构 (Fucett et al., 1998; Rizopoulos et al., 2008; Yao, 2008; Li et al., 2010).","code":""},{"path":"chap5.html","id":"sec5-8","chapter":"第 5 章 标准联合模型的扩展","heading":"5.8 多个纵向结果的联合模型","text":"在 5.7.1 节的 GLMMs 框架下，扩展联合模型以处理多个纵向结果（连续的或分类的）在数学上是简单的。具体地说，为了在统一的框架内适应不同类型的纵向响应，我们假定了一个多元广义线性混合效应模型，其中在给定随机效应向量 \\(b_{iq}\\) 的条件下第 \\(q\\) 个结果的条件分布是指数族 (5.17) 的成员，线性预测器为\\[g_q\\{E(y_{iq}(t)\\mid b_{iq})\\}=x_{iq}^\\top(t)\\beta+z_{iq}^\\top(t)b_{iq}\\]其中，\\(g(\\cdot)\\)，如 5.7.1 节所属，表示已知的一对一单调连接函数，而 \\(y_{iq}(t)\\) 表示第 \\(\\) 个受试者在时间点 \\(t\\) 的第 \\(q\\) 个纵向结果值。此外，我们扩展了 4.3.2 节的条件独立性假设集，并额外假定随机效应也考虑了 \\(q\\) 个纵向结果之间的关联。具体地，我们假定\\[\\begin{aligned}p(T_i,\\delta_i,y_i\\mid b_i;\\theta)&=\\quad p(T_i,\\delta_i\\mid b_i;\\theta)~p(y_i\\mid b_i;\\theta),\\\\p(y_i\\mid b_i;\\theta)&=\\quad\\prod_qp(y_{iq}\\mid b_{iq};\\theta_q),\\quad\\text{以及}\\\\p(y_{iq}\\mid b_{iq};\\theta_q)&=\\quad\\prod_jp\\{y_{iq}(t_{ij})\\mid b_{iq};\\theta_q\\},\\end{aligned}\\]其中 \\(y_i^\\top=(y_{i1}^\\top,\\dots,y_{iQ}^\\top),\\quad y_{iq}^\\top=(y_{iq}(t_{i1}),\\dots,y_{iq}(t_{in_i}))\\) 以及 \\(b_i^\\top=(b_{i1}^\\top,\\ldots,b_{iQ}^\\top)\\)。假定随机效应的完整向量 \\(b_i\\) 服从均值为零、协方差阵为 \\(D\\) 的多元正态分布。生存过程的相对风险模型的线性预测器类似地进行扩展以适应所有纵向结果，即\\[h_{}(t)=h_{0}(t)\\exp\\Bigl[\\gamma^{\\top}w_{i1}+\\sum_{q}f_{q}\\{m_{iq}(t-c),b_{iq},w_{i2q};\\alpha_{q}\\}\\Bigr]\\]这里再次使用了 5.1 节的一般公式，以便明确指出，我们以前看到的所有扩展在原则上也适用于多元联合模型。多元联合模型的估计是通过最大化相应对数似然函数来进行的，该对数似然函数在形式上非常类似于 5.7.2 节给出的分类纵向响应的对数似然函数。事实上，唯一的区别是在多元模型下的纵向部分的密度\\[\\begin{array}{rcl}p(y_i\\mid b_i;\\theta)&=&\\exp\\biggl\\{\\sum_{q=1}^Q\\sum_{j=1}^{n_{iq}}\\Bigl[y_{ij,q}\\psi_{ij,q}(b_{iq})-c_q\\{\\psi_{ij,q}(b_{iq})\\}\\Bigr]\\Bigr/a_q(\\varphi_q)\\\\&&-d_q(y_{ij,q},\\varphi_q)\\biggr\\},\\end{array}\\]其中，我们显式地表示定义指数族的各个成员的函数 \\(c_q(\\cdot),d_q(\\cdot)\\) 以及 \\(a_q(\\cdot)\\) 依赖于 \\(q\\)，这意味着我们可以同时处理连续和分类纵向响应。尽管从一元到多元联合模型的扩展相对简单，但由于需要对随机效应进行数值积分，拟合多元联合模型的主要实际问题是计算复杂性。具体地说，由于我们假定每个结果具有不同的随机效应集，因此当纵向结果的数量 \\(Q\\) 不太小时，显然随机效应向量的维度显著增加。当在一些结果中，特定于受试者的纵向曲线是非线性的，从而需要更高维度的随机效应向量时，问题会更严重。Rizopoulos Ghosh(2011), Chi Ibrahim(2006)，Brown et al. (2005) 和 Lin et al. (2002) 已经考虑了这种类型的多元联合模型。Proust-Lima et al. (2009) 提出了一种减少计算负担的替代方法。他们假定了一个多元联合模型，在该模型中，纵向结果认为是单个潜过程 \\(\\Lambda_i(t)\\) 的实现，该潜过程是在连续时间内定义的，代表驱动了观测纵向轨迹的共同未观测因素。更具体地说，该模型采用以下形式\\[\\left\\{\\begin{array}{ccl}\\Lambda_i(t)&=&x_i^\\top(t)\\beta+z_i^\\top(t)b_i\\\\g_q\\big\\{E(y_{iq}(t)\\mid b_i)\\big\\}&=&\\Lambda_i(t)+u_{iq},\\end{array}\\right.\\]其中 \\(y_{}(t)\\) 属于指数族，\\(b_i \\sim \\mathcal N (0, D)\\)，如前所述。额外的随机效应 \\(u_{iq}\\) 假定呈正态分布，均值为零，方差为 \\(\\sigma^2_u\\) ，与 \\(b_i\\) 独立，即 \\(\\text{cov}(b_i , u_{iq}) = 0\\)，并且彼此独立，即对于 \\(q,q'=1,\\ldots,Q\\) 且 \\(q\\neq q'\\) 有 \\(\\text{cov}(u_{iq}, u_{iq'} ) = 0\\)。这些特定于受试者和标标志物的随机截距项表示未被共同潜结构 \\(\\Lambda_i(t)\\) 解释的个体间变异性。另一种看待这两组随机效应的方法是，\\(b_i\\) 解释了结果之间的关联以及每个结果重复测量中的相关性，\\(u_{iq}\\) 解释了 \\(b_i\\) 没有捕捉到的结果 \\(q\\) 的重复测量的额外相关性。潜过程方法的优点是，对于 \\(Q\\) 个结果中的每一个，只添加一个额外的随机效应 \\(u_{iq}\\)，从而保持随机效应向量的维数相对较低，并使该模型在计算上可行。但另一方面，缺点是假定的结果之间的关联结构更具限制性，因为只有一组随机效应 \\(b_i\\) 用于解释它们之间的相互关系。","code":""},{"path":"chap6.html","id":"chap6","chapter":"第 6 章 联合模型诊断","heading":"第 6 章 联合模型诊断","text":"前几章重点介绍了联合模型的不同公式和几个扩展。然而，当涉及到在实践中使用这些模型时，先决条件是验证模型的假设。评估这些假设的标准工具是残差图。当对纵向和生存结果分别建模时，残差的性质和特征已在文献中进行了广泛研究。然而，这一主题在联合建模文献中没有得到太多关注，除了 Dobson Henderson (2003) 的条件残差和 Rizopoulos et al. (2010) 的多重插补残差。在本章中，我们提出了纵向和事件时间结果的不同类型的残差，并对事件发生引起的非随机脱落的影响进行了深入的讨论。","code":""},{"path":"chap6.html","id":"sec6-1","chapter":"第 6 章 联合模型诊断","heading":"6.1 联合模型的残差","text":"","code":""},{"path":"chap6.html","id":"sec6-1-1","chapter":"第 6 章 联合模型诊断","heading":"6.1.1 纵向部分的残差","text":"在标准线性混合效应模型中，经常使用两种类型的残差，即特定于受试者的（条件）残差和边际（总体平均）残差（参见 Nobre Singer, 2007; Verbeke Molenberghs, 2000). 特定于受试者的残差旨在验证模型分层版本的假设，即\\[\\begin{align}\n\\left\\{\\begin{array}{rcl}y_i&=&X_i\\beta+Z_ib_i+\\varepsilon_i,\\\\b_i&\\sim&\\mathcal{N}(0,D),\\quad\\varepsilon_i\\sim\\mathcal{N}(0,\\sigma^2),\\end{array}\\right.\n\\tag{6.1}\n\\end{align}\\]定义为\\[\\begin{align}\nr_i^{ys}(t)=\\{y_i(t)-x_i^\\top(t)\\hat{\\beta}-z_i^\\top(t)\\hat{b}_i\\}\n\\tag{6.2}\n\\end{align}\\]有相应的标准化版本\\[r_i^{yss}(t)=\\{y_i(t)-x_i^\\top(t)\\hat{\\beta}-z_i^\\top(t)\\hat{b}_i\\}/\\hat{\\sigma}\\]其中，如前所述，\\(\\hat\\beta\\) 和 \\(\\hat\\sigma\\) 表示最大似然估计，而 \\(\\hat b_i\\) 表示随机效应的经验贝叶斯估计。这些残差预测了条件误差 \\(\\varepsilon_i(t)\\)，可用于检验等方差和正态性假设。另一方面，边际残差关注分层表示中隐含的 \\(y_i\\) 边际模型，即\\[\\begin{align}\n\\left\\{\\begin{array}{rcl}y_i&=&X_i\\beta+\\varepsilon_i^*,\\\\\\varepsilon_i^*&\\sim&\\mathcal{N}(0,Z_iDZ_i^\\top+\\sigma^2\\text{}_{n_i}),\\end{array}\\right.\n\\tag{6.3}\n\\end{align}\\]并定义为\\[\\begin{align}\nr_i^{ym}=y_i-X_i\\hat{\\beta}\n\\tag{6.4}\n\\end{align}\\]有相应的标准化版本\\[r_i^{ysm}=\\widehat{V}_i^{-1/2}(y_i-X_i\\hat{\\beta})\\]其中 \\(\\widehat{V}_i=Z_i\\widehat{D}Z_i^\\top+\\hat{\\sigma}^2\\mathrm{}_{n_i}\\) 表示 \\(y_i\\) 的边际协方差阵估计。这些边际残差 \\(r_i^{ym}\\) 预测了边际误差 \\(y_i − X_i\\beta = Z_ib_i+\\varepsilon_i\\) ，并可用于研究平均结构 \\(X_i\\beta\\) 的错误指定以及验证受试者内协方差结构 \\(V\\) 的假设。两种类型的残差也可用于检查联合模型纵向部分的假设。作为说明，我们为 4.2 节中拟合 AIDS 数据集的简单联合模型生成了残差图。具体来说，在纵向部分，我们假定 CD4 细胞计数平方根随时间表现为特定于受试者的线性演变，而在生存部分，我们控制治疗和真实 CD4 细胞计数的效应，并且假定分段常数基线风险函数。拟合模型对应的 R 代码是通过调用 jointModel 对象的 plot() 方法可直接获得一些基本的残差诊断图；对于我们的拟合联合模型，如图 6.1 所示，包括特定于受试者的残差与相应拟合值的图、特定于受试者的残差的 Q-Q 图以及事件过程的边际生存和累积风险函数。\n边际生存函数是使用如下近似公式估计的\\[\\mathcal{S}(t)=\\int\\mathcal{S}_i(t\\mid b_i;\\hat{\\theta})p(b_i;\\hat{\\theta})db_i\\approx n^{-1}\\sum_i\\mathcal{S}_i(t\\mid\\hat{b}_i;\\hat{\\theta})\\]边际累积风险函数简单计算为 \\(H(t)=-\\log\\mathcal S(t)\\)。通过首先计算感兴趣的特定类型的残差，然后根据相应的拟合值或协变量绘制残差，可以很容易地生成额外的残差图。作为 R 的标准操作，残差和拟合值可分别使用泛型函数 residuals() 和 fitted() 从拟合模型中提取。额外的参数 process 和 type 指定了我们想要计算残差的子模型（即纵向或生存），以及残差的类型（即特定于受试者、边际或标准化版本）。例如，下面的代码计算标准化边际残差 \\(r^{ysm}_i\\) 和边际拟合值 \\(X_i\\hat\\beta\\)。相应的散点图可以通过调用 R 的标准函数 plot() 来生成；但这里我们使用以下包装函数其中还包括了散点图的 loess 平滑以帮助我们轻松定位潜在的问题。结果图如图 6.2 所示。我们观察到，标准化边际残差关于拟合值的图形中，拟合的 loess 曲线显示出系统性趋势，较小的拟合值具有更多的正残差。这可能表明固定效应 \\(X\\) 的设计矩阵的形式不合适。我们将在 6.2 节回到这个问题。","code":"> lmeFit.aids <- lme(CD4 ~ obstime + obstime:drug,\n                     random = ~ obstime | patient, data = aids)\n> coxFit.aids <- coxph(Surv(Time, death) ~ drug, data = aids.id,\n                       x = TRUE)\n> jointFit.aids <- jointModel(lmeFit.aids, coxFit.aids,\n                              timeVar = \"obstime\", method = \"piecewise-PH-aGH\")> par(mfrow = c(2, 2))\n> plot(jointFit.aids)> resMargY.aids <- residuals(jointFit.aids, process = \"Longitudinal\",\n                             type = \"Marginal\")\n> fitMargY.aids <- fitted(jointFit.aids, process = \"Longitudinal\",\n                          type = \"Marginal\")> plotResid <- function (x, y, col.loess = \"black\", ...) {\n  plot(x, y, ...)\n  lines(lowess(x, y), col = col.loess, lwd = 2)\n  abline(h = 0, lty = 3, col = \"grey\", lwd = 2)\n}> plotResid(fitMargY.aids, resMargY.aids, xlab = \"Fitted Values\",\n            ylab = \"Marginal Residuals\")"},{"path":"chap6.html","id":"sec6-1-2","chapter":"第 6 章 联合模型诊断","heading":"6.1.2 生存部分的残差","text":"联合模型的相对风险子模型的标准残差类型是鞅残差 (martingale residuals). 他们基于事件时间数据的计数过程表示法（3.5 节简要介绍了），特别是特定于受试者的计数过程鞅，对于第 \\(\\) 个受试者定义为\\[\\begin{align}\nr_i^{tm}(t)& =\\quad N_i(t)-\\int_0^tR_i(s)h_i(s\\mid\\hat{\\mathcal{M}}_i(s);\\hat{\\theta})ds  \\\\\n&=\\quad N_i(t)-\\int_0^tR_i(s)\\hat{h}_0(s)\\exp\\{\\hat{\\gamma}^\\top w_i+\\hat{\\alpha}\\hat{m}_i(s)\\}ds\n\\tag{6.5}\n\\end{align}\\]其中 \\(N_i(t)\\) 是计数过程，表示在时间 \\(t\\) 时受试者 \\(\\) 的事件数，\\(R_i(t)\\) 是左连续风险过程，如果受试者 \\(\\) 在时间 \\(t\\) 处于风险中，则 \\(R_i(t) = 1\\) 否则 \\(R_i(t) = 0\\)。\\(\\hat{m}_i(t)=x_i^\\top(t)\\hat{\\beta}+z_i^\\top(t)\\hat{b}_i\\) 表示基线风险函数估计。这些残差背后的思想基于计数过程的 Doob-Meyer 分解，即将计数过程分解为补偿器 (compensator) 加上鞅过程，因此，鞅过程可看作是标准统计分解中残差项的等价物。简单来说，残差 \\(r^{tm}_i(t)\\) 可视为第 \\(\\) 个受试者在时间 \\(t\\) 时的观测事件数与基于拟合模型的同一时间的预期事件数之差。Barlow Prentice (1988) 以及 Therneau et al. (1990) 提供了使用鞅研究相对风险模型拟合度的理论框架。这些残差的主要用途是直接识别超额事件 (excess events)（即揭示模型拟合不佳的受试者）以及评估模型中是否使用了协变量的适当函数形式。与鞅残差相关的生存模型残差的另一种类型是 Cox-Snell 残差 (Cox Snell, 1968). 对于每个受试者，这些计算为在观测事件时间 \\(T_i\\) 处计算的累积风险函数估计，即\\[\\begin{align}\nr_i^{tcs}&=\\quad\\int_0^{T_i}h_i(s\\mid\\hat{\\mathcal{M}}_i(s);\\hat{\\theta})ds\\\\&=\\quad\\int_0^{T_i}\\hat{h}_0(s)\\exp\\{\\hat{\\gamma}^\\top w_i+\\hat{\\alpha}\\hat{m}_i(s)\\}ds\n\\tag{6.6}\n\\end{align}\\]因此 \\(r_i^{tcs}=N_i(T_i)-r_i^{tm}(T_i)\\)。根据概率积分变换，当假定的模型很好地拟合数据时，我们期望时间 \\(t\\) 之后的失效概率，即 \\(\\mathcal{S}(t)=\\Pr(T_i^*>t)\\) 将在 \\([0, 1]\\) 中均匀分布，因此定义为 \\(H(t) = − \\log \\mathcal S(t)\\) 的累积风险将具有单位指数分布。该等式意味着我们可以通过检查 Cox-Snell 残差 \\(r^{tcs}_i\\) 是否呈单位指数分布来检查相对风险子模型的整体拟合优度。然而，这些残差在实际使用中的复杂性在于它们是在观测事件时间 \\(T_i\\) 处评估的，因此当 \\(T_i\\) 删失时，\\(r^{tcs}_i\\) 也将删失。因此，为了检查模型的拟合度，同时考虑到 \\(r^{tcs}_i\\) 实际上是单位指数分布的删失样本，我们比较单位指数分布的生存函数 \\(\\mathcal S_{exp}(t) = \\exp(−t)\\)，使用 \\(r^{tcs}_i\\) 的生存函数的 Kaplan-Meier 估计。我们通过继续对拟合到 AIDS 数据集的联合模型进行残差分析（如 6.1.1 节所示）来说明 R 中的鞅和 Cox-Snell 残差的使用，并验证生存部分的拟合。与纵向过程残差的计算类似，生存子模型的两种类型的残差都是使用泛型函数 residuals() 提取的。我们首先检查时依标志物所选择的函数形式。在上一节定义的相对风险子模型中，我们假定标志物的当前值与死亡风险相关，即\\[\\begin{aligned}h_i(t)=h_0(t)\\exp\\{\\gamma\\mathtt{ddI}_i+\\alpha m_i(t)\\}\\end{aligned}\\]然而，正如我们在第 5.1 节中看到的，有几种替代参数化可用于描述事件风险与标志物之间的关系，这可能更合适。正如我们在该节看到的，这些参数化通常可表示为\\[h_i(t)=h_0(t)\\exp[\\gamma\\mathtt{ddI}_i+\\alpha f\\{m_i(t)\\}]\\]其中 \\(f(\\cdot)\\) 表示一个未知函数，我们的目的是探究默认的选择 \\(f(x) = x\\) 是否合适。 Therneau et al. (1990) 表明，在某些条件下，零模型的鞅残差与感兴趣的预测变量的散点图可以揭示 \\(f(\\cdot)\\) 函数的真实形式。在我们的示例中，我们已经假定以当前值的项 \\(m_i(t)\\) 拟合了相对风险模型，我们可以检查鞅残差 \\(r^{tm}_i(t)\\) 与 \\(m_i(t)\\) 的散点图以了解系统性趋势。这些残差是使用调用 residuals() 中的选项 process =\"Event\" 从拟合的联合模型计算出来的函数 residuals() 用于计算所有时间点上的鞅残差，在这些时间点上，我们拥有关于患者失效状态的信息。其中包括在时间 \\(\\{t_{ij} , j = 1, \\ldots,n_i\\}\\) 记录纵向响应20 以及观测事件时间 \\(T_i\\)。为了计算同一时间点的当前值的项 \\(m_i(t)\\)，我们在调用 fitting() 泛型函数时使用选项 type = \"EventTime\"。图 6.3 显示了叠加了 loess 曲线的相应散点图，这是使用 6.1.1 节中定义的函数 plotResid() 生成的\n我们可以观察到，对于较小的拟合值，loess 平滑与零有轻微的偏差。为了进一步研究 CD4 细胞计数所选函数形式的适当性，建议以其他基线协变量为条件，额外检查鞅残差的系统性趋势。作为一个例子，我们取条件于治疗生成了图 6.3 的更新版本。ddI 和 ddC 组的散点图可以使用 lattice 中的函数 xyplot() 生成调用 xyplot() 中的选项 type=c(\"p\", \"smooth\") 指定我们要绘制散点以及 loess 平滑器拟合。如图 6.4 所示。我们再次观察到两种治疗方法与零水平线的一些轻度偏差，但 ddI 组的偏差较小。\n我们通过使用 Cox-Snell 残差评估生存子模型的总体拟合度来对生存结果进行残差分析。使用 residual() 函数在 R 中再次计算这些值，但现在使用选项 type=\"CoxSnell\"：为计算 CoxSnell 残差的生存函数的 Kaplan-Meier 估计，我们使用 survival 包中的函数 survfit()。该函数的语法与目前用于拟合 Cox 模型的 coxph() 语法非常相似。具体来说，它接受 R 公式作为主要参数，该公式在左侧使用函数 Surv() 提供删失响应和相应的事件指示符，在右侧它可能包括潜在的分层因素。请注意，在这里，删失响应不是患者的观测失效时间，而是 Cox-Snell 残差。相应的事件指示符是从 data 参数中提供的 ids.id 数据框中提取的。Kaplan-Meier 估计的图形是通过调用 plot() 函数生成的，如图 6.5 所示。curve() 函数用于叠加单位指数分布的生存函数，即 \\(\\mathcal S_{exp}(t) = \\exp(−t)\\)。将 Kaplan-Meier 估计的拟合与预期的渐近分布进行比较，我们观察到一些差异，特别是对于大于 0.8 的残差（尽管严格来说，单位指数分布的生存函数位于 95% 逐点置信区间内）的 Kaplan-Meier 估计，但在 1 附近除外）。为了进一步检查模型的拟合，我们利用治疗对残差进行分层，并绘制单独的生存函数估计；对应的 R 代码是当模型很好地拟合数据时，我们期望每个层的生存函数估计徘徊在单位指数分布附近。图 6.6 显示了两个治疗组的 Cox-Snell 残差的 Kaplan-Meier 估计，从中我们可以再次观察到大于 1 的残差值存在一些欠拟合，尽管其程度比图 6.5 中的要小。","code":"> martRes <- residuals(jointFit.aids, process = \"Event\")\n> mi.t <- fitted(jointFit.aids, process = \"Longitudinal\",\n                 type = \"EventTime\")> plotResid(mi.t, martRes, col.loess = \"grey62\",\n            ylab = \"Martingale Residuals\",\n            xlab = \"Subject-Specific Fitted Values Longitudinal Outcome\")> xyplot(martRes ~ mi.t | drug, data = aids, type = c(\"p\", \"smooth\"),\n         col = \"black\", lwd = 3, ylab = \"Martingale Residuals\",\n         xlab = \"Subject-Specific Fitted Values Longitudinal Outcome\")> resCST <- residuals(jointFit.aids, process = \"Event\",\n                      type = \"CoxSnell\")> sfit <- survfit(Surv(resCST, death) ~ 1, data = aids.id)\n> plot(sfit, mark.time = FALSE, conf.int = TRUE,\n       xlab = \"Cox-Snell Residuals\", ylab = \"Survival Probability\",\n       main = \"Survival Function of Cox-Snell Residuals\")\n> curve(exp(-x), from = 0, to = max(aids.id$Time), add = TRUE,\n        col = \"grey62\", lwd = 2)> sfit <- survfit(Surv(resCST, death) ~ drug, data = aids.id)\n> plot(sfit, mark.time = FALSE, xlab = \"Cox-Snell Residuals\",\n       ylab = \"Survival Probability\",\n       main = \"Survival Function of Cox-Snell Residuals\")\n> curve(exp(-x), from = 0, to = max(aids.id$Time), add = TRUE,\n        col = \"grey62\", lwd = 2)"},{"path":"chap6.html","id":"sec6-2","chapter":"第 6 章 联合模型诊断","heading":"6.2 脱落和残差","text":"上一节介绍了残差图的基本类型，当分别拟合混合模型和相对风险模型时，残差图通常用于验证这些模型背后的假设。尽管可以很容易地构建相同类型的诊断图来检查联合模型的拟合，但问题是纵向过程残差的参考分布会受到事件发生引起的脱落的影响。具体来说，正如我们在 4.6 节中所讨论的，当患者经历感兴趣的事件时，这对应于纵向信息收集的中断。因为在这种情况下，后续的测量数据要么无法再被收集，要么在事件发生后其分布发生了变化，因此视为不重要的，从而不再进行收集。正如我们在 4.6 节中所看到的，联合模型所暗示的脱落机制具有非随机性质，也就是说，它对应于缺失的非随机机制（见 2.3.1 节）。脱落机制的非随机性意味着，用于计算残差的观测并不构成目标人群的随机样本 (Verbeke et al., 2008; Fitzmaurice et al., 2004, Section 14.2). 这反过来意味着仅基于观测的残差图可能会产生误导，因为不应期望这些残差表现出标准性质，例如零均值和独立性。例如，在图 6.2 中，我们观察到，对于较小的拟合值，我们的正残差多于负残差。然而，较小的拟合值对应于较低水平的 CD4 细胞计数平方根，这反过来又对应于患者病情的恶化，因此脱落的概率较大。因此，与较小拟合值对应的残差仅基于健康状况“良好”的患者。因此，由于脱落，我们无法辨别图 6.2 中看到的系统性趋势是否真正归因于固定效应的设计矩阵 \\(X\\) 的错误指定。为了进一步说明非随机脱落如何影响仅基于观测数据的残差的使用，我们在图 6.7 中显示了标准化边际残差和标准化特定于受试者的残差与 PBC 数据集相应拟合值的关系图。这些基于一个联合模型，该模型假定对数血清胆红素的特定于受试者的线性演变，以及事件发生时间（死亡或移植）的相对风险模型，该模型控制治疗和肝肿大，并假定分段恒定的基线风险函数。拟合模型的 R 语法是对于 6.1 节中的 AIDS 数据集，我们分别使用对泛型函数 residuals() 和 fitting() 的适当调用来计算残差和拟合值然后用如下代码生成图 6.7\n我们再次观察到标准化边际残差与拟合值图中的拟合 loess 曲线显示出系统性趋势。但请注意，高水平的血清胆红素表明患者病情恶化，导致更高的死亡率（即中途脱落）。与图 6.2 类似，我们不能从该图中明确得出结论，认为欠拟合是由于 \\(X\\) 的错误指定造成的。因此，艾滋病和 PBC 数据示例都表明，在验证联合模型的假设时，仅基于观测数据的残差图可能是具有误导性的。","code":"> lmeFit2.pbc <- lme(log(serBilir) ~ year * drug,\n                     random = ~ year | id, data = pbc2)\n> coxFit.pbc <- coxph(Surv(years, status2) ~ drug + hepatomegaly,\n                      data = pbc2.id, x = TRUE)\n> jointFit2.pbc <- jointModel(lmeFit2.pbc, coxFit.pbc, timeVar = \"year\",\n                              method = \"piecewise-PH-aGH\")> resSubY.pbc <- residuals(jointFit2.pbc, process = \"Longitudinal\",\n                           type = \"stand-Subject\")\n> fitSubY.pbc <- fitted(jointFit2.pbc, process = \"Longitudinal\",\n                        type = \"Subject\")\n> resMargY.pbc <- residuals(jointFit2.pbc, process = \"Longitudinal\",\n                            type = \"stand-Marginal\")\n> fitMargY.pbc <- fitted(jointFit2.pbc, process = \"Longitudinal\",\n                         type = \"Marginal\")> par(mfrow = c(1,2))\n> plotResid(fitSubY.pbc, resSubY.pbc, xlab = \"Fitted Values\",\n            ylab = \"Subject-Specific Residuals\")\n> plotResid(fitMargY.pbc, resMargY.pbc, xlab = \"Fitted Values\",\n            ylab = \"Marginal Residuals\")"},{"path":"chap6.html","id":"sec6-3","chapter":"第 6 章 联合模型诊断","heading":"6.3 多重插补残差","text":"","code":""},{"path":"chap6.html","id":"sec6-3-1","chapter":"第 6 章 联合模型诊断","heading":"6.3.1 固定就诊时间","text":"为了解决由非随机脱落引起的问题，并生成可用于诊断图的纵向过程残差，Rizopoulos et al. (2010) 提出，在完全数据模型下，通过随机插补缺失的纵向响应来扩充观测数据，这些插补响应对应于如果患者未脱落本应观察到的纵向结果。然后利用这些扩充后的纵向响应，针对完全数据计算残差，并采用多重插补方法来适当解释由于缺失数据而导致的插补值中的不确定性 (Gelman et al., 2005).为呈现该想法，我们将借用 4.6 节的符号，并用 \\(y_i^o=\\{y_i(t_{ij}):t_{ij}<T_i,j=1,\\ldots,n_i\\}\\) 表示纵向响应向量的观测部分，包含第 \\(\\) 个受试者在观测事件时间之前的所有观测纵向测量值，用 \\(y_i^m=\\{y_i(t_{ij}):t_{ij}\\geq T_i,j=1,\\ldots,n'_i\\) 表示纵向测量的缺失部分，如果事件没有发生，这些测量在研究结束前将一直进行。我们还假定联合模型已拟合到手头上的数据集，并且我们已获得了最大似然估计 \\(\\hat\\theta\\) 及其渐近协方差阵 \\(\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\theta})\\) 的估计。此外，我们假定纵向测量计划在一组预先指定的时间点 \\(t_0,t_1,\\ldots,t_\\max\\) 进行，并且对于第 \\(\\) 个受试者，测量结果可追溯到早于 \\(T_i\\) 的最后一个预先指定的就诊时间。为了提出想法，我们采用了联合模型的贝叶斯公式，因为多重插补具有贝叶斯基础 (Little Rubin, 2002, Chapter 10). 具体来说，多重插补方法是基于给定观测数据的 \\(y^m_i\\) 后验分布的重复抽样，对参数的后验分布进行平均。在联合模型 (4.9) 和脱落机制 (4.20) 下，该分布的密度可表示为\\[\\begin{align}\np(y_i^m\\mid y_i^o,T_i,\\delta_i)=\\int p(y_i^m\\mid y_i^o,T_i,\\delta_i;\\theta)p(\\theta\\mid y_i^o,T_i,\\delta_i)d\\theta\n\\tag{6.7}\n\\end{align}\\]上式中的被积函数的第一部分可以从 (4.20) 中导出，同时考虑条件独立性假设 (4.7) 和 (4.8)，即：\\[\\begin{align}\np(y_i^m\\mid y_i^o,T_i,\\delta_i;\\theta)\\quad&=\\quad\\int p(y_i^m\\mid b_i,y_i^o,T_i,\\delta_i;\\theta)p(b_i\\mid y_i^o,T_i,\\delta_i;\\theta)db_i\\\\&=\\quad\\int p(y_i^m\\mid b_i;\\theta)p(b_i\\mid y_i^o,T_i,\\delta_i;\\theta)db_i\n\\tag{6.8}\n\\end{align}\\]对于第二部分，即给定观测数据的参数的后验分布，我们使用标准渐近贝叶斯理论的论点 (Cox Hinkley, 1974, Section 10.6)，并假定样本量 \\(n\\) 足够大，使得 \\(\\{\\theta\\mid y_i^o,T_i,\\delta_i\\}\\) 可以很好地近似为 \\(\\mathcal{N}\\{\\hat{\\theta},\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\theta})\\}\\)。该假定与 (4.7) 和 (4.8) 相结合，提出了以下模拟方案步骤 1：抽取 \\(\\theta^{(l)}\\sim\\mathcal{N}\\{\\hat{\\theta},\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\theta})\\}\\)步骤 2：抽取 \\(b_i^{(l)}\\sim\\{b_i\\mid y_i^o,T_i,\\delta_i,\\theta^{(l)}\\}\\)步骤 3：对于第 \\(\\) 个受试者未观测的预先指定的就诊时间 \\(t_{ij}\\geq T_i,j=1,\\ldots,n'_i\\) 抽取 \\(y_i^{m(l)}(t_{ij})\\sim\\mathcal{N}\\Big\\{\\hat{m}_i^{(l)}(t_{ij}),\\hat{\\sigma}^{2,(l)}\\Big\\}\\)，其中 \\(\\hat{m}_i^{(l)}(t_{ij})=x_i^\\top(t_{ij})\\hat{\\beta}^{(l)}+z_i^\\top(t_{ij})\\hat{b}_i^{(l)}\\)对每个受试者重复以上步骤 \\(l=1,\\ldots,L\\) 次，其中 \\(L\\) 表示插补次数。步骤 1 和步骤 2 分别考虑参数和经验贝叶斯估计的不确定性，而步骤 3 则对缺失的纵向响应进行插补。步骤 1 和 3 执行起来很简单，因为它们需要从多元正态分布中采样；相反，给定步骤 2 中的观测数据，随机效应的后验分布是非标准形式，因此需要更复杂的方法从中进行抽样。Rizopoulos et al. (2010) 提出使用 Metropolis-Hastings 算法，该算法具有来自以经验贝叶斯估计的多元 \\(t\\) 分布的独立建议 (proposals)，该分布以 \\(\\hat b_i\\) 为中心，尺度矩阵为 \\(\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{b}_i)\\) 并具有四个自由度。Booth Hobert (1999) 使用类似的方法来模拟广义线性混合模型中随机效应的后验分布。在联合建模框架中，采用多元 \\(t\\) 建议的理由有两个。首先，Rizopoulos et al. (2008) 已经表明，随着 \\(n_i\\) 的增加，随机效应的对数后验分布的首项是线性混合模型密度的对数 \\(\\log p(y_i|b_i;\\theta^{(l)})=\\sum_j\\log p\\{y_i(t_{ij})|b_i;\\theta^{(l)}\\}\\)，它在 \\(b_i\\) 中是二次的，将类似于多元正态分布的形状；其次，对于较小的 \\(n_i\\)，\\(t\\) 分布的较重的尾部将确保足够的覆盖范围。模拟的 \\(y_i^{m(l)}(t_{ij})\\) 值与 \\(y^o_i\\) 现在可用于根据 (6.2) 或 (6.4) 计算残差。多重插补残差的一个关键优点是它们继承了完全数据模型的性质。这有利于常见的图形模型检查，而不需要正式推导观测数据残差的参考分布。然而，我们应该注意，在一些终止事件是死亡的临床研究中，例如在 AIDS 和 PBC 数据集中，考虑事件时间后纵向结果的潜在值在概念上可能不合理；参见 Kurland Heagerty (2005). 尽管如此，多重插补残差仅用作帮助我们研究模型拟合度的机制，我们实际上对事件时间之后的推断并不感兴趣。上述模拟方案可在 residuals() 方法中使用，并且可以使用逻辑参数 MI 进行调用。作为说明，我们计算 AIDS 数据集的多重插补标准化边际残差与标准调用 residuals() 返回一个残差数值向量（如之前所示）不同，将 MI 设置为 TRUE 会返回一个包含多个组件的列表，这些组件在进一步处理多重插补残差时非常有用。我们在这里提取的两个组件是拟合值和对应于 \\(y^m_i\\) 的多重插补标准化边际残差，如 6.1.1 节所述。对象 fitMargY.miss 是一个数值向量，而 resMargY.miss 是一个数值矩阵，其列表示基于 \\(y^m_i\\) 的多重插补得到的残差实现（默认为 50 次多重插补；这由函数 residuals() 的参数 M 控制）。以下代码生成了图 6.8，该图描述了多重插补残差以及观测残差与相应拟合值的关系\n图 6.8 中的 loess 曲线实际上与图 6.2 中的曲线相同，由如下代码生成：然而，为了生成描述完全残差（即多重插补残差与观测残差）与其相应拟合值之间关系的 loess 曲线，需要一些额外的步骤。具体来说，我们需要考虑到，对于第 \\(\\) 个受试者没有出现在研究中心的每个时间点，我们有 \\(M = 50\\) 个多重插补残差，而对于实际出现的时间我们只有一个残差。因此，在 loess 曲线的计算中，我们将使用案例权重：观测残差值为 1，而多重插补残差值为 \\(1/M = 1/50 = 0.02\\)，即两种 loess 平滑器之间的比较表明，实际上，仅基于观测数据的残差图中出现的系统性趋势主要归因于非随机脱落，而不是模型的欠拟合。","code":"> set.seed(123) # we set the seed for reproducibility\n> resMI.aids <- residuals(jointFit.aids, process = \"Longitudinal\",\n                          type = \"Marginal\", MI = TRUE)\n> fitMargYmiss.aids <- resMI.aids$fitted.valsM\n> resMargYmiss.aids <- resMI.aids$resid.valsM> M <- ncol(resMargYmiss.aids) # number of imputations\n> resMargYmi.aids <- c(resMargY.aids, resMargYmiss.aids)\n> fitMargYmi.aids <- c(fitMargY.aids, rep(fitMargYmiss.aids, M))\n> plot(range(fitMargYmi.aids), range(resMargYmi.aids), type = \"n\",\n       xlab = \"Fitted Values\",\n       ylab = \"MI Standardized Marginal Residuals\")\n> abline(h = 0, lty = 2)\n> points(rep(fitMargYmiss.aids, M), resMargYmiss.aids, cex = 0.5,\n         col = \"grey\")\n> points(fitMargY.aids, resMargY.aids)> lines(lowess(fitMargY.aids, resMargY.aids), lwd = 2)> datResid <- data.frame(\n  resid = resMargYmi.aids,\n                         fitted = fitMargYmi.aids,\n                         weight = c(rep(1, length(resMargY.aids)),\n                                    rep(1/M, length(resMargYmiss.aids)))\n)\n> fitLoess.aids <- loess(resid ~ fitted, data = datResid,\n                         weights = weight)\n> nd.aids <- data.frame(fitted = seq(min(fitMargYmi.aids),\n                                     max(fitMargYmi.aids), length.out = 100))\n> prdLoess.aids <- predict(fitLoess.aids, nd.aids)\n> lines(nd.aids$fit, prdLoess.aids, lwd = 2, lty = 2)"},{"path":"chap6.html","id":"sec6-3-2","chapter":"第 6 章 联合模型诊断","heading":"6.3.2 随机就诊时间","text":"6.3.1 节中提出的多重插补方案假定就诊时间由方案预先指定，并且所有患者都遵守这些时间。然而，在观察性研究中，进行纵向测量的时间点并非由研究设计固定的，而是由医生甚至患者自己决定的。这甚至可能发生在随机研究中，根据方案，这些研究有预先指定的就诊时间。例如，对于 PBC 数据集和前两年的随访，在基线、0.5 年、1 年和 2 年测量血清胆红素，变异性很小，但在后几年，就诊时间的变异性显著增加。在 4.3.2 节中提到的非信息性假设下，只要联合模型被正确指定，就诊过程可以忽略，而不会影响最大似然估计的渐近性质。然而，如 6.3.1 节所述，随机就诊时间会使多重插补残差的计算变得复杂。具体来说，我们无法获得第\\(\\) 个受试者在观测事件时间 \\(T_i\\) 之后应该提供测量值时间点的测量，因此，对于设计矩阵 \\(X_i\\) 和 \\(Z_i\\) 中对应行 \\(x_i(t_{ij})\\) 和 \\(z_i(t_{ij})\\)（其中 \\(t_{ij} \\ge T_i\\)）无法指定。这个问题不能通过在任意指定的固定时间点插补 \\(y^m_i\\) 的简单方法来解决，因为它可能会在观测很少的特定数据范围内产生太多或太少的正残差，从而污染残差图。另一种方法是为就诊过程拟合合适的模型，并用它来模拟每个人未来的就诊时间。正式地，我们不失一般性地假定，所有受试者都至少有一个测量，我们令 \\(u_{ik} (k = 2, ..., n_i)\\) 表示第 \\(\\) 个受试者第 \\(k -1\\) 和第 \\(k\\) 次就诊之间经过的时间。并令 \\(Y^*_i\\) 表示完全纵向响应向量，即如果受试者 \\(\\) 没有脱落，在时间 \\(t\\) 之前的所有观测纵向响应。根据这些定义，就诊过程的非信息性假设可以表达为\\[\\begin{align}\np(u_{ik}&\\mid u_{i2},\\dots,u_{,k-1},Y_i^*;\\theta_\\upsilon)\\\\&=p\\{u_{ik}\\mid u_{i2},\\dots,u_{,k-1},y_i(t_1),\\dots,y_i(t_{k-1});\\theta_v\\}\n\\tag{6.9}\n\\end{align}\\]其中 \\(\\theta_v\\) 是将就诊过程的密度参数化的向量，并且 \\(\\{\\theta,\\theta_v\\}\\) 具有不相交的参数空间。为了建立就诊过程的模型，我们需要考虑到每个受试者的就诊时间 \\(u_i^\\top=(u_{i2},\\ldots,u_{in_i})\\) 是相关的。对于多元生存数据，主要有两类模型，即边际模型和条件/脆弱性模型 (Hougaard, 2000; Therneau Grambsch, 2000). 边际模型基于与 Liang Zeger (1986) 的广义估计方程方法类似的思想，该方法需要将普通 Cox 模型拟合到多元数据，将其视为独立的（即忽略相关性），然后使用三明治型估计调整估计的标准误。另一方面，条件模型使用潜变量显式地对相关性进行建模。与混合模型类似，我们做出了一个条件独立性假设，即在给定脆弱项的情况下，多元生存响应是独立的。因此，脆弱模型需要指定以脆弱项为条件的多元生存响应的模型，以及脆弱项本身的适当分布假定 (Duchateau Janssen, 2008).出于我们的目的，并且因为我们想模拟每个受试者的就诊时间，我们需要提供一个完整的指定——条件分布 \\(p\\{u_{ik}~|~u_{i2},\\ldots,u_{,k-1},y_i(t_1),\\ldots,y_i(t_{k-1});\\theta_v\\}\\)，因此条件模型更合适。具体来说，我们使用具有乘性 Gamma 脆弱性的 Weibull 模型，定义为\\[\\begin{align}\n\\lambda(u_{ik}\\mid x_{vi},\\omega_i)&=\\lambda_0(u_{ik})\\omega_i\\exp(x_{vi}^\\top\\gamma_v),&\\omega_i&\\sim\\text{Gamma}(\\sigma_\\omega,\\sigma_\\omega)\n\\tag{6.10}\n\\end{align}\\]其中 \\(\\lambda(\\cdot)\\) 是以脆弱项 \\(\\omega_i\\) 为条件的风险函数，\\(x_{vi}\\) 表示协变量向量，其可能包含观测纵向响应 \\(y_i(t_{i1}),\\ldots,y_i(t_{,k-1})\\) 的函数形式，\\(\\gamma_v\\) 是回归系数向量，\\(\\sigma^{−1}_\\omega\\) 是 \\(\\omega_i\\) 的未知方差。Weibull 基线风险函数由 \\(\\lambda_0(u_{ik})=\\phi\\psi u_{ik}^{\\psi-1}\\) 给出，其中 \\(\\psi,\\phi>0\\)。我们之所以选择该模型，不仅是因为它的灵活性和简单性，而且是因为在给定观测数据的情况下，脆弱项的后验分布有标准形式 (Sahu et al., 1997)，如下所示，这有助于模拟。类似于 6.3.1 节，我们假定联合模型和就诊过程模型 (6.10) 都已拟合到手头的数据，并已分别获得了最大似然估计 \\(\\hat\\theta\\) 和 \\(\\hat\\theta_v\\) 以及它们响应的渐近协方差阵 \\(\\operatorname{v\\hat{}r}(\\hat{\\theta})\\) 和 \\(\\operatorname{v\\hat{}r}(\\hat{\\theta}_v)\\)。还令 \\(t_\\max\\) 表示研究的结束，并且 \\(\\delta_{v,ik}\\) 表示对应于 \\(u_{1k}\\) 的事件指示符。此外，考虑到非信息性假设 (6.9)，未来就诊的经历的时间 \\(u_{,n_i+1}\\) 可独立于 \\(y_i^m(t_{,n_i+1})\\) 来模拟。因此，在随机就诊时间设定下的模拟方案采用如下形式步骤 1：参数值\n抽取 \\(\\theta_v^{(l)}\\sim\\mathcal{N}\\{\\hat{\\theta}_v,\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\theta}_v)\\}\\)\n抽取 \\(\\theta^{(l)}\\sim\\mathcal{N}\\{\\hat{\\theta},\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\theta})\\}\\)\n抽取 \\(\\theta_v^{(l)}\\sim\\mathcal{N}\\{\\hat{\\theta}_v,\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\theta}_v)\\}\\)抽取 \\(\\theta^{(l)}\\sim\\mathcal{N}\\{\\hat{\\theta},\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\theta})\\}\\)步骤 2：脆弱项和随机效应\n对于大于一次就诊的受试者，抽取 \\(\\omega_i^{(l)}\\sim\\mathrm{Gamma}(,B)\\)，其中 \\(=\\sigma_\\omega^{(l)}+\\sum_{k=2}^{n_i}\\delta_{v,ik}\\) 且 \\(B=\\sigma_\\omega^{(l)}+\\phi^{(l)}\\sum_{k=2}^{n_i}u_{ik}^{\\psi^{(l)}}\\exp\\bigl(x_{vi}^\\top\\gamma_v^{(l)}\\bigr)\\)；对于只有一次就诊的受试者，抽取 \\(\\omega_i^{(l)}\\sim\\mathrm{Gamma}(\\sigma_\\omega^{(l)},\\sigma_\\omega^{(l)})\\)\n抽取 \\(b_i^{(l)}\\sim\\{b_i\\mid y_i^o,T_i,\\delta_i,\\theta^{(l)}\\}\\)\n对于大于一次就诊的受试者，抽取 \\(\\omega_i^{(l)}\\sim\\mathrm{Gamma}(,B)\\)，其中 \\(=\\sigma_\\omega^{(l)}+\\sum_{k=2}^{n_i}\\delta_{v,ik}\\) 且 \\(B=\\sigma_\\omega^{(l)}+\\phi^{(l)}\\sum_{k=2}^{n_i}u_{ik}^{\\psi^{(l)}}\\exp\\bigl(x_{vi}^\\top\\gamma_v^{(l)}\\bigr)\\)；对于只有一次就诊的受试者，抽取 \\(\\omega_i^{(l)}\\sim\\mathrm{Gamma}(\\sigma_\\omega^{(l)},\\sigma_\\omega^{(l)})\\)抽取 \\(b_i^{(l)}\\sim\\{b_i\\mid y_i^o,T_i,\\delta_i,\\theta^{(l)}\\}\\)步骤 3：结果\n抽取 \\(u_i^{(l)}\\sim\\text{Weibull}\\Big\\{\\psi^{(l)},\\phi^{(l)}\\omega_i^{(l)}\\exp(x_{vi}^\\top\\gamma_v^{(l)})\\Big\\}\\)\n令 \\(\\tilde{t}_i=u_i^{(l)}+t_{}\\)，其中 \\(t_{}\\) 表示第 \\(\\) 个受试者末次就诊时间。若 \\(\\tilde{t}_i>t_{max}\\)，则对于该受试者没有 \\(y_i^m\\) 需要插补；否则抽取 \\(y_i^{m(l)}(\\tilde{t}_i)\\sim\\mathcal{N}\\bigg\\{\\hat{m}_i^{(l)}(\\tilde{t}_i),\\hat{\\sigma}^{2,(l)}\\bigg\\}\\)，其中 \\(\\hat{m}_i^{(l)}(\\tilde{t}_i)=x_i^\\top(\\tilde{t}_i)\\hat{\\beta}^{(l)}+z_i^\\top(\\tilde{t}_i)\\hat{b}_i^{(l)}\\)\n令 \\(t_{in_i}=\\tilde{t}_i\\) 并对于所有 \\(\\) 重复 -b 直到 \\(t_{in_i}>t_{max}\\)\n抽取 \\(u_i^{(l)}\\sim\\text{Weibull}\\Big\\{\\psi^{(l)},\\phi^{(l)}\\omega_i^{(l)}\\exp(x_{vi}^\\top\\gamma_v^{(l)})\\Big\\}\\)令 \\(\\tilde{t}_i=u_i^{(l)}+t_{}\\)，其中 \\(t_{}\\) 表示第 \\(\\) 个受试者末次就诊时间。若 \\(\\tilde{t}_i>t_{max}\\)，则对于该受试者没有 \\(y_i^m\\) 需要插补；否则抽取 \\(y_i^{m(l)}(\\tilde{t}_i)\\sim\\mathcal{N}\\bigg\\{\\hat{m}_i^{(l)}(\\tilde{t}_i),\\hat{\\sigma}^{2,(l)}\\bigg\\}\\)，其中 \\(\\hat{m}_i^{(l)}(\\tilde{t}_i)=x_i^\\top(\\tilde{t}_i)\\hat{\\beta}^{(l)}+z_i^\\top(\\tilde{t}_i)\\hat{b}_i^{(l)}\\)令 \\(t_{in_i}=\\tilde{t}_i\\) 并对于所有 \\(\\) 重复 -b 直到 \\(t_{in_i}>t_{max}\\)重复以上步骤 \\(l=1,\\ldots,L\\) 次。与 6.3.1 节一样，步骤 1-3 同时考虑了联合过程模型和就诊过程模型中的不确定性。此外，请注意，只有一项纵向测量的受试者不会向就诊过程模型提供任何信息。对于这些情况，在步骤 3a 中，我们只能使用 Gamma 先验分布（步骤 2a）中的模拟脆弱值来模拟未来的就诊时间。应用上述模拟方案的一个重要方面是就诊过程模型的线性预测器的形式。更具体地说，我们应该注意到，假设 (6.9) 是最弱的假设，在该假设下，即使忽略就诊过程，联合模型也能提供有效的推断，但满足 (6.9) 的模型涉及许多参数，因此可能是不稳定的。一组更有力但可能更合理的假设是\\[\\begin{align}\np(u_{ik}&\\mid u_{i2},\\ldots,u_{,k-1},Y_i^*;\\theta_v)\\\\&=\\quad p\\{u_{ik}\\mid u_{i2},\\ldots,u_{,k-1},y_i(t_{k-1});\\theta_v\\}\n\\tag{6.11}\n\\end{align}\\]以及\\[\\begin{align}\np(u_{ik}\\mid u_{i2},\\ldots,u_{,k-1},Y_i^*;\\theta_v)=p\\{u_{ik}\\mid y_i(t_{k-1});\\theta_v\\}\n\\tag{6.12}\n\\end{align}\\]式 (6.11) 假定就诊 \\(k−1\\) 和就诊 \\(k\\) 之间的时间取决于之前的时间和最后一次观测纵向测量值，而在 (6.12) 中，它仅取决于最后一次观测纵向测量值。这些假设描述了医生根据最后的观测结果以及可能的过去的就诊模式来决定患者未来就诊的情况。在 6.2 节中，我们展示了多重插补方法在实际中的应用，该方法用于扩增将联合模型拟合到 PBC 数据集时纵向过程的标准化残差。作为第一步，我们需要指定就诊过程模型。为了说明，我们假定一个简单的模型，该模型假设在第 \\(k-1\\) 次和 \\(k\\) 次就诊之间经历的时间 \\(u_{ik}\\) 取决于之前的就诊时间以及当前血清胆红素的值。该模型对应于假设 (6.11)，其形式如下：\\[\\lambda(u_{ik}\\mid y_i^*(t),\\omega_i)=\\lambda_0(u_{ik})\\omega_i\\exp\\{\\gamma_vy_i(t_{k-1})\\},\\omega_i\\sim\\text{Gamma}(\\sigma_\\omega,\\sigma_\\omega)\\]为拟合该模型，我们首先需要从 pbc2 数据框中提取每个受试者就诊之间的时间 \\(\\{u_{ik},k=2,\\ldots,n_i\\}\\) 以及滞后响应向量 \\(\\{y_i(t_k−1),k=2,\\ldots,n_i\\}\\)。这是通过以下代码实现的具体来说，对象 diff.time 是每个患者两次就诊之间经历时间的列表，对象 prev.y 是每个患者上一次就诊时间 \\(y_i(t_k−1)\\) 的对数血清胆红素水平列表。代码的最后一行将 diff.time 和 prev.y 设置为 NA，对应于只有单次血清胆红素测量的患者。接下来，我们构建包含就诊过程的所有患者信息的数据框模型 (6.10) 可以使用 JM 包中的函数 weibull.frailty() 拟合到 R 中。该函数的语法与 Survival 包中的 coxph() 非常相似，具体来说，它的主要参数是指定模型的生存信息和线性预测器的参数公式、提供包含所有变量的数据框的参数 data 以及参数 id 用于指定数据中与患者标识符变量对应的变量的名称。summary() 方法提供的详细输出表明，下次就诊的时间与当前血清胆红素值密切相关，并且患者的就诊模式存在相当大的异质性（即，较大的脆弱性方差）。接下来的步骤与 6.3.1 节中的步骤非常相似。具体来说，在对 residual() 的调用中将参数 MI 设置为 TRUE 可实现上述随机就诊时间的多重插补模拟方案。为了让 residuals() 模拟脱落患者的未来就诊时间，我们需要提供拟合的 Weibull 脆弱模型作为参数 time.points。此外，对于一些内部计算，需要将对应于 \\(y_i(t_k−1)\\) 的变量名称作为额外属性添加到 WeibFrl 中，在我们的例子中是 prev.y；这是通过如下代码实现的然后，对 residuals() 的调用为如 6.3.1 节所示，我们首先提取多重插补响应的标准化边际残差和相应的拟合值，然后构建包含完整数据（分别为多重插补残差和观测残差以及拟合值）的数据框。为了帮助我们发现残差与拟合值散点图中的任何系统趋势，我们计算 loess 平滑器。同样，完全数据的 loess 平滑器 需要考虑到脱落时间之后的残差被过度表示的事实。如 6.3.1 节所示，我们使用加权 loess 平滑器实现这一点，其中脱落后的残差权重为 \\(1/L = 1/10 = 0.1\\)。对应的代码是最后，使用如下代码生成残差与拟合值的散点图，包括两个 loess 平滑器（一个仅基于观测数据，另一个基于完全数据）：正如艾滋病数据集的情况一样，我们从图 6.9 中观察到，基于完全数据的加权 loess 并没有表现出仅基于观测数据的 loess 曲线中清晰可见的系统性趋势。这有力地表明，这种系统性趋势主要是由于脱落，而不是模型的欠拟合。","code":"> diff.time <- with(pbc2, tapply(year, id, diff))\n> prev.y <- with(pbc2, tapply(log(serBilir), id, head, -1))\n> one.visit <- sapply(diff.time, length) == 0\n> diff.time[one.visit] <- prev.y[one.visit] <- NA> dataVT <- data.frame(\n  \"id\" = rep(names(prev.y), sapply(prev.y, length)),\n                       \"diff.Times\" = unlist(diff.time),\n                       \"prev.y\" = unlist(prev.y),\n                       \"event\" = 1)> WeibFrl <- weibull.frailty(Surv(diff.Times, event) ~ prev.y,\n                             id = \"id\", data = dataVT)\n> summary(WeibFrl)\n\n        Weibull Relative Risk Model with Gamma Frailty\n        \nCall:\nweibull.frailty(formula = Surv(diff.Times, event) ~ prev.y, data = dataVT,\n                id = \"id\")\nData Descriptives:\nNumber of groups: 285\nNumber of observations: 1633\nTotal Number of Events: 1633\n\nModel Summary:\n  log.Lik      AIC      BIC\n -665.254 1338.508 1353.118\n\nCoefficients:\n         value std.err z-value p-value\nprev.y -0.5084  0.0616  -8.249 <0.0001\n\nShape: 3.7618\nScale: 7.2209\nFrailty variance: 2.7283> attr(WeibFrl, \"prev.y\") <- \"prev.y\"> set.seed(123) # we set the seed for reproducibility\n> resMI.pbc <- residuals(jointFit2.pbc, type = \"stand-Marginal\",\n                         MI = TRUE, M = 10, time.points = WeibFrl)> fitMargYmiss.pbc <- unlist(resMI.pbc$fitted.valsM)\n> resMargYmiss.pbc <- unlist(resMI.pbc$resid.valsM)\n> M <- length(resMI.pbc$fitted.valsM)\n> datResid <- data.frame(\n  resid = c(resMargY.pbc, resMargYmiss.pbc),\n                         fitted = c(fitMargY.pbc, fitMargYmiss.pbc),\n                         weight = c(rep(1, length(resMargY.pbc)),\n                         rep(1/M, length(resMargYmiss.pbc))))\n> datResid <- datResid[complete.cases(datResid), ]> fitLoess.pbc <- loess(resid ~ fitted, data = datResid,\n                        weights = weight)\n> nd.pbc <- data.frame(fitted = seq(min(datResid$fitted, na.rm = TRUE),\n                                    max(datResid$fitted, na.rm = TRUE), len = 100))\n> prdLoess.pbc <- predict(fitLoess.pbc, nd.pbc)> plot(range(fitMargYmiss.pbc, na.rm = TRUE),\n       range(resMargYmiss.pbc, na.rm = TRUE),\n       type = \"n\", xlab = \"Fitted Values\",\n       ylab = \"Standardized Marginal Residuals\")\n> abline(h = 0, lty = 2)\n> points(fitMargY.pbc, resMargY.pbc)\n> points(fitMargYmiss.pbc, resMargYmiss.pbc, col = \"grey\")\n> lines(lowess(fitMargY.pbc, resMargY.pbc), lwd = 2)\n> lines(nd.pbc$fit, prdLoess.pbc, lwd = 2, lty = 2)"},{"path":"chap6.html","id":"sec6-4","chapter":"第 6 章 联合模型诊断","heading":"6.4 随机效应分布","text":"我们对联合模型进行分布假定的最后一个组成部分是随机效应。正如我们已经看到的，在混合模型中，通常情况下，标准的选择是假定正态分布随机效应，均值为零和协方差阵为 \\(D\\)，尽管很多时候，这种选择实际上并不是基于计算目的。检验正态分布适当性的主要问题是，随机效应是不利于直接构建残差的潜在量，即观测量减去预期/拟合量。尽管如此，在标准混合模型文献中，已经表明线性混合效应模型对这种分布的错误指定相对稳健 (Verbeke Lesaffre, 1997). 然而，在广义线性混合模型中，这一主题存在更多的模糊性，一些作者报告了导出的推断对随机效应分布的敏感性 (Heagerty Kurland, 2001; Agresti et al., 2004; Litiere et al., 2007, 2008)，而其他一些作者报告了稳健性 (Neuhaus et al., 1992, 1994, 2011).在联合模型中，主要出于两个原因，人们更加关注随机效应分布的潜在错误指定可能会在多大程度上影响导出的推断。首先，随机效应在联合模型中具有更突出的作用，因为它们用于捕获纵向结果中重复测量之间的相关性，并用于建立纵向过程和事件时间过程之间的关联。其次，正如我们在 6.2 节中已经解释的那样，因事件发生引起的非随机脱落使问题变得复杂，因为在缺失数据文献中，众所周知，非随机脱落设定中的推断可能对建模假设高度敏感 (Copas Li, 1997; Molenberghs\net al., 2008).由于这些特征，基于 Gallant Nychka (1987) 以及 Tsiatis Davidian (2001) 所研究的平滑密度类别的灵活模型，Song et al. (2002) 提出一种半参数估计方程方法，该方法能在不指定随机效应分布的情况下进行有效推断。这些作者的模拟结果表明，参数估计和标准误对模型的错误指定具有较强的稳健性。这一特征随后得到了 Rizopoulos et al.(2008) 和 Huang et al. (2009) 的理论证实，他们表明，随着每个受试者的重复测量次数 \\(n_i\\) 的增加，随机效应分布的错误指定对模型参数估计和标准误的影响微乎其微。","code":""},{"path":"chap7.html","id":"chap7","chapter":"第 7 章 联合模型的预测和准确性","heading":"第 7 章 联合模型的预测和准确性","text":"通常，建立统计模型的动机是为感兴趣的结果提供预测。在本章中，我们将说明如何使用拟合的联合模型来提供生存和纵向结果的个性化预测。我们在这里考虑的设置的一个重要特征是，这些预测具有动态性，即随着时间的推移会为患者记录额外的信息，因此可以利用新信息更新她的预测。为了评估这些预测的质量，我们提出了基于受试者工作特征 (Receiver Operating Characteristic, ROC) 方法的判别度量。","code":""},{"path":"chap7.html","id":"sec7-1","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.1 生存概率的动态预测","text":"","code":""},{"path":"chap7.html","id":"sec7-1-1","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.1.1 定义","text":"我们首先将注意力转向生存概率的预测。具体来说，对于特定患者和随访期间的特定时间点，我们希望利用我们手头的所有可用信息（包括基线信息和累积的生物标志物水平）来预测生存概率。获得这些信息将使医生能够更好地了解疾病动态，并最终在特定时间点做出最佳决策。由于当前医疗实践有向个性化医疗发展的趋势，以及这种个性化预测在这方面可以发挥的突出作用，最近人们对这方面的联合建模框架产生了很大的兴趣 (Rizopoulos, 2011; Proust-Lima Taylor, 2009; Yu et al., 2008; Garre et al., 2008).更正式地说，基于随机样本中拟合的联合模型 \\(\\mathcal{D}_n=\\{T_i,\\delta_i,y_i;=1,\\ldots,n\\}\\)，我们感兴趣的是预测新受试者 \\(\\) 的生存概率，该受试者提供了一组纵向测量 \\(\\mathcal{Y}_i(t)=\\{y_i(s);0\\leq s<t\\}\\)，并且具有基线协变量向量 \\(w_i\\)。正如我们 3.4 节中看到的，\\(y_i(t)\\) 的内生性的一个重要特征是它与失效机制直接相关，即提供直到 \\(t\\) 的纵向测量，实际上意味着生存到这个时间点。因此，更重要的是关注给定生存到时间 \\(t\\) 后生存时间 \\(u > t\\) 的条件概率，即\\[\\begin{align}\n\\pi_i(u\\mid t)=\\Pr(T_i^*\\ge u\\mid T_i^*>t,\\mathcal{Y}_i(t),w_i,\\mathcal{D}_n;\\theta^*),\\quad t>0\n\\tag{7.1}\n\\end{align}\\]其中，\\(\\theta^*\\) 表示真参数值。从它的定义可以看出，\\(\\pi_i(u|t)\\) 具有动态性质。也就是说，当在时间 \\(t' > t\\) 为患者记录新信息时，我们可以更新这些预测并获得 \\(\\pi_i(u | t')\\)，其中 \\(u > t'\\)，因此以时间动态方式进行。","code":""},{"path":"chap7.html","id":"sec7-1-2","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.1.2 估计","text":"特定于受试者的条件生存概率的估计充分利用了用于定义联合模型的条件独立假设。也就是说，在条件 (4.7) 下，我们观察到 (7.1) 可重写为（假设以协变量 \\(w_i\\) 为条件，但在表达式中省略了）\\[\\begin{align}\n\\operatorname*{Pr}(T_{}^{*}&\\geq u\\mid T_{}^{*}>t,\\mathcal{Y}_{}(t);\\theta) \\\\\n=&\\quad\\int\\Pr(T_i^*\\geq u\\mid T_i^*>t,\\mathcal{Y}_i(t),b_i;\\theta) \\\\\n&\\times p(b_i\\mid T_i^*>t,\\mathcal{Y}_i(t);\\theta)db_i \\\\\n=&\\quad\\int\\Pr(T_i^*\\ge u\\mid T_i^*>t,b_i;\\theta)p(b_i\\mid T_i^*>t,\\mathcal{Y}_i(t);\\theta)db_i\\\\\n=&\\quad\\int\\frac{\\mathcal{S}_i\\big\\{u\\mid\\mathcal{M}_i(u,b_i,\\theta);\\theta\\big\\}}{\\mathcal{S}_i\\big\\{t\\mid\\mathcal{M}_i(t,b_i,\\theta);\\theta\\big\\}}p(b_i\\mid T_i^*>t,\\mathcal{Y}_i(t);\\theta)db_i\n\\tag{7.2}\n\\end{align}\\]其中 \\(\\mathcal S_i(\\cdot)\\) 与之前一样表示生存函数，此外我们明确指出，由线性混合效应模型近似的纵向历史 \\(\\mathcal M_i(\\cdot)\\) 是随机效应和参数的函数。基于 (7.2)，我们可以使用 \\(b_i\\) 的经验贝叶斯估计得出 \\(\\pi_i(u | t)\\) 的一阶估计，即\\[\\begin{align}\n&\\tilde{\\pi}_i(u\\mid t)\\\\&=\\mathcal{S}_i\\big\\{u\\mid\\mathcal{M}_i(u,\\hat{b}_i^{(t)},\\hat{\\theta});\\hat{\\theta}\\big\\}\\Big/\\mathcal{S}_i\\big\\{t\\mid\\mathcal{M}_i(t,\\hat{b}_i^{(t)},\\hat{\\theta});\\hat{\\theta}\\big\\}+O\\big([n_i(t)]^{-1}\\big)\n\\tag{7.3}\n\\end{align}\\]其中 \\(\\hat\\theta\\) 表示最大似然估计，\\(\\hat b_i^{(t)}\\) 表示条件分布 \\(\\log p(b_i\\mid T_i^*>t,\\mathcal{Y}_i(t);\\hat{\\theta})\\) 的众数，\\(n_i(t)\\) 表示受试者 \\(\\) 在时间 \\(t\\) 时的纵向响应数。Rizopoulos (2011) 中的模拟研究表明，该估计在实践中效果相对较好。然而，推导 \\(\\pi_i(u|t)\\) 的标准误和置信区间是一项相当困难的任务，因为我们需要考虑最大似然和经验贝叶斯估计的变异性。为了解决这个问题并产生有效的标准误差，Rizopoulos (2011), Proust-Lima Taylor (2009) 提出使用蒙特卡洛模拟方案。事实上，这些在本质上与 6.3 节中提出的多重插补残差模拟方案非常相似，并且它们可以通过联合模型的渐近贝叶斯公式来驱动。具体来说，(7.1) 的后验期望可以导出为\\[\\begin{align}\n\\Pr(T_i^*&\\ge u\\mid T_i^*>t,\\mathcal{Y}_i(t),\\mathcal{D}_n)\\\\&=\\quad\\int\\Pr(T_i^*\\ge u\\mid T_i^*>t,\\mathcal{Y}_i(t);\\theta)p(\\theta\\mid\\mathcal{D}_n)d\\theta\n\\tag{7.4}\n\\end{align}\\]被积函数的第一部分由 (7.2) 给出。对于第二部分，即给定观测数据的参数的后验分布，我们使用与 6.3 节中类似的参数，并假设样本量 \\(n\\) 足够大，使得 \\(\\{\\theta|\\mathcal D_n\\}\\) 可以很好地近似为 \\(\\mathcal{N}\\{\\hat{\\theta},\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\theta})\\}\\)。将 (7.4) 与 (7.2) 和 \\(\\{\\theta\\mid\\mathcal{D}_n\\}\\sim\\mathcal{N}\\{\\hat{\\theta},\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\theta})\\}\\) 相结合，我们可以使用以下模拟方案导出 \\(\\pi_i(u|t)\\) 的蒙特卡罗估计步骤 1：抽取 \\(\\theta^{(l)}\\sim\\mathcal{N}\\{\\hat{\\theta},\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\theta})\\}\\)步骤 2：抽取 \\(b_i^{(l)}\\sim\\{b_i\\mid T_i^*>t,\\mathcal{Y}_i(t),\\theta^{(l)}\\}\\)步骤 3：计算 \\(\\pi_i^{(l)}(u\\mid t)=\\mathcal{S}_i\\big\\{u\\mid\\mathcal{M}_i(u,b_i^{(l)},\\theta^{(l)});\\theta^{(l)}\\big\\}\\Big/\\mathcal{S}_i\\big\\{t\\mid\\mathcal{M}_i(t,b_i^{(l)},\\theta^{(l)});\\theta^{(l)}\\big\\}\\)重复以上步骤 \\(l=1,\\ldots,L\\) 次，其中 \\(L\\) 表示蒙特卡罗样本量。请注意，实际上，上述模拟方案需要计算一阶估计 (7.3)，但使用 \\(\\theta^{(l)}\\) 和 \\(b^{(l)}_i\\) 代替 \\(\\hat\\theta\\) 和 \\(\\hat b^{(t)}_i\\)，以便分别传播最大似然估计和经验贝叶斯估计中的不确定性。此外，与 6.3 节类似，步骤 2 基于 Metropolis-Hastings 算法，该算法具有来自具有四个自由度的多元 \\(t\\) 分布的独立建议，以经验贝叶斯估计 \\(\\hat b^{(t)}_i\\) 为中心，并且具有尺度矩阵 \\(\\operatorname{var}(\\hat{b}_i^{(t)})=\\left\\{-\\partial^2\\log p(T_i^*>t,\\mathcal{Y}_i(t),b;\\hat{\\theta})/\\partial b^\\top\\partial b\\Big|_{b=\\hat{b}_i^{(t)}}\\right\\}^{-1}\\)。实现 \\(\\{\\pi_i^{(l)}(u~|~t),l~=~1,\\dots,L\\}\\) 可用于导出 \\(\\pi_i(u|t)\\) 的点估计，例如\\[\\begin{align}\n\\hat{\\pi}_i(u\\mid t)=\\text{median}\\{\\pi_i^{(l)}(u\\mid t),l=1,\\ldots,L\\}\n\\tag{7.5}\n\\end{align}\\]或\\[\\begin{align}\n\\hat{\\pi}_i(u\\mid t)=L^{-1}\\sum_{l=1}^L\\pi_i^{(l)}(u\\mid t)\n\\tag{7.6}\n\\end{align}\\]并使用蒙特卡罗样本上的样本标准差、使用蒙特卡罗样本百分位数的置信区间来计算标准误差。与 (7.3) 相比，估计 (7.5) 和 (7.6) 不仅提供了一种直接计算标准误的方法，而且由于它们恰当地逼近 \\(\\pi_i(u|t)\\) 定义中的积分，因此有望产生更准确的结果。","code":""},{"path":"chap7.html","id":"sec7-1-3","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.1.3 在 R 中的实现","text":"动态生存概率是在 JM 包中使用函数 survfitJM() 计算的。该函数接受拟合联合模型和数据框作为主要参数，其中包含我们希望计算预测生存概率的受试者的纵向和协变量信息。为了说明其使用，我们从 PBC 数据集中计算患者 2 和 25 的生存概率。这两名患者观察到的血清胆红素对数纵向轨迹如图 7.1 所示。我们观察到，2 号患者的血清胆红素对数水平呈上升趋势，这表明她的病情正在恶化。另一方面，25 号患者表现出更稳定的较低血清胆红素水平，因此我们预计她有更高的生存概率。\n我们基于一个联合模型来估计这两名患者的条件生存概率 \\(\\pi_i(u|t)\\)，该模型使用 B 样条来近似特定于受试者的纵向轨迹 \\(m_i(t)\\)。更具体地说，对于纵向对数血清胆红素测量，我们假定模型\\[\\begin{array}{rcl}y_i(t)&=&m_i(t)+\\varepsilon_i(t)\\\\&=&(\\beta_0+b_{i0})+(\\beta_k+b_{ik})^\\top B(t,4,4)+\\varepsilon_i(t)\\end{array}\\]其中 \\(B(t,df,q)\\) 表示 \\(q−1\\) 次样条的 B 样条基矩阵，\\(df−q+1\\) 个内部结位于随访时间的相应百分位数，\\(\\beta_k\\) 和 \\(b_{ik}\\) 表示与 B 样条矩阵相对应的固定和随机效应向量。对于生存过程，我们假定复合事件（死亡或移植）的风险取决于治疗、异常凝血酶原时间和对数血清胆红素的真实水平，即\\[h_i(t)=h_0(t)\\exp\\{\\gamma_1\\mathtt{D}\\text{-}\\mathtt{pnc}_i+\\gamma_2\\mathtt{ProtTime}_i+\\alpha m_i(t)\\}\\]其中 \\(\\mathtt{ProtTime}\\) 表示当基线的凝血酶原时间在 [10秒, 13秒] 的正常范围之外时取值为 1 的虚拟变量。假定基线风险为分段常数。我们首先使用相同的语法拟合相应的联合模型：代码的第一部分构建了表示基线时凝血酶原时间是否在正常范围内的因子变量。来自包 splines 的函数 bs() 自动构造所需的 B 样条基矩阵。它的第二个参数对应于自由度，参数 Boundary.nots 用于确保 B 样条基的边界结延伸到随访时间 \\(\\{t_{ij},=1,\\ldots,n;j=1,\\ldots,n_i\\) 以及到 \\(\\{T_i,=1,\\ldots,n\\}\\) 的组合范围。我们将首先关注患者 2 并计算她的条件生存概率 \\(\\pi_i(u | t)\\)。具体来说，我们提供拟合联合模型作为 survfitJM() 的第一个参数，并在 newdata 参数中提供该患者的数据。该函数假定患者已存活到新数据中记录血清胆红素测量值的最后一个时间点 \\(t\\)，并将生成一组预定义的 \\(u > t\\) 值的生存概率21。输出结果相当不言自明。具体来说，对于新数据中的每个不同受试者和一系列时间点 \\(u\\)，我们从蒙特卡罗样本的百分位数计算出 \\(\\pi_i(u|t)\\) 的中位数 (7.5) 和均值 (7.6) 的蒙特卡罗估计，以及相应的 95% 置信区间。默认情况下，使用 200 个蒙特卡罗采样，但可以通过指定 survfitJM() 的 M 参数来适当调整该数字。输出中的第一行对应于我们知道受试者仍然未发生事件的最后一个时间点，因此相应的置信区间的估计和限被设置为 1. 或者，当只对 \\(\\pi_i(u|t)\\) 的点估计感兴趣时，我们也可以利用更快的近似一阶估计 (7.3)。这可以通过将模拟参数设置为 FALSE 来调用，例如比较 \\(\\pi_i(u|t)\\) 的近似估计和蒙特卡罗估计，我们观察到相当微小的差异。这证实了 7.1.2 节的说法，即在实践中，估计 (7.3) 相对于估计 (7.5) 和 (7.6) 表现得非常好，这两个估计预计会产生更准确的结果，因为它们恰当地逼近了 \\(\\pi_i(u|t)\\) 定义中的积分。此外，在某些情况下，我们还可能有关于患者在最后一次可用纵向测量后特定时间点的失效状态的额外信息。例如，根据患者 2 的数据：我们知道，她在研究中存活了 14.2 年，而最后一次血清胆红素测量是在 8.8 年收集的。该信息可以在 survfitJM() 中通过指定 last.time 参数来提供，该参数应该是一个字符串，其中包含保存此信息的 newdata 中变量的名称，或者最后一个时间点本身作为数字向量。请注意，由于计算时间点序列 \\(u\\) 的默认方法，当我们指定患者 2 生存到 14.2 年时，\\(\\pi_i(u | t)\\) 是针对单个时间点进行估计的。如果我们希望为特定的 \\(u\\) 估计 \\(\\pi_i(u | t)\\)，这可以通过参数 survTimes 来实现。例如，\\(\\pi_i(u | t)\\) 的 14.5 年和 15 年蒙特卡洛估计是通过调用如下命令生成的还可以使用 survfitJM 对象的 plot() 方法以图形方式说明 \\(\\pi_i(u | t)\\) 的估计。具体地，以下对 plot() 的简单调用会生成图 7.2.\n虚线和实线分别表示中位数 (7.5) 和均值 (7.6) 的估计，而 conf.int 参数指定我们还想绘制相应的 95% 逐点置信区间，用虚线表示。该图基于第一次调用 survfitJM() 生成的对象 survPrbs，并假设患者还活着的最后一个时间点是在 8.8 年，当时她提供了最后一次血清胆红素测量值。因此，对于所有之前的时间点 \\(u < t\\)，\\(\\pi_i(u | t) = 1\\)。下面我们重点关注条件生存概率的动态预测。具体来说，在记录每个额外的纵向测量后，我们将动态更新患者 2 的 \\(\\pi_i(u | t)\\)。为了对此进行编程，我们使用标准的 循环循环背后的想法是在每次迭代中简单地提供更新的数据框，其中包含 survfitJM() 的 newdata 参数中的一个额外测量值。结果保存在 survPreds 列表中。我们使用代码分别绘制基线、第三次、第五次和第七次测量后更新的生存曲线同样，使用 循环来生成曲线图。include.y 参数用于在曲线图中同时包含患者 2 到最后一次可用血清胆红素测量的时间点之前的拟合纵向轮廓，以及在该时间点之后的生存概率估计。此外，参数 estimator 的选项 \"medium\" 指定我们只希望绘制中位数估计 (7.5)。图 7.3 中包括了这四张图。我们观察到，在第三次测量后，观察到血清胆红素的真实水平明显增加，条件生存函数 \\(\\pi_i(u|t)\\) 的下降速度变得更加陡峭。\n我们观察到，在第三次测量后，观察到血清胆红素的真实水平明显增加，条件生存函数 \\(\\pi_i(u|t)\\) 的下降速度变得更加陡峭。为了说明血清胆红素曲线的变化如何反映在生存概率的动态更新中，我们比较了患者 2 和 25 的 \\(\\pi_i(u|t)\\) 的估计。如图 7.4 所示。在该图的每个面板中，我们对 \\(t = 0,0.5,2\\) 和 \\(5\\) 年以及 \\(u = t + \\Delta t\\) 的 \\(\\pi_i(u | t)\\)（以及相应的 95% 置信区间）进行了四个估计，其中每个面板具有不同的 \\(\\Delta t\\) 值。具体来说，左图对应 \\(\\Delta t = 1\\) 年，中间图对应 \\(\\Delta t = 2\\) 年，右图对应 \\(\\Delta t = 4\\) 年。一般来说，我们观察到，与患者 2 相比，表现出更稳定血清胆红素谱的患者 25 没有经历复合事件（死亡或移植）的生存机会更高。此外，如果我们仔细观察图 7.1 ，它描绘了观察到的两名患者的纵向轨迹，我们看到两名患者的血清胆红素水平从基线到第一次测量均有所下降，表明他们的病情有所改善。图 7.4 中生存概率的相应点估计中也注意到了这种改进，即 \\(t = 0.5\\) 时的生存概率高于基线 \\(t = 0\\) 时的相同概率，尽管两个估计的置信区间重叠。","code":"> pbc2.id$Pro <- with(pbc2.id, factor(pro >= 10 & pro <= 13,\n                                      labels = c(\"Abnormal\", \"Normal\")))\n> pbc2$Pro <- rep(pbc2.id$Pro, tapply(pbc2$id, pbc2$id, length))\n> lmeFitBsp.pbc <- lme(\n  fixed = log(serBilir) ~ bs(year, 4, Boundary.knots = c(0, 15)),\n                       random = list(\n  id = pdDiag(form = ~ bs(year, 4, Boundary.knots = c(0, 15)))),\n                       data = pbc2)\n> coxFit.pbc <- coxph(Surv(years, status2) ~ drug + Pro,\n                      data = pbc2.id, x = TRUE)\n> jointFitBsp.pbc <- jointModel(lmeFitBsp.pbc, coxFit.pbc,\n                                timeVar = \"year\", method = \"piecewise-PH-aGH\")> set.seed(123) # we set the seed for reproducibility\n> survPrbs <- survfitJM(jointFitBsp.pbc, newdata = pbc2[pbc2$id == 2, ])\n> survPrbs\n\nPrediction of Conditional Probabilities for Event\n      based on 200 Monte Carlo samples\n\n$2\n     times   Mean Median  Lower  Upper\n1   8.8325 1.0000 1.0000 1.0000 1.0000\n1   8.9405 0.9835 0.9845 0.9666 0.9926\n2   9.3609 0.9197 0.9252 0.8379 0.9655\n3   9.7813 0.8567 0.8695 0.7022 0.9403\n4  10.2017 0.7944 0.8140 0.5633 0.9138\n5  10.6221 0.7524 0.7769 0.4848 0.9014\n6  11.0425 0.7162 0.7462 0.4026 0.8933\n7  11.4629 0.6791 0.7101 0.3405 0.8837\n8  11.8833 0.6412 0.6773 0.2516 0.8718\n9  12.3037 0.6027 0.6501 0.1561 0.8559\n10 12.7241 0.5641 0.6182 0.0728 0.8466\n11 13.1445 0.5265 0.5847 0.0131 0.8405\n12 13.5649 0.4906 0.5509 0.0003 0.8335\n13 13.9853 0.4566 0.5216 0.0000 0.8326\n14 14.4057 0.4251 0.4853 0.0000 0.8193> survPrbsEB <- survfitJM(jointFitBsp.pbc,\n                          newdata = pbc2[pbc2$id == 2, ], simulate = FALSE)\n> survPrbsEB\n\nPrediction of Conditional Probabilities for Events\n$2\n     times predSurv\n1   8.8325   1.0000\n1   8.9405   0.9859\n2   9.3609   0.9314\n3   9.7813   0.8780\n4  10.2017   0.8255\n5  10.6221   0.7917\n6  11.0425   0.7636\n7  11.4629   0.7349\n8  11.8833   0.7053\n9  12.3037   0.6746\n10 12.7241   0.6427\n11 13.1445   0.6090\n12 13.5649   0.5734\n13 13.9853   0.5354\n14 14.4057   0.4946> pbc2[pbc2$id == 2, c(\"id\", \"years\", \"status\", \"serBilir\", \"year\")]\n   id   years  status serBilir      year\n3   2 14.15234  alive      1.1 0.0000000\n4   2 14.15234  alive      0.8 0.4983025\n5   2 14.15234  alive      1.0 0.9993429\n6   2 14.15234  alive      1.9 2.1027270\n7   2 14.15234  alive      2.6 4.9008871\n8   2 14.15234  alive      3.6 5.8892783\n9   2 14.15234  alive      4.2 6.8858833\n10  2 14.15234  alive      3.6 7.8907020\n11  2 14.15234  alive      4.6 8.8325485> set.seed(123)\n> survPrbs2 <- survfitJM(jointFitBsp.pbc,\n                         newdata = pbc2[pbc2$id == 2, ], last.time = \"years\")\n> survPrbs2\n\nPrediction of Conditional Probabilities for Event\n      based on 200 Monte Carlo samples\n$2\n    times   Mean Median  Lower  Upper\n1 14.1523 1.0000 1.0000 1.0000 1.0000\n1 14.4057 0.9414 0.9842 0.5686 0.9998> set.seed(123)\n> survfitJM(jointFitBsp.pbc, newdata = pbc2[pbc2$id == 2, ],\n            survTimes = c(14.5, 15), last.time = \"years\")\n\nPrediction of Conditional Probabilities for Event\n      based on 200 Monte Carlo samples\n$2\n    times   Mean Median  Lower  Upper\n1 14.1523 1.0000 1.0000 1.0000 1.0000\n1 14.5000 0.9225 0.9783 0.4382 0.9997\n2 15.0000 0.8385 0.9486 0.0549 0.9995> plot(survPrbs, lty = c(1:2,3,3), conf.int = TRUE)> ND <- pbc2[pbc2$id == 2, ]\n> survPreds <- vector(\"list\", nrow(ND))\n> for (i in 1:nrow(ND)) {\n  set.seed(123)\n  survPreds[[i]] <- survfitJM(jointFitBsp.pbc, newdata = ND[1:i, ])\n}> par(mfrow = c(2, 2), oma = c(0, 2, 0, 2))\n> for (i in c(1,3,5,7)) {\n  plot(survPreds[[i]], estimator = \"median\", conf.int = TRUE,\n                              include.y = TRUE, main = paste(\"Follow-up time:\",\n                              round(survPreds[[i]]$last.time, 1)))\n}\n> mtext(\"log serum bilirubin\", side = 2, line = -1, outer = TRUE)\n> mtext(\"Survival Probability\", side = 4, line = -1, outer = TRUE)"},{"path":"chap7.html","id":"sec7-2","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.2 纵向结果的动态预测","text":"在许多情况下，人们的兴趣还可能在于对纵向结果的预测。例如，在 HIV 感染的患者中，CD4 细胞计数和病毒载量通常用于确定何时应该开始治疗。在这些情况下，治疗医生深入了解两个标志物的预计纵向轮廓将有助于尽早开始治疗。这种预测可用与生存过程类似的方式来定义和估计。具体来说，对于在随访时间 \\(t\\) 时仍然存活的特定受试者 \\(\\)，我们对她在时间 \\(u > t\\) 时的纵向结果的预期值感兴趣，因为她在该时间点观测响应 \\(Y_i(t) = \\{ y_i(s), 0 \\le s < t\\}\\)，即\\[\\begin{align}\n\\omega_i(u\\mid t)=E\\big\\{y_i(u)\\mid T_i^*>t,\\mathcal{Y}_i(t),\\mathcal{D}_n;\\theta^*\\big\\},\\quad u>t\n\\tag{7.7}\n\\end{align}\\]与条件生存概率 (7.1) 类似，随着为该受试者记录额外信息，这些预测也会及时动态更新。也就是说，基于我们在时间 \\(t\\) 之前可用的信息对 \\(y_i(u)\\) 进行的预测 \\(omega_i(u | t)\\) 可以在时间 \\(t'\\) 处更新为 \\(t < t' < u\\)，以产生使用到后一个时间点的额外纵向信息的新的预测 \\(\\omega_i(u | t')\\)。对于 \\(\\omega_i(u | t)\\) 的估计，我们可以使用类似于 7.1.2 节中 \\(\\pi_i(u|t)\\) 估计的类似程序。更具体地说，为了说明我们不知道真实参数值 \\(\\theta^*\\) 的事实，我们再次在联合模型的渐近贝叶斯公式下进行，并且计算 \\(\\omega_i(u|t)\\) 关于参数 \\(\\{\\theta|\\mathcal D_n\\}\\) 的后验分布的期望为\\[\\begin{align}\nE\\big\\{y_i(u)\\mid T_i^*>t,\\mathcal{Y}_i(t),\\mathcal{D}_n\\big\\}\\\\=\\quad\\int E\\big\\{y_i(u)\\mid T_i^*>t,\\mathcal{Y}_i(t);\\theta\\big\\}p(\\theta\\mid\\mathcal{D}_n)d\\theta\n\\tag{7.8}\n\\end{align}\\]被积函数的第一部分可通过利用条件独立假设 (4.7) 和 (4.8) 来简化，如下所示\\[\\begin{align}\nE\\big\\{y_i(u)&\\mid T_i^*>t,\\mathcal{Y}_i(t);\\theta\\big\\} \\\\\n&=\\quad\\int E\\big\\{y_i(u)\\mid T_i^*>t,\\mathcal{Y}_i(t),b_i;\\theta\\big\\}p(b_i\\mid T_i^*>t,\\mathcal{Y}_i(t);\\theta)db_i \\\\\n&=\\quad\\int E\\big\\{y_i(u)\\mid b_i\\big\\}p(b_i\\mid T_i^*>t,\\mathcal{Y}_i(t);\\theta)db_i \\\\\n&=\\quad\\int\\{x_i^\\top(u)\\beta+z_i^\\top(u)b_i\\}p(b_i\\mid T_i^*>t,\\mathcal{Y}_i(t);\\theta)db_i \\\\\n&=\\quad x_i^\\top(u)\\beta+z_i^\\top(u)\\bar{b}_i^{(t)}\n\\tag{7.9}\n\\end{align}\\]其中\\[\\bar{b}_i^{(t)}=\\int b_ip(b_i\\mid T_i^*>t,\\mathcal{Y}_i(t);\\theta)db_i\\]在这些推导下，通过简单地将 \\(\\theta\\) 替换为 \\(\\hat theta\\)，并计算后验分布 \\(p(b_i\\mid T_i^*>t,\\mathcal{Y}_i(t);\\hat{\\theta})\\) 的均值即可获得 \\(\\omega_i(u | t)\\) 的直接估计。本着同样的精神，当我们使用后验分布 \\(\\hat{b}_i^{(t)}=\\arg\\max_b\\log p(b\\mid T_i^*>t,\\mathcal{Y}_i(t);\\hat{\\theta})\\) 的众数 \\(\\bar{b}_i^{(t)}\\)，即\\[\\begin{align}\n\\tilde{\\omega}_i(u\\mid t)=x_i^\\top(u)\\hat{\\beta}+z_i^\\top(u)\\hat{b}_i^{(t)}+O(n_i^{-1})\n\\tag{7.10}\n\\end{align}\\]如下的标准关系式证明了这一点 (Tierney Kadane, 1986)\\[\\bar{b}_i^{(t)}=\\hat{b}_i^{(t)}+O\\big([n_i(t)]^{-1}\\big)\\]在 \\(\\log p(b\\mid T_i^*>t,\\mathcal{Y}_i(t);\\hat{\\theta})\\) 足够平滑的情况下成立，其中 \\(n_i(t)\\) 表示受试者 \\(\\) 在时间 \\(t\\) 时的纵向响应数。正如我们在 4.5 节所指出的，随机效应的后验分布的均值和众数通常非常接近，因此我们也期望上述两个 \\(\\omega_i(u | t)\\) 估计之间的差异可以忽略不计。出于实际目的，我们更喜欢估计 (7.10)，因为众数通常是比均值更好的位置度量，特别是当后验分布偏斜时。然而，获得两个估计量任何一个的标准误都非常困难，因为 \\(\\hat b_i(t)\\) 和 \\(\\hat b_i(t)\\) 都是 \\(\\hat\\theta\\) 的非线性函数，无法写成封闭形式。为了克服这个问题并获得 \\(\\omega_i(u | t)\\) 的置信区间，我们使用与 7.1.2 节中类似的蒙特卡罗方法。具体来说，将 (7.8) 与 (7.9) 结合起来，并再次假定样本量足够大，使得 \\(\\{\\theta |\\mathcal D_n\\}\\) 可以很好地近似为以最大似然估计 \\(\\hat\\theta\\) 为中心的正态分布，并使用观测信息矩阵的逆矩阵 \\(\\operatorname{var}(\\hat{\\theta})=\\{\\mathcal{}(\\hat{\\theta})\\}^{-1}\\) 作为方差-协方差阵，我们得到以下模拟方案步骤 1：抽取 \\(\\theta^{(l)}\\sim\\mathcal{N}\\{\\hat{\\theta},\\text{v}\\hat{\\mathrm{}}\\text{r}(\\hat{\\theta})\\}\\)步骤 2：抽取 \\(b_i^{(l)}\\sim\\{b_i\\mid T_i^*>t,\\mathcal{Y}_i(t),\\theta^{(l)}\\}\\)步骤 3：计算 \\(\\omega_i^{(l)}(u\\mid t)=x_i^\\top(u)\\beta^{(l)}+z_i^\\top(u)b_i^{(l)}\\)步骤 1 和 2 与 7.1.2 节的模拟方案完全相同，分别用于考虑 \\(\\hat\\theta\\) 和 \\(\\hat b_i(t)\\) 的变异。使用模拟值的参数和随机效应，步骤 3 仅需要计算未观测纵向结果 \\(y_i(u)\\) 的预测值。相应的 95% 逐点置信区间可以从 \\(\\{\\ometa_i^{(l)}(u | t), l = 1,\\ldots,L\\}\\) 的 2.5% 和 97.5% 百分位数获得。上述模拟方案的一个有利特征是可以容易地对其修改以产生预测区间。更具体地说，我们不是将 \\(\\omega_i^{(l)}(u | t)\\) 设置为特定于受试者均值的实现，而是模拟相应正态分布的值，即 \\(\\omega_i^{(l)}(u\\mid t)\\sim\\mathcal{N}\\big\\{x_i^\\top(u)\\beta^{(l)}+z_i^\\top(u)b_i^{(l)},[\\sigma^{(l)}]^2\\big\\}\\)。此外，请注意，与 7.1.2 节类似，我们也可以使用蒙特卡罗实现来估计 \\(\\omega_i(u | t)\\)，即\\[\\begin{align}\n\\hat{\\omega}_i(u\\mid t)=L^{-1}\\sum_{l=1}^L\\omega_i^{(l)}(u\\mid t)\n\\tag{7.11}\n\\end{align}\\]或\\[\\begin{align}\n\\hat{\\omega}_i(u\\mid t)=\\text{median}\\{\\omega_i^{(l)}(u\\mid t),l=1,\\ldots,L\\}\n\\tag{7.12}\n\\end{align}\\]然而，(7.11) 和 (7.12) 与 (7.10) 的数值比较表明，这些估计值几乎无法区分。因此，为简单起见，我们使用 \\(\\omega_i(u | t)\\) 进行点估计，并使用蒙特卡罗方法来导出置信区间或预测区间。纵向结果的特定于受试者的预测是在 R 中使用函数 predict() 生成的。我们已经在 4.4.2 节中看到了该函数，它被用来生成平均纵向演变 \\(\\mu = X\\beta\\) 的估计，以及它们相应的逐点置信区间。该函数的主要参数是感兴趣的拟合联合模型和数据框 newdata，提供预测的基础数据。对于特定于受试者的预测，该数据框应包含基线协变量和截至时间 \\(t\\) 的纵向响应，这将用于估计 \\(\\omega_i(u | t),u > t\\)。默认情况下，predict() 将生成平均纵向演变的预测。当需要特定于受试者时，我们设置选项 type=\"Sbuject\"。下文将说明如何使用此函数为 PBC 研究中的患者 2 生成 \\(\\omega_i(u|t)\\) 的估计以及相应的置信度区间，基于模型 jointFitBsp.pbc。关于上面给出的 \\(\\omega_i(u|t)\\) 的估计，函数 predict() 返回根据 (7.10) 的估计作为预测，当调用选项 interval = \"confidence\" 时，它使用蒙特卡罗方案来计算标准误和置信区间22。为了说明当记录额外的血清胆红素测量值时，如何更新患者 2 的预测，我们使用 循环，每次迭代时更新 newdata 参数。predict() 的默认输出是 newdata 中包含的每个个体的预测值的向量。默认情况下，计算这些预测的时间点 \\(u\\) 被选择为从 \\(t\\)（受试者的最后一次可用测量）到 \\(t_\\max+\\varepsilon\\) 的长度为 25 的规则序列，其中 \\(t_\\max\\) 表示手头样本中的最大随访时间，而 \\(\\varepsilon\\) 是一个小数字23。然而，通过将参数 returnData 设置为 TRUE，predict() 的输出是在 newdata 中提供的数据框，并为每个受试者在时间点 \\(u\\) 的预测增加了额外的行。forloop 的最后一行为 predict() 返回的数据框添加了一列额外的列，表示记录纵向响应的最后随访时间 \\(t\\)。为了可视化结果估计，我们首先使用代码在单个数据框中收集所有结果第二行将保存最后一个可用时间点的列 FollowUp 转换为具有适当水平的因子。使用该数据框，以下代码生成纵向结果的动态预测图该图的更详细版本如图 7.5 所示24。正如预期的那样，我们观察到预测区间的宽度随着时间的推移而增加，这表明我们对上次可用纵向测量后不久的预测更有信心。这些预测区间的一个重要特征是，它们不被限制为对称的，因为它们不基于 \\(\\hat\\omega_i(u|t)\\) 的渐近正态性。具体来说，我们希望蒙特卡罗方法能够为 \\(\\omega_i(u|t)\\) 的真实抽样分布提供相对较好的近似值，从而获得更有可能满足所要求的覆盖范围的置信区间。","code":"> ND <- pbc2[pbc2$id == 2, ]\n> longPreds <- vector(\"list\", nrow(ND))\n> for (i in 1:nrow(ND)) {\n  set.seed(123) # we set the seed for reproducibility\n  longPreds[[i]] <- predict(jointFitBsp.pbc, newdata = ND[1:i, ],\n  type = \"Subject\", interval = \"confidence\", returnData = TRUE)\n  longPreds[[i]]$FollowUp <- round(max(ND[1:i, \"year\"]), 1)\n}> longPreds.all <- do.call(rbind, longPreds)\n> longPreds.all$FollowUp <- with(longPreds.all, factor(FollowUp,\n      labels = paste(\"Follow-up time:\", unique(FollowUp))))> xyplot(pred + low + upp ~ year | FollowUp, data = longPreds.all,\n         lty = c(1, 2, 2), type = \"l\", as.table = TRUE,\n         xlab = \"Time\", ylab = \"Predicted log serum bilirubin\")"},{"path":"chap7.html","id":"sec7-3","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.3 参数化对预测的影响","text":"在前面的部分中，我们已经了解了如何在拟合的联合模型下获得生存或纵向结果的动态预测。然而，在决定在实践中使用这些预测之前，我们应该首先调查它们的稳定性和质量。这些预测的质量通常取决于两个因素，首先，取决于纵向标志物本身预测未来事件的能力，其次，取决于联合模型的正确制定，以揭示该标志物的真实预测性能。显然，第一个因素主要与标志物试图描述的生物机制以及该机制与事件结果的相关程度有关。假设基于强大的生物学背景选择了标志物，则联合建模练习的目的是揭示标志物过程的哪些特征与事件风险最密切相关。由于我们处理的是时依标志物，事件的风险可能取决于纵向历史 \\(\\mathcal M_i(t) = \\{m_i(s), 0 \\le s < t\\}\\) 的复杂函数。具体地，正如我们在 5.1 节中所看到的，有各种参数化可用于连接这两个结果，并且如图 5.3 所示，它们可以显著影响特定于受试者的风险函数估计的形状。\n为研究纵向和事件时间结果之间的假定关联结构如何影响导出的特定于主题的预测，我们在不同的参数化下进行了敏感性分析。为进行说明，我们将使用 PBC 研究中的 51 号患者，其血清胆红素测量对数的纵向轨迹如图 7.6 所示。我们可以观察到，该患者前三次就诊时胆红素水平稳定，但随后她的纵向曲线急剧增加，表明她的病情恶化。在我们的敏感性分析中，我们将对复合事件（死亡或移植）的相对风险子模型的六个不同指定的联合模型进行比较，即：以及相同的纵向子模型，如 7.1.3 节所示，该模型使用 B 样条来灵活地捕捉特定于受试者的纵向轨迹形状：\\[\\begin{array}{rcl}y_i(t)&=&m_i(t)+\\varepsilon_i(t)\\\\&=&(\\beta_0+b_{i0})+(\\beta_k+b_{ik})^\\top B(t,4,4)+\\varepsilon_i(t)\\end{array}\\]相对风险模型（）-（III）假设，在时间 \\(t\\) 发生复合事件的风险分别取决于同一时间点的对数血清胆红素的真实水平、\\(t\\) 处真实轨迹的斜率或 \\(t\\) 处的真实水平和斜率。类似地，模型（IV）-（VI）假设了相同类型的关系，但也包括标志物的真实水平和/或轨迹斜率与基线异常凝血酶原时间的虚拟变量之间的交互作用项。在继续在 R 中拟合这些模型之前，我们首先需要在 \\(m_i(t)\\) 的 B 样条表示下导出导数 \\(m'_i (t)\\) 的表达式。从标准 B 样条理论可知，该导数也可以用 B 样条基函数来编写 (Dierckx, 1993, Section 1.3.2). 具体地，将 \\(m_i(t)\\) 重写为以下形式\\[\\begin{aligned}m_i(t)=(\\beta_0+b_{i0})+\\sum_k(\\beta_k+b_{ik})B_k(t,q)\\end{aligned}\\]其中 \\(B_k(t, q)\\) 表示结 \\(\\lambda_k\\) 处 \\(q\\) 阶的 B 样条基，其导数由以下表达式给出\\[\\begin{aligned}m_i'(t)=(q-1)\\sum_k\\frac{c_{,k+1}-c_{,k}}{\\lambda_{k+q+1}-\\lambda_k}B_k(t,q-1)\\end{aligned}\\]其中 \\(c_{;k} = \\beta_k + b_{ik}\\)。为了使用 R 的公式接口指定真实轨迹的斜率，我们使用混合效应模型公式重写 \\(m'_i (t)\\)，即\\[\\begin{aligned}m_{}^{\\prime}(t)&=\\quad[x_{}^{sl}(t)]^{\\top}\\beta^{sl}+[z_{}^{sl}(t)]^{\\top}b_{}^{sl}\\\\&=\\quad(q-1)B(t,\\lambda,q-1)^\\top(\\beta_{k,-1}/D\\lambda)-qB(t,\\lambda,q-1)^\\top(\\beta_{k,-c}/D\\lambda)\\\\&\\quad+qB(t,\\lambda,q-1)^\\top(b_{ik,-1}/D\\lambda)-qB(t,\\lambda,q-1)^\\top(b_{ik,-c}/D\\lambda)\\end{aligned}\\]其中 \\(\\lambda\\) 表示 \\(m_i(t)\\) 指定中 B 样条基的结，\\(D\\lambda\\) 表示 \\(\\lambda\\) 的 \\(q+1\\) 阶差分，\\(\\beta_{k,-l}\\) 和 \\(b_{ik,-l}\\) 分别表示固定效应和随机效应 \\(\\beta_k\\) 和 \\(b_{ik}\\) 的向量但不包括其中第 \\(l\\) 个元素，而 \\(c\\) 表示最后一个元素。对于我们的例子，由于我们只有一个内部结，在 \\(m'_i(t)\\) 的分母中，项 \\(D\\lambda k=\\lambda k+q+1-\\lambda k\\) 总是等于边界结的极差，我们手动将其设置为随访时间 \\(t_{ij}\\) 和观测事件时间 \\(T_i\\) 的组合范围。拟合纵向和生存子模型的代码 7.1.3 节相同，即为了拟合包含斜率项 \\(m'_i (t)\\) 的联合模型，我们首先需要适当地指定在 5.1.3 节中介绍的 jointModel() 的 derivForm 参数，使用适当的 R 公式来构造该项的固定和随机效应设计矩阵。这些采用以下形式\\(m'_i(t)\\) 指定中的 B 样条基应在与 \\(m_i(t)\\) 的 B 样条基完全相同的结处计算。为此，我们首先使用代码提取内部结的值然后，我们分别使用 knots 和 boundary.nots 参数在 bs() 调用中手动设置内部结和边界结。此外，Degree 参数指定 B 样条线的次数，默认设置为 3，这意味着 B 样条的次数 q 为 4。因此，在上述公式中，为了构造项 \\((q − 1)B(t, \\lambda, q − 1)\\)，我们将 B 样条基乘以 3，并将其次数设置为 2. dform 列表的 indFixed 分量对应于构造向量 ${sl}=({k,-1}^,{k,-c})^$ 的索引，并且 indRandom 的定义类似。上面（）-（VI）给出的六个联合模型及其相应的相关子模型在 R 中用代码进行拟合六个相对风险子模型的回归系数估计（以及相关的标准误和 \\(p\\) 值）如表 7.1 所示。为了说明预测在不同参数化下是如何受到影响的，我们在图 7.7 和 7.8 中显示了 PBC 研究中患者 51 的纵向结果动态更新预测 \\(\\omega_i(u|t)\\) 和事件结果动态更新条件生存概率 \\(\\pi_i(u| t)\\) 的估计。在这些图的每个面板中，\\(t\\) 被设为最后可用纵向响应的时间点，并且 \\(u=t+1\\)。从图 7.7 中我们清楚地观察到，纵向结果的预测及其相应的标准误受所选关联结构的影响最小。相反，从图 7.8 中可以看出，对于某些时间点 \\(u\\)，条件生存概率估计 \\(\\pi_i(u|t)\\) 在六种不同的参数化之间表现出相当大的变异性。例如，我们观察到，基于仅考虑斜率项 \\(m'_i(t)\\) 影响的联合模型（II）和（V），前三次就诊中的每一次就诊后的预测显示出比同样以当前值 \\(m_i(t)\\) 为条件的其他模型更大的标准误。然而，对于后一个时间点，特别是在第六次就诊（即 \\(u＝5.5\\)）之后，出现了相反的行为，模型（II）和（V）显示出比其他模型更高的生存概率和更小的标准误。这可以通过患者 51 的纵向曲线的形状来解释（见图 7.6），在前五次就诊期间，纵向曲线更加非线性，但在之后趋于稳定。\n我们的预测应该基于六个模型中的哪一个，这可以基于标准的似然信息方法。表 7.2 列出了所有六个模型的 AIC 和 BIC 值，以及将完整模型（VI）与其他五个缩减模型进行比较的五个似然比检验的结果。AIC 选择完整模型作为最合适的模型，而 BIC 模型（IV）假设只有标记物的当前值与复合事件的风险相关，但这种关联的强度在凝血酶原时间正常和异常的患者之间不同。似然比检验建议模型（IV），因为对于其他模型，存在比完整模型（VI）中更差的拟合的证据。","code":"> lmeFitBsp.pbc <- lme(\n  fixed = log(serBilir) ~ bs(year, 4, Boundary.knots = c(0, 15)),\n  random = list(\n  id = pdDiag(form = ~ bs(year, 4, Boundary.knots = c(0, 15)))),\n  data = pbc2)\n> coxFit.pbc <- coxph(Surv(years, status2) ~ drug + Pro,\n                      data = pbc2.id, x = TRUE)> dform <- list(\n  fixed = ~ -1\n  + I(3 * bs(year, knots = 2.0534443,\n    Boundary.knots = c(0, 15), degree = 2) / 15)\n  + I(-3 * bs(year, knots = 2.0534443,\n    Boundary.knots = c(0, 15), degree = 2) / 15),\n  indFixed = c(3,4,5,2,3,4),\n  random = ~ -1\n  + I(3 * bs(year, knots = 2.0534443,\n    Boundary.knots = c(0, 15), degree = 2) / 15)\n  + I(-3 * bs(year, knots = 2.0534443,\n    Boundary.knots = c(0, 15), degree = 2) / 15),\n  indRandom = c(3,4,5,2,3,4))> attr(lmeFitBsp.pbc$terms, \"predvars\")\nlist(log(serBilir), bs(year, degree = 3L, knots = 2.0534443105903,\n                       Boundary.knots = c(0, 15), intercept = FALSE))> jointFitBsp.pbc <- jointModel(lmeFitBsp.pbc, coxFit.pbc,\n                                timeVar = \"year\", method = \"piecewise-PH-aGH\")\n> jointFitBsp2.pbc <- update(jointFitBsp.pbc,\n                             parameterization = \"slope\", derivForm = dform)\n> jointFitBsp3.pbc <- update(jointFitBsp.pbc,\n                             parameterization = \"both\", derivForm = dform)\n> jointFitBsp4.pbc <- update(jointFitBsp.pbc,\n                             interFact = list(value = ~ Pro, data = pbc2.id))\n> jointFitBsp5.pbc <- update(jointFitBsp2.pbc,\n                             interFact = list(slope = ~ Pro, data = pbc2.id))\n> jointFitBsp6.pbc <- update(jointFitBsp3.pbc,\n                             interFact = list(value = ~ Pro, slope = ~ Pro, data = pbc2.id))"},{"path":"chap7.html","id":"sec7-4","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.4 联合模型的前瞻准确性","text":"上一节表明，标志物过程的不同特征可能比其他特征与事件风险的相关性更强。当对包含纵向和生存部分的联合模型的整体预测能力感兴趣时，信息准则（例如 AIC 和 BIC）可能很有用。然而，通常重点可能主要在于生存结果，特别是确定纵向标记在预测该结果方面的效果如何。这个问题的答案在文献中受到了广泛关注，其中出现了两条研究主线。第一个侧重于校准措施以及模型预测观测数据的效果（Graf et al, 1999; Schemper Henderson, 2000; Henderson et al., 2002; Gerds Schumacher, 2006)，第二个侧重于判别度量以及该模型如何区分将在短时间内经历该事件的患者与将在以后经历该事件的患者 (Harrell et al., 1982; Heagerty et al., 2000; Heagerty Cheng, 2005; Antonolini et al, 2005; Pencina et al., 2008). 在本节中，我们重点关注后一类指标，并依靠受试者工作特征 (ROC) 方法来评估纵向标记区分事件低风险和高风险的患者的能力。","code":""},{"path":"chap7.html","id":"sec7-4-1","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.4.1 二项结果的判别度量","text":"为了介绍判别度量背后的基本概念，我们将首先考虑简单的二元响应设定。具体地，令 \\(d_i\\) 表示受试者 \\(\\) 的疾病状态指示符，其取值 1 或 0，具体取决于受试者是否经历过感兴趣的事件。还令 \\(y_i\\) 表示在基线处测量的标量标志物，其被认为与疾病概率密切相关。我们的目的是利用观测标志物值来识别“患病”几率更大的受试者。为实现这一点，我们构建了一个适当的预测规则，当受试者 \\(\\) 的观测标记物水平超过特定阈值时，即 \\(y_i>c\\)，将其分类为患病。基于该规则，我们现在可以使用基于疾病状态的正确分类概率来量化标志物的性能。具体地，标志物将受试者正确分类为患病的概率称为灵敏度 (sensitivity)（也称为真阳性率）\\[\\begin{aligned}\\text{TP}(c)=\\text{Pr}(y_i>c\\mid d_i=1)\\end{aligned}\\]而标志物正确地将受试者分类为未患病的概率称为特异度 (specificity)\\[\\begin{aligned}1-\\operatorname{FP}(c)=\\operatorname{Pr}(y_i\\leq c\\mid d_i=0)\\end{aligned}\\]其中 \\(\\operatorname{FP}(c)=\\operatorname{Pr}(y_i>c\\mid d_i=0)\\) 表示假阳性率。请注意，这些概率度量特定规则 \\(\\{y_i > c\\}\\) 的预测准确性。为了描述标志物的整体区分能力，我们计算所有可能的预测规则 \\(\\{y_i > c, c \\\\mathbb R_y\\}\\) 的灵敏度和特异度，其中 \\(\\mathbb{R}_y\\subseteq\\mathbb{R}\\) 表示标志物的样本空间，\\(\\mathbb R\\) 是实数集。这就得到了 ROC 曲线，它是针对不同 c 的真阳性率（灵敏度）与假阳性率（1 − 特异性）的关系图，正式定义为\\[\\begin{aligned}\\operatorname{ROC}(p)=\\operatorname{TP}\\{\\operatorname{FP}^{-1}(p)\\}\\end{aligned}\\]其中 \\(p\\) 在 \\([0, 1]\\) 中，且 \\(\\text{FP}^{-1}(p)=\\inf_c\\{c:\\text{FP}(c)\\leq p\\}\\)。图 7.9 给出了 ROC 曲线的一般示例。左图显示患病组和非患病组中标志物水平的箱线图，右图显示相应的 ROC 曲线。左图中的虚线对应于规则 \\(y_i > 35\\)，右图中的虚线注释了该规则在灵敏度和 1 – 特异性方面的表现。ROC 曲线在单位象限内越高，预测规则越准确。ROC 曲线下面积 (AUC) 给出了所有可能阈值 c 的标记物预测准确性指数的总结，定义为：\\[\\begin{aligned}\\text{AUC}&=\\int_0^1\\text{ROC}(p)dp\\end{aligned}\\]\n等价公式提供了对 AUC 更直观的解释 (Hanley McNeil, 1982)\\[\\begin{align}\n\\text{AUC}=\\Pr(y_i>y_j\\mid d_i=1,d_j=0)\n\\tag{7.13}\n\\end{align}\\]这假设，对于任何随机的“可比”受试者对子 \\(\\{,j\\}\\)（即其状态可以进行排序的受试者，例如一个患病和另一个未患病），AUC 表示两个受试者的标志物水平排序与其疾病状态排序一致的概率。AUC 等于 1 表示最大的判别力，而 AUC=0.5 表示随机判别力（即，该标标志物在判别患者方面并不比扔硬币更好）。ROC 方法的一个关键优势是可以用于比较不同的候选标志物。例如，对于 HIV 感染的患者，人们可能想要将 CD4 细胞计数与病毒载量进行比较，或者在感染前后观察到的 CD4 的即时变化是否比 CD4 的基线水平提供更好的准确性。有关连续标志物的 ROC 曲线的更多背景信息，请参阅 Krzanowski Hand (2009).","code":""},{"path":"chap7.html","id":"sec7-4-2","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.4.2 生存结果的判别度量","text":"为了将灵敏度和特异度的定义从上一节中介绍的二元设定扩展到生存数据，我们将事件时间视为与时间相关的二元结果，事件前所有时间点的值为 0，事件后的值为 1. 事实上，这种生存时间的表示等同于 3.5 节中引入的事件时间结果 \\(N_i(t)=(t\\geq T_i^*)\\) 的计数过程表示。二元结果 \\(N_i(t)\\) 的时依性考虑根据受试者在任何特定时间点 \\(t\\) 被分类为“病例”或“对照”的方式，对灵敏度和特异度进行几种潜在的定义。Heagerty Zheng (2005) 提出了我们在这种情况下不同的分类法。仍然集中在用作事件预测因子的标量标志物 \\(y_i\\) 上，三个主要的准确性度量族是累积灵敏度/动态特异度：\\[\\begin{aligned}\\operatorname{TP}_t^\\mathbb{C}(c):\\quad&\\Pr(y_i>c\\mid T_i^*\\le t)\\\\1-\\operatorname{FP}_t^\\mathbb{D}(c):\\quad&\\Pr(y_i\\le c\\mid T_i^*>t)\\end{aligned}\\]\n根据这些定义，在任何固定时间 \\(t\\)，整个总体根据其在时间 \\(t\\) 时的事件状态被分类为病例或对照。此外，每个受试者在时间 \\(t < T^*_i\\) 中为控制，但当 \\(t \\ge T^*_i\\) 时成为病例。事件灵敏度/静态特异度：\\[\\begin{aligned}\\mathrm{TP}_t^\\mathbb{}(c):\\quad&\\Pr(y_i>c\\mid T_i^*=t)\\\\1-\\mathrm{FP}_{\\tilde{t}}^\\mathbb{S}(c):\\quad&\\Pr(y_i\\le c\\mid T_i^*>\\tilde{t})\\end{aligned}\\]\n这些定义已被 Etzioni et al. (1999) 以及 Slate Turnbull (2000) 采用，并假定每个受试者不会改变状态，并且被分类为病例或对照。病例根据事件发生的时间进行分层，对照被定义为在固定的随访期 \\((0,\\tilde t)\\) 内没有发生事件的受试者。事件灵敏度/动态特异度：\\[\\begin{aligned}\\mathrm{TP}_t^\\mathbb{}(c):\\quad&\\Pr(y_i>c\\mid T_i^*=t)\\\\1-\\mathrm{FP}_t^\\mathbb{D}(c):\\quad&\\Pr(y_i\\leq c\\mid T_i^*>t)\\end{aligned}\\]\n在这种方法下，受试者可以在所有 \\(t < T^*_i\\) 中扮演控制的角色，但当 \\(t = T^*_i\\) 时则扮演病例的角色。这里，灵敏度度量在 \\(t\\) 发生事件的个体亚组中标志物水平超过阈值 \\(c\\) 的受试者的预期比例，而特异度衡度量在时间 \\(t\\) 之后存活的受试者中标志物水平低于或等于 \\(c\\) 的受试者的比例。所有上述定义的一个重要特征是它们是时依的，这意味着标志物区分病例和控制的能力随着时间的推移而变化。在选择时依灵敏度和特异度的定义之后，ROC 曲线和这些曲线下的面积可以以与在二元设定中相同的方式来计算和解释。这些度量也将是时变的，并反映了标志物的准确性在随访中是如何演变的。","code":""},{"path":"chap7.html","id":"sec7-4-3","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.4.3 纵向标志物的预测规则","text":"继 Rizopoulos (2011) 以及 Cheng Heagerty (2007) 之后，我们现在将上一节的时依准确性度量框架扩展到纵向标志物的情况。正如前面所指出的，需要联合建模方法来回答感兴趣的科学问题的研究的固有特征是它们的动态性质。也就是说，当收集受试者的纵向信息时，我们可以不断更新对其生存概率的预测。考虑到这一特征，区分将在上次测量后的一段时间内经历该事件的患者与将在没有事件的情况下超过该时间段的患者通常具有医学相关性。在这种情况下，纵向标志物的一个有用特性是成功地区分这些患者。具体地，和以前一样，对于受试者 \\(\\) 直到时间 \\(t\\)，我们假定我们已经收集了一组纵向测量值 \\(\\mathcal{Y}_i(t)=\\{y_i(s);0\\leq s<t\\}\\)。我们感兴趣的是在医学相关时间范围 \\((t,t+\\Delta t]\\) 内发生的事件，在该时间范围内医生可以采取行动（例如，开始或改变治疗）以提高该患者的生存机会。使用标志物历史 \\(\\mathcal Y_i(t)\\) 的适当函数，我们可以定义预测规则来区分事件高风险和低风险的患者。例如，对于 PBC 患者，我们可以将血清胆红素对数值大于特定阈值视为死亡的预测。由于我们处于纵向环境中，因此我们可以灵活地确定患者的纵向历史 \\(\\mathcal Y_i(t)\\) 的哪些值将有助于预测规则的规范。为了实现完全通用性，我们考虑阈值 \\(c\\) 的向量，基于该向量我们定义\\[\\mathcal{P}_i^s(t,k,c)=\\{y_i(s)\\geq c_s;k\\leq s\\leq t\\}\\]作为“成功”，即，标志物指示事件将发生，并且\\[\\begin{aligned}\\mathcal{P}_i^f(t,k,c)=\\mathbb{R}^{r(k,t)}\\setminus\\{y_i(s)\\geq c_s;k\\leq s\\leq t\\}\\end{aligned}\\]为“失败”，其中 \\(\\mathcal R_n\\) 表示 \\(n\\) 维欧几里得空间，\\(r(k, t)\\) 表示在区间 \\([k, t]\\) 内进行的纵向测量的次数。\\(k \\ge 0\\) 的值指定纵向历史的哪些过去标志物值对规则有贡献，\\(c_s\\) 表示时间点 \\(s\\) 的阈值。这些预测规则的惯例是，标志物值越大，死亡风险越高。当情况相反时，例如我们使用 CD4 细胞计数作为 HIV 感染患者的标志物，这些定义应相应调整。为了证明 \\(\\mathcal{P}_i^s(t,k,c)\\) 的完全通用性以及我们在定义预测规则时不同的范围，我们给出了三个示例：示例 1：最简单且最常用的预测规则仅利用最后可用的纵向测量来驱动决策，即\\[\\mathcal{P}_i^s(t,k,c)=\\{y_i(t)\\geq c\\}\\]该规则代表了我们在 7.4.1 和 7.4.2 节中看到的基线标志物预测规则的时依的类似物。具体地，对于任何时间点 \\(t\\)，如果患者在同一时间点观察到的标志物水平超过特定阈值 \\(c\\)，我们会将患者归类为经历该事件的高风险组。示例 2：尽管前面的规则在实践中简单易用，但它的缺点是使用单一标志物测量，因此它丢弃了有用的信息。一个小的扩展是在两个时间点使用标志物值，例如：\n\\[\\begin{aligned}\\mathcal{P}_i^s(t,k,c)=\\{y_i(t-1)\\geq c\\}\\cap\\{y_i(t)\\geq c\\}\\end{aligned}\\]\n如果患者的标志物水平在时间点 \\(t\\) 和 \\(t−1\\) 都超过了相同的阈值 \\(c\\)，则该规则将在时间 \\(t\\) 将患者归类为高风险组。示例 2：尽管前面的规则在实践中简单易用，但它的缺点是使用单一标志物测量，因此它丢弃了有用的信息。一个小的扩展是在两个时间点使用标志物值，例如：\n\\[\\begin{aligned}\\mathcal{P}_i^s(t,k,c)=\\{y_i(t-1)\\geq c\\}\\cap\\{y_i(t)\\geq c\\}\\end{aligned}\\]\n如果患者的标志物水平在时间点 \\(t\\) 和 \\(t−1\\) 都超过了相同的阈值 \\(c\\)，则该规则将在时间 \\(t\\) 将患者归类为高风险组。示例 3：对示例 2 的进一步增强是考虑预测规则捕获患者病情的恶化。这可以通过绝对增加预测规则来实现，例如，\n\\[\\mathcal{P}_i^s(t,k,c)=\\{y_i(t-1)\\geq c\\}\\cap\\{y_i(t)\\geq c+\\nu\\},\\quad\\nu>0\\]\n它正式化了这样一种想法，如果患者表现出 \\(ν\\) 个单位标志物水平的绝对增加，或相对增加预测规则，则患者经历该事件的机会更高，例如\n\\[\\begin{aligned}\\mathcal{P}_i^s(t,k,c)=\\{y_i(t-1)\\geq c\\}\\cap\\{y_i(t)\\geq(1+\\nu)c\\},\\quad\\nu>0\\end{aligned}\\]\n类似地，如果患者的标记物水平增加了 \\((100 × ν)%\\)，那么她经历该事件的机会就更高。示例 3：对示例 2 的进一步增强是考虑预测规则捕获患者病情的恶化。这可以通过绝对增加预测规则来实现，例如，\n\\[\\mathcal{P}_i^s(t,k,c)=\\{y_i(t-1)\\geq c\\}\\cap\\{y_i(t)\\geq c+\\nu\\},\\quad\\nu>0\\]\n它正式化了这样一种想法，如果患者表现出 \\(ν\\) 个单位标志物水平的绝对增加，或相对增加预测规则，则患者经历该事件的机会更高，例如\n\\[\\begin{aligned}\\mathcal{P}_i^s(t,k,c)=\\{y_i(t-1)\\geq c\\}\\cap\\{y_i(t)\\geq(1+\\nu)c\\},\\quad\\nu>0\\end{aligned}\\]\n类似地，如果患者的标记物水平增加了 \\((100 × ν)%\\)，那么她经历该事件的机会就更高。我们将基于单一标志物评估的规则（如示例 1）称为简单预测规则，将涉及多个标志物评估的规则（如示例 2 和 3）称为复合预测规则。由于我们的兴趣在于利用截至时间 \\(t\\) 的观测标记物水平 \\(\\mathcal Y_i(t)\\) 来预测医学相关区间 \\((t, t + \\Delta t]\\) 中的事件，因此灵敏度和特异度分别定义为\\[\\begin{align}\n\\mathrm{TP}_t^{\\Delta t}(c)=\\mathrm{Pr}\\big\\{\\mathcal{P}_i^s(t,k,c)\\mid T_i^*>t,T_i^*\\(t,t+\\Delta t];\\theta^*\\big\\}\n\\tag{7.14}\n\\end{align}\\]以及\\[\\begin{align}\n1-\\operatorname{FP}_t^{\\Delta t}(c)=\\operatorname{Pr}\\big\\{\\mathcal{P}_i^f(t,k,c)\\mid T_i^*>t,T_i^*>t+\\Delta t;\\theta^*\\big\\}\n\\tag{7.15}\n\\end{align}\\]根据 7.4.2 节中 Heagerty Zheng (2005) 的分类，上述规范分别对应于累积灵敏度和动态特异度。此外，请注意，这些准确性度量不仅取决于时间，还取决于医学相关时间区间 \\(\\Delta t\\) 的长度。这意味着对于相同的 \\(t\\)，不同的模型可能对不同的 \\(\\Delta t\\) 表现出不同的判别能力。与之前一样，可以使用相应的 ROC 曲线来评估纵向标志物对所有可能阈值 \\(c\\\\mathbb{R}_y\\) 的整体判别能力\\[\\begin{aligned}\\operatorname{ROC}_t^{\\Delta t}(p)=\\operatorname{TP}_t^{\\Delta t}\\{[\\operatorname{FP}_t^{\\Delta t}]^{-1}(p)\\}\\end{aligned}\\]其中 \\(p\\) 位于 \\([0, 1]\\) 和 \\([\\mathrm{FP}_t^{\\Delta t}]^{-1}(p)=\\inf_c\\{c:\\mathrm{FP}_t^{\\Delta t}(c)\\leq p\\}\\) 中，以及 ROC 曲线下面积\\[\\begin{aligned}\\mathrm{AUC}_t^{\\Delta t}&=\\int_0^1\\mathrm{ROC}_t^{\\Delta t}(p)dp\\end{aligned}\\]","code":""},{"path":"chap7.html","id":"sec7-4-4","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.4.4 判别指数","text":"到目前为止，我们提出的所有生存数据准确性度量的一个重要特征是，它们描述了标志物（基线或时依的）在特定随访时间 \\(t\\) 时区分患者的能力。因此，在不同的时间点，标志物可能表现出不同程度的区分能力，因此一个相关的问题是我们如何总结标记在整个随访期间的区分能力。为了评估基线标志物的整体性能，Harrell et al. (1982) 提出了基于 Kendall-Goodman-Kruskal-Somers 型等级相关系数 (Goodman Kruskal, 1979) 修改的一致性指数. 这可以看作是 AUC (7.13) 定义在具有时依疾病状态的二元背景下的扩展。也就是说，对于一对随机的受试者 \\(\\{, j\\}\\)，其真实事件时间可以排序，使得受试者 \\(\\) 在受试者 \\(j\\) 之前经历该事件，那么我们感兴趣的是他们的标志物水平与其事件时间一致的概率，即\\[\\begin{align}\n\\mathrm{C}_h=\\Pr(y_i>y_j\\mid T_i^*<T_j^*)\n\\tag{7.16}\n\\end{align}\\]事实上，这个全局准确性总结指数与 7.4.2 节中介绍的时依 ROC 曲线相关。具体地，在这种情况下，Heagerty Cheng (2005) 已经表明，\\(\\mathrm{C}_h\\) 指数 (7.16) 可以等价地导出为分别从灵敏度和特异度的发生率/动态定义获得的 AUC 的加权平均值。更具体地说，他们表明\\[\\begin{align}\n\\mathrm{C}_h&=\\int_0^\\infty\\mathrm{AUC}_tu(t)dt\n\\tag{7.17}\n\\end{align}\\]其中 \\(\\mathrm{AUC}_t=\\mathrm{Pr}(y_i>y_j|T_i^*=t,T_j^*>t)\\) 以及 \\(u(t)=2\\cdotp(t)\\cdot\\mathcal{S}(t)\\)。\\(\\mathrm{C}_h\\) 指数的这种等价定义为一系列全局一致性总结度量提供了可能性，这些度量基于 AUC 和权重函数 \\(u(t)\\) 的其他指定。例如，可以使用 AUC 的适当定义来构建时依标志物的一致性判别指数 (Antolini et al., 2005). 根据这种方法，Rizopoulos (2011) 提出了一种基于 (7.14) 和 (7.15) 推导出的 AUC 的动态区分指数，即\\[\\mathrm{C}_{dyn}^{\\Delta t}=\\int_0^\\infty\\mathrm{AUC}_t^{\\Delta t}u(t)dt\\]其中\\[u(t)=\\operatorname*{Pr}(T_{}^{*}>t)\\Big/\\int\\operatorname*{Pr}(T_{}^{*}>t)dt\\]其中 \\(\\Pr(T_i^*>t)\\) 为边际生存概率。选择此权重函数是因为考虑到并非所有时间点对比较的贡献均等，因为在晚期时间点，我们预计只有较少的受试者。也可以利用其他权重函数 \\(u(t)\\) 来定义动态判别指数 \\(\\mathrm{C}_{dyn}^{\\Delta t}\\) 的替代版本，并且在这方面的最佳选择仍然是一个悬而未决的问题。在实践中，我们通常会将注意力限制在固定的随访时间段 \\((0,\\tau)\\)。在这种情况下，可以修改 \\(\\mathrm{C}_{dyn}^{\\Delta t}\\) 指数以考虑有限的随访：\\[[\\mathrm{C}_{dyn}^{\\Delta t}]^\\tau=\\int_0^\\tau\\mathrm{AUC}_t^{\\Delta t}u^\\tau(t)dt\\]式中 \\(u^\\tau(t)=u(t)/\\int_0^\\tau u(t)dt.[\\mathrm{C}_{dyn}^{\\Delta t}]^\\tau\\) 仍将与随机一对受试者的预测与其结果一致的概率相关，但考虑到较小的事件时间发生在区间 \\((0, \\tau)\\) 内。","code":""},{"path":"chap7.html","id":"sec7-4-5","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.4.5 联合建模框架下的估计","text":"7.4.1 节中描述的二元设定中的灵敏度、特异度和 AUC 的估计可以简单地基于观察样本中各自频率的计算。例如，灵敏度可以估计为样本中 \\(y_i > c\\) 的受试者与患病受试者的比例。然而，在生存背景下，预期准确性测量的估计因删失而变得复杂。特别要注意的是，这些度量是根据真实事件时间变量 \\(T^*_i\\) 定义的。然而，当我们有兴趣估计比如特定时间点 \\(t\\) 的灵敏度，并且受试者在 \\(t'< t\\) 时删失，那么我们不知道她在 \\(t\\) 时的事件状态，因此她不能被分类为病例或对照。这意味着我们不能像在二元设定中那样简单地计算不同预测规则的样本中的病例数和对照数，而是需要估计真实事件时间和纵向测量值 \\(T^*_i,y_i\\)。在这方面，联合建模框架非常有利，因为它为该分发提供了完整的指定。也就是说，使用联合模型，我们可以同时考虑删失和纵向结果的内生性，此外，我们还可以通过在生存子模型的设计矩阵 \\(W\\) 中引入其他影响事件风险的基线协变量来很容易地进行调整。为了便于阐述，我们将只关注灵敏度的估计，因为特异度的估计以类似的方式进行。我们将遵循 7.1和 7.2 节中的类似方法，并推导出适当的模拟方案来产生灵敏度及其标准误的蒙特卡罗估计。更具体地说，我们观察到 (7.14) 可写为（假定以协变量为条件，但在符号中省略）：\\[\\begin{align}\n&\\Pr\\Big\\{\\mathcal{P}_i^s(t,k,c)\\mid T_i^*>t,T_i^*\\(t,t+\\Delta t];\\theta^*\\Big\\}\\\\[2ex]=&\\quad\\frac{\\Pr\\{\\mathcal{P}_i^s(t,k,c),T_i^*\\(t,t+\\Delta t]\\mid T_i^*>t;\\theta^*\\}}{1-\\Pr(T_i^*>t+\\Delta t\\mid T_i^*>t;\\theta^*)}\n\\tag{7.18}\n\\end{align}\\]其中，与前面一样，\\(\\theta^*\\) 表示真实的参数值。在假定 (4.7) 和 (4.8) 以及联合模型的定义下，我们可以得到分子和分母的进一步简化。具体地说，分子的形式为\\[\\begin{align}\n\\Pr\\{\\mathcal{P}_i^s&(t,k,c),T_i^*\\(t,t+\\Delta t]\\mid T_i^*>t;\\theta^*\\} \\\\\n&=\\quad\\int\\Pr\\{\\mathcal{P}_i^s(t,k,c),T_i^*\\(t,t+\\Delta t]\\mid T_i^*>t,b_i;\\theta^*\\}p(b_i\\mid T_i^*>t;\\theta^*)db_i \\\\\n&=\\quad\\int\\Pr\\{\\mathcal{P}_i^s(t,k,c)\\mid b_i;\\theta^*\\}\\times\\Pr\\{T_i^*\\(t,t+\\Delta t]\\mid T_i^*>t,b_i;\\theta^*\\} \\\\\n&\\times p(b_{}\\mid T_{}^{*}>t;\\theta^{*})db_{},\n\\tag{7.19}\n\\end{align}\\]其中\\[\\begin{aligned}\\Pr\\{\\mathcal{P}_i^s(t,k,c)\\mid b_i;\\theta^*\\}=\\prod_{s=k}^t\\Phi\\Big\\{\\frac{c_s-m_i(s,b_i,\\beta^*)}{\\sigma^*}\\Big\\}\\end{aligned}\\]其中 \\(\\Phi(\\cdot)\\) 表示标准正态累积分布函数，以及\\[\\Pr\\{T_i^*\\(t,t+\\Delta t]\\mid T_i^*>t,b_i;\\theta^*\\}=1-\\frac{\\mathcal{S}_i\\big\\{t+\\Delta t\\mid\\mathcal{M}_i(t+\\Delta t,b_i);\\theta^*\\big\\}}{\\mathcal{S}_i\\big\\{t\\mid\\mathcal{M}_i(t,b_i);\\theta^*\\big\\}}\\]同样地，对于分母，我们得到\\[\\begin{align}\n\\Pr(T_i^*>t+&\\Delta t\\mid T_i^*>t;\\theta^*)\\\\\n& =\\quad\\int\\Pr(T_i^*>t+\\Delta t\\mid T_i^*>t,b_i;\\theta^*)p(b_i\\mid T_i^*>t;\\theta^*)db_i  \\\\\n&=\\quad\\int\\frac{\\mathcal{S}_i\\big\\{t+\\Delta t\\mid\\mathcal{M}_i(t+\\Delta t,b_i);\\theta^*\\big\\}}{\\mathcal{S}_i\\big\\{t\\mid\\mathcal{M}_i(t,b_i);\\theta^*\\big\\}}p(b_i\\mid T_i^*>t;\\theta^*)db_i\n\\tag{7.20}\n\\end{align}\\]因此，我们观察到灵敏度被重写为如下关于边际后验分布 \\(p(b_i|T_i^*>t;\\theta^*)\\) 的期望值之比\\[\\mathcal{E}_1(b_i,\\theta)=\\left[\\prod_{s=k}^t\\Phi\\Big\\{\\frac{c_s-m_i(s,b_i,\\beta^*)}{\\sigma^*}\\Big\\}\\right]\\left[1-\\frac{\\mathcal{S}_i\\big\\{t+\\Delta t\\mid\\mathcal{M}_i(t+\\Delta t,b_i);\\theta^*\\big\\}}{\\mathcal{S}_i\\big\\{t\\mid\\mathcal{M}_i(t,b_i,\\theta);\\theta^*\\big\\}}\\right]\\]以及\\[\\mathcal{E}_2(b_i,\\theta)=\\mathcal{S}_i\\big\\{t+\\Delta t\\mid\\mathcal{M}_i(t+\\Delta t,b_i);\\theta^*\\big\\}\\bigg/\\mathcal{S}_i\\big\\{t\\mid\\mathcal{M}_i(t,b_i);\\theta^*\\big\\}\\]我们应注意到，这种后验分布与条件生存概率 (7.2) 的推导或纵向结果 (7.9) 的预测中使用的后验分布不同。具体地，在 (7.2) 和 (7.9) 中，随机效应的后验取条件于 \\(T^*_i > t\\) 和观察到的纵向历史 \\(\\mathcal Y_i(t)\\)，而在上述时依灵敏度的推导中，它仅以 \\(T^*_i>t\\) 为条件。这意味着，为了应用与 7.1.2 节中类似的模拟方案，我们首先需要用 \\(p(b_i\\mid T_i^*>t,\\mathcal{Y}_i(t);\\theta^*)\\) 来表示 \\(p(b_i\\mid T_i^*>t;\\theta^*)\\)。观察到\\[\\begin{align}\np(b_i&\\mid T_i^*>t;\\theta^*)\\propto p(T_i^*>t\\mid b_i;\\theta^*)p(b_i;\\theta^*)\\\\\n=&\\quad\\int p(T_i^*>t,\\mathcal{Y}_i(t)\\mid b_i;\\theta^*)p(b_i;\\theta^*)d\\mathcal{Y}_i(t) \\\\\n=&\\quad\\int p(\\mathcal{Y}_i(t)\\mid b_i;\\theta^*)\\mathcal{S}_i\\big\\{t\\mid\\mathcal{M}_i(t,b_i);\\theta^*\\big\\}p(b_i;\\theta^*)d\\mathcal{Y}_i(t)\n\\tag{7.21}\n\\end{align}\\]因此，结合式 (7.19)、(7.20) 和 (7.21)，并计算它们关于参数 \\(\\{\\theta\\}\\) 的渐近后验分布 \\(\\{\\theta|\\mathcal{D}_n\\}\\sim\\mathcal{N}\\{\\hat{\\theta},\\mathrm{vâr}(\\hat{\\theta})\\}\\) 的期望，我们得到以下模拟方案步骤 1：抽取 \\(\\theta^{(l)}\\sim\\mathcal{N}\\{\\hat{\\theta},\\text{vâr}(\\hat{\\theta})\\}\\)步骤 2：抽取 \\(\\mathcal{Y}_i^{(l)}(t)\\sim\\mathcal{N}\\{X_i\\beta^{(l)}+Z_ib_i^{(l-1)},[\\sigma^{(l)}]^2\\}\\)步骤 3：抽取 \\(b_i^{(l)}\\sim\\{b_i\\mid T_i^*>t,\\mathcal{Y}_i^{(l)}(t),\\theta^{(l)}\\}\\)步骤 4：计算 \\(\\mathcal{E}_1(b_i^{(l)},\\theta^{(l)})\\) 以及 \\(\\mathcal{E}_2(b_i^{(l)},\\theta^{(l)})\\)以上步骤重复 \\(l = 1,\\ldots,L\\) 次，其中 \\(L\\) 表示蒙特卡罗样本数。如前所述，步骤 1 用于解释最大似然估计的变异性，在步骤 2 中，我们在联合模型下模拟直到时间 \\(t\\) 的合理纵向历史，在步骤 3 中，我们模拟以 \\(Y^{(l)}_i(t)\\) 和 \\(T^*_i >t\\) 的纵向历史为条件的随机效应实现。最后一步只需要计算实现 \\(\\mathcal{E}_1(b_i^{(l)},\\theta^{(l)})\\) 以及 \\(\\mathcal{E}_2(b_i^{(l)},\\theta^{(l)})\\)，其比值给出灵敏度。同样，与我们在本章中看到的之前的模拟方案类似，步骤 3 使用 Metropolis-Hastings 算法实现，该算法具有来自以经验贝叶斯估计值 \\(\\hat{b}_i^{(t)}\\) 为中心的多元 \\(t\\) 分布的独立建议，并且具有尺度矩阵：这些估计的协方差阵 \\(\\operatorname{vâr}(\\widehat{b}_i^{(l)})\\)。在实现这种模拟方案时，一个小的实际问题与 \\(b_i\\) 的初始值有关。更具体地说，在 7.1.2 节和 7.2 节介绍的模拟方案中，我们将我们想要模拟的目标分布的众数 \\(\\hat b_i(t)\\) 作为 \\(b_i\\) 的初始值，因此无需热身 (burn-). 然而，在上面的方案中采用相同的初始值，其中我们的目标是从 \\(\\{b_i\\mid T_i^*>t\\}\\) 中模拟，它需要一些热身，因为该初始值可能会远离目标分布的支持。灵敏度的蒙特卡罗估计采用以下形式：\\[\\widehat{\\Pr}\\big\\{\\mathcal{P}_{}^{s}(t,k,c)\\mid T_{}^{*}>t,T_{}^{*}\\(t,t+\\Delta t]\\big\\}=\\frac{\\sum_{l}\\mathcal{E}_{1}(b_{}^{(l)},\\theta^{(l)})}{L-\\sum_{l}\\mathcal{E}_{2}(b_{}^{(l)},\\theta^{(l)})}\\]使用 \\(\\mathcal{E}_1(b_i^{(l)},\\theta^{(l)})\\) 和 \\(\\mathcal{E}_2(b_i^{(l)},\\theta^{(l)})\\) 的蒙特卡罗标准误和 Delta 法估计相应的标准误。具体地，我们有\\[s.e.\\Big(\\widehat{\\Pr}\\Big\\{\\mathcal{P}_i^s(t,k,c)\\mid T_i^*>t,T_i^*\\(t,t+\\Delta t]\\Big\\}\\Big)=\\{gVg^\\top\\}^{1/2}\\]其中\\[\\begin{aligned}g\\quad=\\quad L\\Big[1\\Big/&\\Big\\{L-\\sum_l\\mathcal{E}_2(b_i^{(l)},\\theta^{(l)})\\Big\\}\\\\&\\sum_l\\mathcal{E}_1(b_i^{(l)},\\theta^{(l)})\\Big/\\Big\\{L-\\sum_l\\mathcal{E}_2(b_i^{(l)},\\theta^{(l)})\\Big\\}^2\\Big]\\end{aligned}\\]以及\\[\\begin{aligned}\\operatorname{vech}(V)&=L^{-1}\\bigg[\\operatorname{var}\\big\\{\\mathcal{E}_1(b_i^{(l)},\\theta^{(l)})\\big\\}\\\\&\\operatorname{cov}\\big\\{\\mathcal{E}_1(b_i^{(l)},\\theta^{(l)}),\\mathcal{E}_2(b_i^{(l)},\\theta^{(l)})\\big\\},\\operatorname{var}\\big\\{\\mathcal{E}_2(b_i^{(l)},\\theta^{(l)})\\big\\}\\bigg]\\end{aligned}\\]在估计了灵敏度和特异度之后，可以直接构建相应的 ROC 曲线并额外计算 AUC. 最后，为了估计动态指数 \\(\\mathbb{C}_{dyn}^{\\Delta t}\\)，我们还需要估计边际生存函数 \\(\\mathcal{S}(t)=\\Pr(T_{}^{*}>t)\\)。正如我们在 6.1 节中看到的，这可通过使用近似表达式从拟合的联合模型获得\\[\\begin{aligned}\\mathcal{S}(t)=\\int\\mathcal{S}_i(t\\mid b_i;\\hat{\\theta})p(b_i;\\hat{\\theta})db_i\\approx n^{-1}\\sum_i\\mathcal{S}_i(t\\mid\\hat{b}_i;\\hat{\\theta})\\end{aligned}\\]或者使用 Kaplan-Meier 乘积限估计 (3.2)。此外，的 \\(\\mathbb{C}_{dyn}^{\\Delta t}\\) 分子中的积分没有封闭形式解，可以使用梯形法则、辛普森法则或高斯求积方法进行数值近似 (Press et al., 2007).","code":""},{"path":"chap7.html","id":"sec7-4-6","chapter":"第 7 章 联合模型的预测和准确性","heading":"7.4.6 在 R 中的实现","text":"我们说明了肝硬化数据集中时依判别度量的计算。具体地，我们有兴趣调查凝血酶原指数是否是一个潜在有用的标志物，可以区分上次评估后短时间内死亡的受试者和寿命更长的受试者。我们首先将一个简单的联合模型拟合到数据。对于纵向部分，我们假定每个受试者随时间的线性演变，并且我们还允许两个治疗组之间的平均演变存在差异。此外，为了捕捉每个治疗组随访早期阶段凝血酶原指数的突然变化，我们还包括一个单独的基线测量指示变量。该模型采用以下形式\\[\\begin{array}{rcl}y_i(t)&=&m_i(t)+\\varepsilon_i(t)\\\\&=&\\beta_0+\\beta_1\\mathtt{Predns}_i+\\beta_2t+\\beta_3\\mathtt{T0}_i+\\beta_4\\{\\mathtt{Predns}_i\\times t\\}\\\\&&+\\beta_5\\{\\mathtt{Predns}_i\\times\\mathtt{T0}_i\\}+b_{i0}+b_{i1}t+\\varepsilon_i(t),\\end{array}\\]其中 \\(\\mathtt{Predns}\\) 表示泼尼松治疗组的虚拟变量，\\(\\mathtt{T0}\\) 表示基线测量的虚拟变量。拟合模型的 R 代码是对于生存子模型，我们将治疗作为与时间无关的协变量，将根据纵向模型估计的凝血酶原指数的真实潜在曲线作为时依协变量，即\\[\\begin{array}{rcl}h_i(t)&=&h_0(t)\\exp\\{\\gamma\\mathtt{Predns}_i+\\alpha m_i(t)\\}\\end{array}\\]这在 R 中通过如下代码拟合：我们假设一个分段常数基线风险函数 \\(h_0(t)\\)，在观测事件时间的等距百分位数处放置六个结，我们对相应的联合模型进行拟合我们观察到凝血酶原指数与事件结局密切相关，标志物的单位减少对应于死亡风险增加为原来的 1.04 倍（95% CI：1.03, 1.05). 该标志物的时依灵敏度 (7.12) 和特异度 (7.15) 以及相应的 ROC 曲线和 AUC 可以使用在包 JM 中的函数 rocJM() 计算。此函数的语法与我们在 7.1.3 节中使用的 survfitJM() 函数非常相似，并接受拟合联合模型和数据框作为主要参数，该数据框包含基线协变量信息以及应该进行纵向测量的时间点。为了说明这一函数的使用，我们将重点放在安慰剂组的一名代表性受试者身上，他提供了基线、三个月、一年、三年和四年的五次凝血酶原指数测量。我们首先构建包含此信息的数据框函数 rocJm() 的最后一个必需参数是参数 dt，它指定医学相关的时间间隔的长度 \\(\\Delta t\\)。对于 \\(\\Delta t\\) 分别等于一年、两年和四年的情况，利用下面的调用，我们在最后可用时间点，即 \\(t=4\\)，产生判别度量的估计默认情况下，rocJM() 在基于最后可用的标志物测量的简单预测规则下运行，以区分病例和对照。输出提供 DT 的不同选项下的时依 AUC. 对于这种特定情况，我们观察到，在时间 \\(t=4\\) 时，选项 \\(\\Delta t=4\\) 提供了比其他两个稍好的区分度。列 Cut 包含标志物的阈值，可在不同 dt 选项下最大化灵敏度和特异度的乘积。尽管最佳阈值的选择直观上有吸引力并且易于计算，但我们应注意它并不总是最佳的，因此它只是作为指示提供。另一种可用于捕获特定预测规则性能的统计量是 Youden 指数，其定义为灵敏度 + 特异度 − 1 (Youden, 1950; Kraemer, 2004). 要根据 Youden 公式在 rocJM() 的输出中报告最佳阈值，用户应设置选项 optThr = \"youden\"。参数 M 指定 7.4.5 节中描述的模拟方案中的蒙特卡罗样本数，参数 burn.指定要从计算中排除的样本数。通过简单调用 plot() 函数即可生成相应的 ROC 曲线，如图 7.10 所示。\n正如 AUC 也表明的那样，我们观察到 \\(\\Delta t = 4\\) 的 ROC 曲线高于 \\(\\Delta t = 1\\) 和 \\(\\Delta t = 2\\) 的 ROC 曲线，这表明在第四年，该标志物物可以更好地区分将在 8 年前死亡的患者以及将生存超过 8 年的患者。为了检验标志物在随访期间的预测性能如何演变，我们可以绘制不同时间点的 ROC 曲线。这可以通过使用 循环适当地更新 rocJM() 的数据参数来实现。以下代码基于 plcbData 数据框说明了这一点在每次迭代中，都会考虑一行额外的 plcbData，因此我们获得了 \\(t = 0,0.25,1,3\\) 和 \\(4\\) 年时的灵敏度和特异度的估计。从 \\(t = 0.25\\) 年开始，对于 \\(\\Delta t\\) 的三个不同选项，相应的时变 ROC 曲线如图 7.11 所示。生成此图的 R 代码使用类似的 循环：\n水平实线表示当特异度设为 80% 时，三种 \\(\\Delta t\\) 选择下的灵敏度水平。随着时间的推移，我们看到三个 \\(\\Delta t\\) 选项之间的区别更加清晰，其中 \\(\\Delta t = 4\\) 比 \\(\\Delta t = 1\\) 和 \\(2\\) 提供了稍微更好的区分度。但是，一般来说，在简单的预测规则下，凝血酶原指数不能很好地将在 \\(t + \\Delta t\\) 之前死亡的患者与不会死亡的患者分开。我们继续我们的 ROC 分析，调查我们是否可以通过考虑复合预测规则来改善区分力。按照 7.4.3 节给出的示例 3，我们使用规则\\[\\begin{aligned}\\mathcal{P}_i^s(t,k,c)=\\{y_i(t-k)\\leq c\\}\\cap\\{y_i(t)\\leq0.8c\\}\\end{aligned}\\]假定患者在两次后续就诊之间凝血酶原水平下降 20% 时，在时间区间 \\((t, t+\\Delta t]\\) 内经历该事件的机会更高，其中 \\(t−k\\) 表示时间点表示倒数第二次就诊的时间点。为了在此预测规则下生成 ROC 和 AUC，我们使用 rocJM() 的参数 DiffType 和 rel.diff。在前者中，我们指定选项 \"relative\" 来表示我们对相对预测规则感兴趣，在后者中我们指定一个数字向量来表示不同时间点的阈值之间的关系，相应的语法是在上面的调用中，我们再次使用了完整的数据框 plcbData，这意味着报告的 AUC 和“最佳”分割点是针对最后一个可用时间点 \\(t = 4\\)。\\(\\Delta t\\) 的三个选项的 ROC 曲线显示在图 7.12，这是再次通过简单地调用 plot() 方法获得的图 7.11 和图 7.13 之间的比较显示，这两个规则下的时变 ROC 曲线几乎相同，这表明在这个特定的例子中，我们通过考虑复合预测规则并没有获得太多好处。作为 ROC 分析的最后一步，基于 7.3 节中关于参数选择对生存结果预测的影响的观察，我们探索了纵向结果和事件时间结果之间假定的关联结构如何影响区分。具体地，假设相同的线性混合模型来描述凝血酶原指数在时间上的潜在纵向演变，我们将考虑三个联合模型，以及相应的生存子模型\\[\\begin{array}{rcl}(\\mathrm{})&h_i(t)&=&h_0(t)\\exp\\{\\gamma\\mathtt{Predns}_i+\\alpha_1m_i(t)\\}\\\\(\\mathrm{II})&h_i(t)&=&h_0(t)\\exp\\{\\gamma\\mathtt{Predns}_i+\\alpha_2m_i'(t)\\}\\\\(\\mathrm{III})&h_i(t)&=&h_0(t)\\exp\\{\\gamma\\mathtt{Predns}_i+\\alpha_1m_i(t)+\\alpha_2m_i'(t)\\}\\end{array}\\]模型 () 是我们到目前为止在我们的分析中使用的模型，并假设在时间 \\(t\\) 的死亡风险与同一时间点的凝血酶原指数的真实值有关。模型 (II) 假设 \\(t\\) 处的风险与该时间点的真实纵向轨迹的斜率有关，而模型 \\((III)\\) 假设风险既取决于标志物的当前值，也取决于标志物轨迹的当前斜率。如前所述，为了拟合模型 (II)和(III)，我们首先需要定义包含定义 \\(m'_i(t)\\) 的固定和随机效应部分的 R 公式的列表。在我们的特定示例中，我们有\\[\\begin{array}{rcl}m_i(t)&=&\\beta_0+\\beta_1\\mathtt{Predns}_i+\\beta_2t+\\beta_3\\mathtt{T0}_i+\\beta_4\\{\\mathtt{Predns}_i\\times t\\}\\\\&&+\\beta_5\\{\\mathtt{Predns}_i\\times\\mathtt{T0}_i\\}+b_{i0}+b_{i1}t,\\end{array}\\]因此\\[m_i'(t)=\\beta_2+\\beta_4\\mathtt{Predns}_i+b_{i1}\\]对于下面列表中的固定部分和随机部分，我们将 \\(m'_i(t)\\) 转换为一对 R 公式上面列表中的组件 indFix 和 indRandom 分别给出了在 \\(m'_i(t)\\) 的指定中使用的原始 \\(m_i(t)\\) 的固定和随机效应系数向量 \\(\\beta\\) 和 \\(b_i\\) 的位置索引。也就是说，从 \\(m_i(t)\\) 的固定效应系数向量 \\(\\beta\\) 中，我们需要用于 \\(m'_i(t)\\) 指定中固定效应部分的第三个和第五个元素，类似地，随机效应的第二个元素系数向量 \\(b_i\\)。相应的联合模型符拟合语法为使用与之前类似的 rocJM() 调用，我们估计安慰剂患者在时间 \\(t = 4\\)（\\(\\Delta t = 1,2\\) 和 \\(4\\)）时这两个联合模型下的 ROC 和 AUC，并使用对患者进行分类的复合预测规则当他们在最后两次就诊期间凝血酶原水平相对下降 20% 时，即视为“病例”。即，对于模型 (II)，调用为对于模型 (III)，相应的调用是\n模型 (II) 调用中包含的额外参数 DirectionSmaller 用于定义预测规则中不等式的方向，此处凝血酶原指数的较低值表示事件。这在以前不需要设置，在模型 (III) 中也不需要，因为 rocJM() 通过当前值项 \\(m_i(t)\\) 的关联系数的符号来确定它。比较三个模型下不同 \\(\\Delta t\\) 选项的 AUC，我们观察到结合了当前值项 \\(m_i(t)\\) 和斜率项 \\(m'_i(t)\\) 的参数化似乎在某种程度上比分别具有这些项中每一项的参数化提供了更好的区分度。三个模型相应的 ROC 曲线也得出了相同的结论，如图 7.14 所示，从中可以看出，对于 80% 的特异度，模型 (III) 比其他两个模型具有更高的敏感度，特别是对于 \\(\\Delta t = 4\\)。然而，即使有了这种改进，凝血酶原指数也没有被证明是能够成功区分“病例”和“对照”的标志物。为了调查模型 (III) 是否在 10 年的主要关注期内（并且不仅在 \\(t = 4\\)）提供比其他两个模型更好的区分度，我们计算了 7.4.4 节中介绍的动态区分指数，即\\[\\begin{aligned}[\\mathrm C_{dyn}^{\\Delta t}]^\\tau&=\\frac{\\int_0^\\tau\\mathrm \\mathrm U\\mathrm C_t^{\\Delta t}\\mathcal S(t)dt}{\\int_0^\\tau\\mathcal S(t)dt}\\end{aligned}\\]其中 \\(\\tau=10\\)。作为说明，我们计算了安慰剂患者的 \\([\\text{C}_{dyn}^{\\Delta t}]^{10}\\) 和 \\(\\Delta t=4\\)。实现这一目标的第一步是计算十年期间不同时间点的时变 AUC. 我们已经选择了基线、三个月、半年、一年以及此后的每年，直到第十年；所需的信息包含在以下数据框中如前所述，时依 AUC 在 R 中使用 循环进行计算，该循环在每次迭代时都会考虑数据框 plcbData2 的额外一行三个模型每次迭代的结果分别保存在列表 ROCs.MI、ROCs.MII 和 ROCs.MIII 中。在接下来的步骤中，我们从这些列表中提取 \\(\\mathrm{AUC}_t^{\\Delta t}\\) 并计算边际函数 \\(\\mathcal S(t)\\)：具体地，sapply() 语句提取三个列表中每个列表的所有元素的 AUC 组件，并且 survival 包中的函数 survfit() 计算肝硬化数据集的 Kaplan-Meier 估计。在 survfit() 中，我们使用子集参数来估计安慰剂患者的 \\(\\mathcal S(t)\\)，然后使用 summary() 方法在感兴趣的特定时间点返回 \\(\\hat \\mathcal S_{KM} (t)\\)。我们使用梯形规则来近似 \\([\\mathrm{C}_{dyn}^{\\Delta t}]^{10}\\) 的分子和分母中的积分，一般定义为\\[\\begin{aligned}\\int_a^bf(x)dx\\approx(b-)\\frac{f()+f(b)}{2}\\end{aligned}\\]为了获得更好的精度，我们对 plcbData2 中 13 个时间点定义的 12 个子区间中的每一个子区间进行积分近似，即将 \\([\\mathrm{C}_{dyn}^{\\Delta t}]^{10}\\) 重写为\\[\\begin{aligned}[\\mathrm C_{dyn}^{\\Delta t}]^{10}&=\\frac{\\int_0^{0.25}\\mathrm \\mathrm U\\mathrm C_t^{\\Delta t}\\mathcal S(t)dt+\\int_{0.25}^{0.5}\\mathrm \\mathrm U\\mathrm C_t^{\\Delta t}\\mathcal S(t)dt+\\dots+\\int_9^{10}\\mathrm \\mathrm U\\mathrm C_t^{\\Delta t}\\mathcal S(t)dt}{\\int_0^{0.25}\\mathcal S(t)dt+\\int_{0.25}^{0.5}\\mathcal S(t)dt+\\dots+\\int_9^{10}\\mathcal S(t)dt}\\end{aligned}\\]然后我们用梯形法则近似上述每一个积分。我们可以使用 head() 和 tail() 函数灵活地定义 R 中每个积分的限 \\(\\) 和 \\(b\\)，即以类似的方式并使用梯形规则的定义，\\([\\mathrm{C}_{dyn}^{\\Delta t}]^{10}\\) 分母中的 12 个积分之和可得出：类似地，我们还根据三个联合模型中每个模型的时变 AUC 推导 \\([\\mathrm{C}_{dyn}^{\\Delta t}]^{10}\\) 分子中的 12 个积分之和最后，通过计算相应的比就可以简单地获得动态区分指数比较总结整个十年随访期间辨别能力的三个指数的值，我们观察到模型 (III) 在 \\(t = 4\\) 时显示的准确性相对于其他两个模型有所减弱。特别是，模型 () 和 (III) 提供了几乎相同的区分能力，比模型 (II) 提供的要好一些。这意味着，对于所研究的患者来说，凝血酶原指数的当前值 \\(m_i(t)\\) 似乎比真实轨迹的斜率 \\(m'_i (t)\\) 在区分方面发挥更重要的作用。","code":"> prothro$t0 <- as.numeric(prothro$time == 0)\n> lmeFitBsp.pro <- lme(pro ~ treat * (time + t0), random = ~ time | id,\n                       data = prothro)> coxFit.pro <- coxph(Surv(Time, death) ~ treat, data = prothros,\n                      x = TRUE)> jointFitBsp.pro <- jointModel(lmeFitBsp.pro, coxFit.pro,\n                                timeVar = \"time\", method = \"piecewise-PH-aGH\")\n> summary(jointFitBsp.pro)\n\n. . .\nEvent Process\n              Value Std.Err  z-value p-value\ntreatpredns  0.2211  0.1402   1.5772  0.1147\nAssoct      -0.0406  0.0036 -11.2040 <0.0001\nlog(xi.1)    1.2221  0.2612   4.6793\nlog(xi.2)    1.1222  0.2650   4.2347\nlog(xi.3)    0.6148  0.2756   2.2306\nlog(xi.4)    0.6764  0.2710   2.4961\nlog(xi.5)    0.5626  0.2786   2.0196\nlog(xi.6)    1.2004  0.3202   3.7486\nlog(xi.7)    1.7162  0.3703   4.6346\n. . .> plcbData <- data.frame(\n  id = 1,\n                         treat = factor(\"placebo\", levels = levels(prothro$treat)),\n                         time = c(0, 0.25, 1, 3, 4)\n)\n> plcbData$t0 <- as.numeric(plcbData$time == 0)\n> plcbData\n\n  id   treat time t0\n1  1 placebo 0.00  1\n2  1 placebo 0.25  0\n3  1 placebo 1.00  0\n4  1 placebo 3.00  0\n5  1 placebo 4.00  0> set.seed(123)\n> ROCplcb <- rocJM(jointFitBsp.pro, dt = c(1, 2, 4), data = plcbData,\n                   M = 1000, burn.in = 500)\n> ROCplcb\n\nAreas under the time-dependent ROC curves\n\nEstimation: Monte Carlo (500 samples)\nDifference: absolute, lag = 1 (0)\nThresholds range: (-28, 306)\n\nCase: 1\nRecorded time(s): 0, 0.25, 1, 3, 4\n dt t + dt    AUC    Cut\n  1      5 0.6799 80.216\n  2      6 0.6944 81.552\n  4      8 0.7321 85.560> plot(ROCplcb, legend = TRUE)> ROCs <- vector(\"list\", 5)\n> for (i in seq_along(ROCs)) {\n  set.seed(123)\n  ROCs[[i]] <- rocJM(jointFitBsp.pro, dt = c(1, 2, 4),\n                     data = plcbData[seq_len(i), ], M = 1000, burn.in = 500)\n}> par(mfrow = c(2, 2), oma = c(0, 0, 2, 0))\n> for (i in 2:5) {\n  plot(ROCs[[i]], legend = TRUE)\n}\n> mtext(\"Prediction rule: Simple\", side = 3, line = -1, outer = TRUE)> set.seed(123)\n> ROCplcb.Rel <- rocJM(jointFitBsp.pro, dt = c(1, 2, 4), data = plcbData,\n                       diffType = \"relative\", rel.diff = c(1, 0.8), M = 1000, burn.in = 500)\n> ROCplcb.Rel\n\nAreas under the time-dependent ROC curves\n\nEstimation: Monte Carlo (500 samples)\nDifference: relative, lag = 2 (1, 0.8)\nThresholds range: (-28, 306)\n\nCase: 1\nRecorded time(s): 0, 0.25, 1, 3, 4\n dt t + dt    AUC   Cut.1   Cut.2\n  1      5 0.6725 102.928 82.3424\n  2      6 0.6878 104.264 83.4112\n  4      8 0.7290 108.272 86.6176> plot(ROCplcb.Rel, legend = TRUE)> ROCs.r <- vector(\"list\", 5)\n> for (i in seq_along(ROCs)) {\n  set.seed(123)\n  ROCs.r[[i]] <- rocJM(jointFitBsp.pro, dt = c(1, 2, 4),\n                       data = plcbData[seq_len(i), ], diffType = \"relative\",\n                       rel.diff = c(1, 0.8), M = 1000, burn.in = 500)\n}\n\n> par(mfrow = c(2, 2), oma = c(0, 0, 2, 0))\n> for (i in 2:5) {\n  plot(ROCs.r[[i]], legend = TRUE, main = \"Prediction rule: Simple\")\n}\n> mtext(\"Prediction rule: Composite\", side = 3, line = -1, outer = TRUE)> dform2 <- list(fixed = ~ treat, indFixed = c(3, 5),\n                 random = ~ 1, indRandom = 2)> jointFitBsp2.pro <- update(jointFitBsp.pro,\n                             parameterization = \"slope\", derivForm = dform2)\n> jointFitBsp3.pro <- update(jointFitBsp.pro,\n                             parameterization = \"both\", derivForm = dform2)> set.seed(123)\n> ROCplcb.Rel2 <- rocJM(jointFitBsp2.pro, dt = c(1, 2, 4),\n                        data = plcbData, directionSmaller = TRUE, diffType = \"relative\",\n                        rel.diff = c(1, 0.8), M = 1000, burn.in = 500)\n> ROCplcb.Rel2\n\nAreas under the time-dependent ROC curves\n\nEstimation: Monte Carlo (500 samples)\nDifference: relative, lag = 2 (1, 0.8)\nThresholds range: (-28, 306)\n\nCase: 1\nRecorded time(s): 0, 0.25, 1, 3, 4\n dt t + dt    AUC   Cut.1   Cut.2\n  1      5 0.6543 105.600 84.4800\n  2      6 0.6599 105.600 84.4800\n  4      8 0.6766 109.608 87.6864> set.seed(123)\n> ROCplcb.Rel3 <- rocJM(jointFitBsp3.pro, dt = c(1, 2, 4),\n                        data = plcbData, diffType = \"relative\", rel.diff = c(1, 0.8),\n                        M = 1000, burn.in = 500)\n> ROCplcb.Rel3\n\nAreas under the time-dependent ROC curves\n\nEstimation: Monte Carlo (500 samples)\nDifference: relative, lag = 2 (1, 0.8)\nThresholds range: (-28, 306)\n\nCase: 1\nRecorded time(s): 0, 0.25, 1, 3, 4\n dt t + dt    AUC  Cut.1    Cut.2\n  1      5 0.7105  90.904 72.7232\n  2      6 0.7244  93.576 74.8608\n  4      8 0.7566 100.256 80.2048> plcbData2 <- data.frame(\n  id = 1,\n                          treat = factor(\"placebo\", levels = levels(prothro$treat)),\n                          time = c(0, 0.25, 0.5, 1:10)\n)\n> plcbData2$t0 <- as.numeric(plcbData2$time == 0)> ROCs.MI <- ROCs.MII <- ROCs.MIII <- vector(\"list\", nrow(plcbData2))\n> for (i in seq_along(ROCs.MI)) {\n  set.seed(123)\n  ROCs.MI[[i]] <- rocJM(jointFitBsp.pro, dt = 4,\n                        data = plcbData2[seq_len(i), ], diffType = \"relative\",\n                        rel.diff = c(1, 0.8), M = 1000, burn.in = 500)\n  ROCs.MII[[i]] <- rocJM(jointFitBsp2.pro, dt = 4,\n                         data = plcbData2[seq_len(i), ], directionSmaller = TRUE,\n                         diffType = \"relative\", rel.diff = c(1, 0.8),\n                         M = 1000, burn.in = 500)\n  ROCs.MIII[[i]] <- rocJM(jointFitBsp3.pro, dt = 4,\n                          data = plcbData2[seq_len(i), ], diffType = \"relative\",\n                          rel.diff = c(1, 0.8), M = 1000, burn.in = 500)\n}> AUCs.MI <- sapply(ROCs.MI, \"[[\", \"AUCs\")\n> AUCs.MII <- sapply(ROCs.MII, \"[[\", \"AUCs\")\n> AUCs.MIII <- sapply(ROCs.MIII, \"[[\", \"AUCs\")\n> sf <- survfit(Surv(Time, death) ~ treat, data = prothros,\n                subset = treat == \"placebo\")\n> Surv.Plcb <- summary(sf, times = c(0, 0.25, 0.5, 1:10))$surv> times <- c(0, 0.25, 0.5, 1:10)\n> a <- head(times, -1)\n> b <- tail(times, -1)\n> rbind(a, b)\n  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\na 0.00 0.25  0.5    1    2    3    4    5    6     7     8     9\nb 0.25 0.50  1.0    2    3    4    5    6    7     8     9    10> Denom <- sum((b - a) * (head(Surv.Plcb, -1) + tail(Surv.Plcb, -1)) / 2)> Numer.MI <- sum((b - a) * (head(AUCs.MI * Surv.Plcb, -1) +\n                               tail(AUCs.MI * Surv.Plcb, -1)) / 2)\n> Numer.MII <- sum((b - a) * (head(AUCs.MII * Surv.Plcb, -1) +\n                                tail(AUCs.MII * Surv.Plcb, -1)) / 2)\n> Numer.MIII <- sum((b - a) * (head(AUCs.MIII * Surv.Plcb, -1) +\n                                 tail(AUCs.MIII * Surv.Plcb, -1)) / 2)> Numer.MI / Denom # Cdyn Model (I)\n[1] 0.7209312\n> Numer.MII / Denom # Cdyn Model (II)\n[1] 0.6824211\n> Numer.MIII / Denom # Cdyn Model (III)\n[1] 0.7293451"},{"path":"A.html","id":"A","chapter":"A R 的简要介绍","heading":"A R 的简要介绍","text":"","code":""},{"path":"bib.html","id":"bib","chapter":"参考文献","heading":"参考文献","text":"","code":""}]
